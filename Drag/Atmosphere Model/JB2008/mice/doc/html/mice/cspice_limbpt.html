
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<HTML>

<HEAD>
   <TITLE>cspice_limbpt</TITLE>
</HEAD>

<BODY style="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);">
<A name="TOP"></A>

<table style="text-align: left; margin-left: auto; margin-right: auto; width: 800px;"
 border="0" cellpadding="5" cellspacing="2">
  <tbody>
    <tr><td>
<div align="center">
Index of Functions: 
<A HREF="index.html#A">A</A>&nbsp;
<A HREF="index.html#B">B</A>&nbsp;
<A HREF="index.html#C">C</A>&nbsp;
<A HREF="index.html#D">D</A>&nbsp;
<A HREF="index.html#E">E</A>&nbsp;
<A HREF="index.html#F">F</A>&nbsp;
<A HREF="index.html#G">G</A>&nbsp;
<A HREF="index.html#H">H</A>&nbsp;
<A HREF="index.html#I">I</A>&nbsp;
<A HREF="index.html#J">J</A>&nbsp;
<A HREF="index.html#K">K</A>&nbsp;
<A HREF="index.html#L">L</A>&nbsp;
<A HREF="index.html#M">M</A>&nbsp;
<A HREF="index.html#N">N</A>&nbsp;
<A HREF="index.html#O">O</A>&nbsp;
<A HREF="index.html#P">P</A>&nbsp;
<A HREF="index.html#Q">Q</A>&nbsp;
<A HREF="index.html#R">R</A>&nbsp;
<A HREF="index.html#S">S</A>&nbsp;
<A HREF="index.html#T">T</A>&nbsp;
<A HREF="index.html#U">U</A>&nbsp;
<A HREF="index.html#V">V</A>&nbsp;
<A HREF="index.html#W">W</A>&nbsp;
<A HREF="index.html#X">X</A>&nbsp;
</div>
</td></tr>

    <tr>
      <td style="background-color: rgb(153, 153, 153); vertical-align: middle; text-align: center;">
      <div align="right"> 
      <small><small><a href="index.html">Index Page</a></small></small>
      </div>
      <b>cspice_limbpt</b></td>
    </tr>
    

    <tr>
      <td style="vertical-align: top;">

       <br>
       <div align="left"><b>Table of contents</b></div>
       <table style="text-align: left; width: 60%; margin-left: auto; margin-right: auto;"
       border="0" cellspacing="2" cellpadding="2">
        <tbody>
          <tr>
            <td style="width: 33%; text-align: center;">
              <a href="#Abstract">Abstract<br></a>
              <a href="#I/O">I/O<br></a>
              <a href="#Parameters">Parameters<br></a>
              <big><b><a href="#Examples">Examples<br></a></b></big>
              <a href="#Particulars">Particulars<br></a>

              </td>
              <td style="vertical-align: top; width: 33%; text-align: center;">              <a href="#Exceptions">Exceptions<br></a>
              <a href="#Files">Files<br></a>
              <a href="#Restrictions">Restrictions<br></a>
              <a href="#Required_Reading">Required_Reading<br></a>
              <a href="#Literature_References">Literature_References<br></a>

              </td>
              <td style="vertical-align: top; width: 33%; text-align: center;">              <a href="#Author_and_Institution">Author_and_Institution<br></a>
              <a href="#Version">Version<br></a>
              <a href="#Index_Entries">Index_Entries<br></a>
            </td>
          </tr>
        </tbody>
</table>
<hr>


<PRE>
</pre><h4><a name="Abstract">Abstract</a></h4><pre>

   CSPICE_LIMBPT finds limb points on a target body. The limb is the set
   of points of tangency on the target of rays emanating from the observer.
   The caller specifies half-planes bounded by the observer-target
   center vector in which to search for limb points.

</pre><h4><a name="I/O">I/O</a></h4><pre>

   Given:

      method   a short string providing parameters defining the computation
               method to be used.

               [1,c1] = size(method); char = class(method)

                  or

               [1,1] = size(method); cell = class(method)

               In the syntax descriptions below, items delimited by
               brackets are optional.

               `method' may be assigned the following values:

                 'TANGENT/DSK/UNPRIORITIZED[/SURFACES = &lt;surface list&gt;]'

                     The limb point computation uses topographic data
                     provided by DSK files (abbreviated as &quot;DSK data&quot;
                     below) to model the surface of the target body. A
                     limb point is defined as the point of tangency, on
                     the surface represented by the DSK data, of a ray
                     emanating from the observer.

                     Limb points are generated within a specified set
                     of &quot;cutting&quot; half-planes that have as an edge the
                     line containing the observer-target vector.
                     Multiple limb points may be found within a given
                     half-plane, if the target body shape allows for
                     this.

                     The surface list specification is optional. The
                     syntax of the list is

                        &lt;surface 1&gt; [, &lt;surface 2&gt;...]

                     If present, it indicates that data only for the
                     listed surfaces are to be used; however, data need
                     not be available for all surfaces in the list. If
                     the list is absent, loaded DSK data for any
                     surface associated with the target body are used.

                     The surface list may contain surface names or
                     surface ID codes. Names containing blanks must
                     be delimited by double quotes, for example

                        SURFACES = &quot;Mars MEGDR 128 PIXEL/DEG&quot;

                     If multiple surfaces are specified, their names
                     or IDs must be separated by commas.

                     See the -Particulars section below for details
                     concerning use of DSK data.

                     This is the highest-accuracy method supported by
                     this routine. It generally executes much more
                     slowly than the 'GUIDED' method described below.


                 'GUIDED/DSK/UNPRIORITIZED[/SURFACES = &lt;surface list&gt;]'

                     This method uses DSK data as described above, but
                     limb points generated by this method are &quot;guided&quot;
                     so as to lie in the limb plane of the target
                     body's reference ellipsoid, on the target body's
                     surface. This method produces a unique limb point
                     for each cutting half-plane. If multiple limb
                     point candidates lie in a given cutting
                     half-plane, the outermost one is chosen.

                     This method may be used only with the 'CENTER'
                     aberration correction locus (see the description
                     of `corloc' below).

                     Limb points generated by this method are
                     approximations; they are generally not true
                     ray-surface tangent points. However, these
                     approximations can be generated much more quickly
                     than tangent points.


                 'TANGENT/ELLIPSOID'
                 'GUIDED/ELLIPSOID'

                     Both of these methods generate limb points on the
                     target body's reference ellipsoid. The 'TANGENT'
                     option may be used with any aberration correction
                     locus, while the 'GUIDED' option may be used only
                     with the 'CENTER' locus (see the description of
                     `corloc' below).

                     When the locus is set to 'CENTER', these methods
                     produce the same results.


                  Neither case nor white space are significant in
                  `method', except within double-quoted strings. For
                  example, the string ' eLLipsoid/tAnGenT ' is valid.

                  Within double-quoted strings, blank characters are
                  significant, but multiple consecutive blanks are
                  considered equivalent to a single blank. Case is
                  not significant. So

                     &quot;Mars MEGDR 128 PIXEL/DEG&quot;

                  is equivalent to

                     &quot; mars megdr  128  pixel/deg &quot;

                  but not to

                     &quot;MARS MEGDR128PIXEL/DEG&quot;


      target   the name of the target body.

               [1,c2] = size(target); char = class(target)

                  or

               [1,1] = size(target); cell = class(target)

               The target body is an extended ephemeris object.

               The string `target' is case-insensitive, and leading
               and trailing blanks in `target' are not significant.
               Optionally, you may supply a string containing the
               integer ID code for the object. For example both
               'MOON' and '301' are legitimate strings that indicate
               the Moon is the target body.

               When the target body's surface is represented by a
               tri-axial ellipsoid, this routine assumes that a
               kernel variable representing the ellipsoid's radii is
               present in the kernel pool. Normally the kernel
               variable would be defined by loading a PCK file.


      et       the epoch of participation of the observer, expressed as TDB
               seconds past J2000 TDB: `et' is the epoch at which the
               observer's state is computed.

               [1,1] = size(et); double = class(et)

               When aberration corrections are not used, `et' is also
               the epoch at which the position and orientation of
               the target body are computed.

               When aberration corrections are used, the position
               and orientation of the target body are computed at
               et-lt, where `lt' is the one-way light time between the
               aberration correction locus and the observer. The
               locus is specified by the input argument `corloc'.
               See the descriptions of `abcorr' and `corloc' below for
               details.


      fixref   the name of a body-fixed reference frame centered on the
               target body.

               [1,c3] = size(fixref); char = class(fixref)

                  or

               [1,1] = size(fixref); cell = class(fixref)

               `fixref' may be any such frame supported by the SPICE
               system, including built-in frames (documented in the Frames
               Required Reading) and frames defined by a loaded frame kernel
               (FK). The string `fixref' is case-insensitive, and leading
               and trailing blanks in `fixref' are not significant.

               The output limb points in the array `points' and the
               output observer-target tangent vectors in the array
               `tangts' are expressed relative to this reference frame.


      abcorr   indicates the aberration corrections to be applied when
               computing the target's position and orientation.

               [1,c4] = size(abcorr); char = class(abcorr)

                  or

               [1,1] = size(abcorr); cell = class(abcorr)

               Corrections are applied at the location specified by the
               aberration correction locus argument `corloc', which is
               described below.

               For remote sensing applications, where apparent limb
               points seen by the observer are desired, normally
               either of the corrections

                  'LT+S'
                  'CN+S'

               should be used. The correction 'NONE' may be suitable
               for cases in which the target is very small and the
               observer is close to, and has small velocity relative
               to, the target (e.g. comet Churyumov-Gerasimenko and
               the Rosetta Orbiter).

               These and the other supported options are described
               below. `abcorr' may be any of the following:

                  'NONE'     Apply no correction. Return the
                             geometric limb points on the target
                             body.

               Let `lt' represent the one-way light time between the
               observer and the aberration correction locus. The
               following values of `abcorr' apply to the &quot;reception&quot;
               case in which photons depart from the locus at the
               light-time corrected epoch et-lt and *arrive* at the
               observer's location at `et':


                  'LT'       Correct for one-way light time (also
                             called &quot;planetary aberration&quot;) using a
                             Newtonian formulation. This correction
                             yields the locus at the moment it
                             emitted photons arriving at the
                             observer at `et'.

                             The light time correction uses an
                             iterative solution of the light time
                             equation. The solution invoked by the
                             'LT' option uses two iterations.

                             Both the target position as seen by the
                             observer, and rotation of the target
                             body, are corrected for light time.

                  'LT+S'     Correct for one-way light time and
                             stellar aberration using a Newtonian
                             formulation. This option modifies the
                             locus obtained with the 'LT' option to
                             account for the observer's velocity
                             relative to the solar system
                             barycenter. These corrections yield
                             points on the apparent limb.

                  'CN'       Converged Newtonian light time
                             correction. In solving the light time
                             equation, the 'CN' correction iterates
                             until the solution converges. Both the
                             position and rotation of the target
                             body are corrected for light time.

                  'CN+S'     Converged Newtonian light time and
                             stellar aberration corrections. This
                             option produces a solution that is at
                             least as accurate at that obtainable
                             with the 'LT+S' option. Whether the
                             'CN+S' solution is substantially more
                             accurate depends on the geometry of the
                             participating objects and on the
                             accuracy of the input data. In all
                             cases this routine will execute more
                             slowly when a converged solution is
                             computed.

               The following values of `abcorr' apply to the
               &quot;transmission&quot; case in which photons depart from the
               observer's location at `et' and arrive at the aberration
               correction locus at the light-time corrected epoch
               et+lt:

                  'XLT'      Correct for one-way light time (also
                             called &quot;planetary aberration&quot;) using a
                             Newtonian formulation. This correction
                             yields the locus at the moment it
                             receives photons departing from the
                             observer at `et'.

                             The light time correction uses an
                             iterative solution of the light time
                             equation. The solution invoked by the
                             'LT' option uses two iterations.

                             Both the target position as seen by the
                             observer, and rotation of the target
                             body, are corrected for light time.

                  'XLT+S'    Correct for one-way transmission light
                             time and stellar aberration using a
                             Newtonian formulation. This option
                             modifies the locus obtained with the 'XLT'
                             option to account for the observer's
                             velocity relative to the solar system
                             barycenter. These corrections yield points
                             on the apparent limb.

                  'XCN'      Converged transmission Newtonian light
                             time correction. In solving the light time
                             equation, the 'XCN' correction iterates
                             until the solution converges. Both the
                             position and rotation of the target body
                             are corrected for light time.

                  'XCN+S'    Converged transmission Newtonian light
                             time and stellar aberration corrections.
                             This option produces a solution that is at
                             least as accurate at that obtainable with
                             the `XLT+S' option. Whether the 'XCN+S'
                             solution is substantially more accurate
                             depends on the geometry of the
                             participating objects and on the accuracy
                             of the input data. In all cases this
                             routine will execute more slowly when a
                             converged solution is computed.


      corloc   a string specifying the aberration correction locus: the
               point or set of points for which aberration corrections are
               performed.

               [1,c5] = size(corloc); char = class(corloc)

                  or

               [1,1] = size(corloc); cell = class(corloc)

               `corloc' may be assigned the values:

                  'CENTER'

                      Light time and stellar aberration corrections
                      are applied to the vector from the observer to
                      the center of the target body. The one way
                      light time from the target center to the
                      observer is used to determine the epoch at
                      which the target body orientation is computed.

                      This choice is appropriate for small target
                      objects for which the light time from the
                      surface to the observer varies little across
                      the entire target. It may also be appropriate
                      for large, nearly ellipsoidal targets when the
                      observer is very far from the target.

                      Computation speed for this option is faster
                      than for the 'ELLIPSOID LIMB' option.

                  'ELLIPSOID LIMB'

                      Light time and stellar aberration corrections
                      are applied to individual limb points on the
                      reference ellipsoid. For a limb point on the
                      surface described by topographic data, lying
                      in a specified cutting half-plane, the unique
                      reference ellipsoid limb point in the same
                      half-plane is used as the locus of the
                      aberration corrections.

                      This choice is appropriate for large target
                      objects for which the light time from the limb
                      to the observer is significantly different
                      from the light time from the target center to
                      the observer.

                      Because aberration corrections are repeated for
                      individual limb points, computational speed for
                      this option is relatively slow.


      obsrvr   the name of the observing body.

               [1,c6] = size(obsrvr); char = class(obsrvr)

                  or

               [1,1] = size(obsrvr); cell = class(obsrvr)

               The observing body is an ephemeris object: it typically is
               a spacecraft, the earth, or a surface point on the earth.
               `obsrvr' is case-insensitive, and leading and trailing blanks
               in `obsrvr' are not significant. Optionally, you may supply a
               string containing the integer ID code for the object. For
               example both 'MOON' and '301' are legitimate strings that
               indicate the Moon is the observer.


      refvec,
      rolstp,
      ncuts    respectively, a reference vector, a roll step
               angle, and a count of cutting half-planes.

               [3,1] = size(refvec); double = class(refvec)
               [1,1] = size(rolstp); double = class(rolstp)
               [1,1] = size(ncuts); int32 = class(ncuts)

               `refvec' defines the first of a sequence of cutting
               half-planes in which limb points are to be found.
               Each cutting half-plane has as its edge the line
               containing the observer-target vector; the first
               half-plane contains `refvec'.

               `refvec' is expressed in the body-fixed reference frame
               designated by `fixref'.

               `rolstp' is an angular step by which to roll the
               cutting half-planes about the observer-target vector.
               The first half-plane is aligned with `refvec'; the ith
               half-plane is rotated from `refvec' about the
               observer-target vector in the counter-clockwise
               direction by (i-1)*rolstp. Units are radians.
               `rolstp' should be set to

                  2*pi/ncuts

               to generate an approximately uniform distribution of
               limb points along the limb.

               `ncuts' is the number of cutting half-planes used to
               find limb points; the angular positions of
               consecutive half-planes increase in the positive
               sense (counterclockwise) about the target-observer
               vector and are distributed roughly equally about that
               vector: each half-plane has angular separation of
               approximately

                  `rolstp' radians

               from each of its neighbors. When the aberration
               correction locus is set to 'CENTER', the angular
               separation is the value above, up to round-off. When
               the locus is 'ELLIPSOID LIMB', the separations are
               less uniform due to differences in the aberration
               corrections used for the respective limb points.


      schstp,
      soltol   used only for DSK-based surfaces.

               [1,1] = size(schstp); double = class(schstp)
               [1,1] = size(soltol); double = class(soltol)

               These inputs are, respectively, the search angular step
               size and solution convergence tolerance used to find tangent
               rays and associated limb points within each cutting half
               plane. These values are used when the `method' argument
               includes the 'TANGENT' option. In this case, limb points are
               found by a two-step search process:

                  1) Bracketing: starting with the direction
                     opposite the observer-target vector, rays
                     emanating from the observer are generated
                     within the half-plane at successively greater
                     angular separations from the initial direction,
                     where the increment of angular separation is
                     `schstp'. The rays are tested for intersection
                     with the target surface. When a transition
                     between non-intersection to intersection is
                     found, the angular separation of a tangent ray
                     has been bracketed.

                  2) Root finding: each time a tangent ray is
                     bracketed, a search is done to find the angular
                     separation from the starting direction at which
                     a tangent ray exists. The search terminates
                     when successive rays are separated by no more
                     than `soltol'. When the search converges, the
                     last ray-surface intersection point found in
                     the convergence process is considered to be a
                     limb point.


                `schstp' and `soltol' have units of radians.

                Target bodies with simple surfaces---for example,
                convex shapes---will have a single limb point within
                each cutting half-plane. For such surfaces, `schstp'
                can be set large enough so that only one bracketing
                step is taken. A value greater than pi, for example
                4.0, is recommended.

                Target bodies with complex surfaces can have
                multiple limb points within a given cutting
                half-plane. To find all limb points, `schstp' must be
                set to a value smaller than the angular separation
                of any two limb points in any cutting half-plane,
                where the vertex of the angle is the observer.
                `schstp' must not be too small, or the search will be
                excessively slow.

                For both kinds of surfaces, `soltol' must be chosen so
                that the results will have the desired precision.
                Note that the choice of `soltol' required to meet a
                specified bound on limb point height errors depends
                on the observer-target distance.


      maxn     the maximum number of limb points that can be stored in the
               output array `points'.

               [1,1] = size(maxn); int32 = class(maxn)

   the call:

      [npts,   points,                                                    ...
       epochs, tangts] = <b>cspice_limbpt</b>( method, target, et,     fixref,   ...
                                        abcorr, corloc, obsrvr, refvec,   ...
                                        rolstp, ncuts,  schstp, soltol,   ...
                                        maxn    )

   returns:

      npts     an array of counts of limb points within the specified set of
               cutting half-planes.

               [1,n] = size(npts); int32 = class(npts)

               The ith element of `npts' is the limb point count in the
               ith half-plane.

               For most target bodies, there will be one limb point
               per half-plane. For complex target shapes, the limb
               point count in a given half-plane can be greater
               than one (see example 3 below), and it can be zero.


      points   an array containing the limb points found by this routine.

               [3,m] = size(points); double = class(points)

               Sets of limb points associated with half-planes are ordered
               by the indices of the half-planes in which they're found. The
               limb points in a given half-plane are ordered by decreasing
               angular separation from the observer-target direction; the
               outermost limb point in a given half-plane is the first of
               that set.

               The limb points for the half-plane containing `refvec'
               occupy array elements

                  points(1,1) through points(3,npts(1))

               Limb points for the second half plane occupy
               elements

                  points(1, npts(1)+1       ) through
                  points(3, npts(1)+npts(2) )

               and so on.

               Limb points are expressed in the reference frame
               designated by `fixref'. For each limb point, the
               orientation of the frame is evaluated at the epoch
               corresponding to the limb point; the epoch is
               provided in the output array `epochs' (described
               below).

               Units of the limb points are km.


      epochs   an array of epochs associated with the limb points,
               accounting for light time if aberration corrections are used.

               [1,m] = size(epochs); double = class(epochs)

               `epochs' contains one element for each limb point.

               The element

                  epochs(i)

               is associated with the limb point

                  points(j,i), j = 1 to 3

               If `corloc' is set to 'CENTER', all values of `epochs'
               will be the epoch associated with the target body
               center. That is, if aberration corrections are used,
               and if `lt' is the one-way light time from the target
               center to the observer, the elements of `epochs' will
               all be set to

                  et - lt

               If `corloc' is set to 'ELLIPSOID LIMB', all values of
               `epochs' for the limb points in a given half plane
               will be those for the reference ellipsoid limb point
               in that half plane. That is, if aberration
               corrections are used, and if lt(i) is the one-way
               light time to the observer from the reference
               ellipsoid limb point in the ith half plane, the
               elements of `epochs' for that half plane will all be
               set to

                  et - lt(i)

               When the target shape is given by DSK data, there
               normally will be a small difference in the light
               time between an actual limb point and that implied
               by the corresponding element of `epochs'. See the
               description of `tangts' below.


      tangts   an array of tangent vectors connecting the observer to the
               limb points.

               [3,m] = size(tangts); double = class(tangts)

               The tangent vectors are expressed in the frame designated
               by `fixref'. For the ith vector, the orientation of the frame
               is evaluated at the ith epoch provided in the output array
               `epochs' (described above).

               The elements

                  tangts(j,i), j = 1 to 3

               are associated with the limb point

                  points(j,i), j = 1 to 3

               Units of the tangent vectors are km.

               When the target shape is given by DSK data, there
               normally will be a small difference in the light
               time between an actual limb point and that implied
               by the corresponding element of `epochs'. This
               difference will affect the orientation of the target
               body-fixed frame and the output tangent vectors
               returned in the array `tangts'. All other factors
               being equal, the error in the tangent vector due to
               the light time error is proportional to the
               observer-target distance.

</pre><h4><a name="Parameters">Parameters</a></h4><pre>

   None.

</pre><h4><a name="Examples">Examples</a></h4><pre>

   Any numerical results shown for this example may differ between
   platforms as the results depend on the SPICE kernels used as input
   and the machine specific arithmetic implementation.

   1) Find apparent limb points on Phobos as seen from Mars.

      Due to Phobos' irregular shape, the TANGENT limb point
      definition will used. It suffices to compute light time and
      stellar aberration corrections for the center of Phobos, so
      the &quot;CENTER&quot; aberration correction locus will be used. Use
      converged Newtonian light time and stellar aberration
      corrections in order to model the apparent position and
      orientation of Phobos.

      For comparison, compute limb points using both ellipsoid
      and topographic shape models.

      Use the target body-fixed +Z axis as the reference direction
      for generating cutting half-planes. This choice enables the
      user to see whether the first limb point is near the target's
      north pole.

      For each option, use just three cutting half-planes, in order
      to keep the volume of output manageable. In most applications,
      the number of cuts and the number of resulting limb points
      would be much greater.

      Use the meta-kernel shown below to load the required SPICE
      kernels.


         KPL/MK

         File: limbpt_ex1.tm

         This meta-kernel is intended to support operation of SPICE
         example programs. The kernels shown here should not be
         assumed to contain adequate or correct versions of data
         required by SPICE-based user applications.

         In order for an application to use this meta-kernel, the
         kernels referenced here must be present in the user's
         current working directory.

         The names and contents of the kernels referenced
         by this meta-kernel are as follows:

            File name                        Contents
            ---------                        --------
            de430.bsp                        Planetary ephemeris
            mar097.bsp                       Mars satellite ephemeris
            pck00010.tpc                     Planet orientation and
                                             radii
            naif0011.tls                     Leapseconds
            phobos512.bds                    DSK based on
                                             Gaskell ICQ Q=512
                                             Phobos plate model


         \begindata

            KERNELS_TO_LOAD = ( 'de430.bsp',
                                'mar097.bsp',
                                'pck00010.tpc',
                                'naif0011.tls',
                                'phobos512.bds' )

         \begintext

         End of meta-kernel


      Example code begins here.


      function limbpt_ex1()

         %
         % Local constants
         %
         NMETH  =          2;
         MAXN   =      10000;

         %
         % Local variables
         %

         method = { 'TANGENT/ELLIPSOID', ...
                    'TANGENT/DSK/UNPRIORITIZED' };

         z = [ 0.0, 0.0, 1.0 ]';

         %
         % Load kernel files via the meta-kernel.
         %
         <a href="cspice_furnsh.html">cspice_furnsh</a>( 'limbpt_ex1.tm' )

         %
         % Set target, observer, and target body-fixed,
         % body-centered reference frame.
         %
         obsrvr = 'MARS';
         target = 'PHOBOS';
         fixref = 'IAU_PHOBOS';

         %
         % Set aberration correction and correction locus.
         %
         abcorr = 'CN+S';
         corloc = 'CENTER';

         %
         % Convert the UTC request time string seconds past
         % J2000, TDB.
         %
         et = <a href="cspice_str2et.html">cspice_str2et</a>( '2008 AUG 11 00:00:00');

         %
         % Compute a set of limb points using light time and
         % stellar aberration corrections. Use both ellipsoid
         % and DSK shape models. Use a step size of 100
         % microradians to ensure we don't miss the limb.
         % Set the convergence tolerance to 100 nanoradians,
         % which will limit the height error to about 1 meter.
         % Compute 3 limb points for each computation method.
         %
         schstp = 1.0d-4;
         soltol = 1.0d-7;
         ncuts  = 3;

         fprintf( ['\n'                     ...
                  'Observer:       %s\n'    ...
                  'Target:         %s\n'    ...
                  'Frame:          %s\n'    ...
                  '\n'                      ...
                  'Number of cuts: %d\n'],  ...
                  obsrvr,                   ...
                  target,                   ...
                  fixref,                   ...
                  ncuts            )

         delrol = <a href="cspice_twopi.html">cspice_twopi</a>() / ncuts;

         for i = 1:NMETH

            [ npts, points, trgeps, tangts] = <b>cspice_limbpt</b>( method(i), ...
                       target, et,     fixref,            ...
                       abcorr,    corloc, obsrvr, z,      ...
                       delrol,    ncuts,  schstp, soltol, ...
                       MAXN );

            %
            % Write the results.
            %
            fprintf ( ['\n\n'                      ...
                     'Computation method = %s\n'   ...
                     'Locus              = %s\n'], ...
                     char(method(i)),...
                     corloc                     );

            start = 0;

            for j = 1:ncuts

               roll = (j-1) * delrol;

               fprintf ( ['\n'                           ...
                        '  Roll angle (deg) = %21.9f\n'  ...
                        '     Target epoch  = %21.9f\n'  ...
                        '     Number of limb points at this ' ...
                        'roll angle: %d\n'],                  ...
                        roll * <a href="cspice_dpr.html">cspice_dpr</a>(),                  ...
                        trgeps(j),                            ...
                        npts(j)                            );

               fprintf ( '      Limb points\n' );

               for k = 1:npts(j)

                  fprintf( ' %20.9f %20.9f %20.9f\n', ...
                           points(1, k+start),        ...
                           points(2, k+start),        ...
                           points(3, k+start)        )
               end

               start = start + npts(j);
            end

         end

         fprintf ( '\n' )

         %
         % It's always good form to unload kernels after use,
         % particularly in Matlab due to data persistence.
         %
         <a href="cspice_kclear.html">cspice_kclear</a>


      When this program was executed on a Mac/Intel/Octave6.x/64-bit
      platform, the output was:


      Observer:       MARS
      Target:         PHOBOS
      Frame:          IAU_PHOBOS

      Number of cuts: 3


      Computation method = TANGENT/ELLIPSOID
      Locus              = CENTER

        Roll angle (deg) =           0.000000000
           Target epoch  =   271684865.152078211
           Number of limb points at this roll angle: 1
            Limb points
                0.016445326         -0.000306114          9.099992715

        Roll angle (deg) =         120.000000000
           Target epoch  =   271684865.152078211
           Number of limb points at this roll angle: 1
            Limb points
               -0.204288375         -9.235230829         -5.333237706

        Roll angle (deg) =         240.000000000
           Target epoch  =   271684865.152078211
           Number of limb points at this roll angle: 1
            Limb points
                0.242785221          9.234520095         -5.333231253


      Computation method = TANGENT/DSK/UNPRIORITIZED
      Locus              = CENTER

        Roll angle (deg) =           0.000000000
           Target epoch  =   271684865.152078211
           Number of limb points at this roll angle: 1
            Limb points
               -0.398901673          0.007425178          9.973720555

        Roll angle (deg) =         120.000000000
           Target epoch  =   271684865.152078211
           Number of limb points at this roll angle: 1
            Limb points
               -0.959300281         -8.537573427         -4.938700447

        Roll angle (deg) =         240.000000000
           Target epoch  =   271684865.152078211
           Number of limb points at this roll angle: 1
            Limb points
               -1.380536729          9.714334047         -5.592916790


</pre><h4><a name="Particulars">Particulars</a></h4><pre>

   Using DSK data
   ==============

      DSK loading and unloading
      -------------------------

      DSK files providing data used by this routine are loaded by
      calling <a href="cspice_furnsh.html">cspice_furnsh</a> and can be unloaded by calling <a href="cspice_unload.html">cspice_unload</a> or
      <a href="cspice_kclear.html">cspice_kclear</a>. See the documentation of cspice furnsh for limits on
      numbers of loaded DSK files.

      For run-time efficiency, it's desirable to avoid frequent
      loading and unloading of DSK files. When there is a reason to
      use multiple versions of data for a given target body---for
      example, if topographic data at varying resolutions are to be
      used---the surface list can be used to select DSK data to be
      used for a given computation. It is not necessary to unload
      the data that are not to be used. This recommendation presumes
      that DSKs containing different versions of surface data for a
      given body have different surface ID codes.


      DSK data priority
      -----------------

      A DSK coverage overlap occurs when two segments in loaded DSK
      files cover part or all of the same domain---for example, a
      given longitude-latitude rectangle---and when the time
      intervals of the segments overlap as well.

      When DSK data selection is prioritized, in case of a coverage
      overlap, if the two competing segments are in different DSK
      files, the segment in the DSK file loaded last takes
      precedence. If the two segments are in the same file, the
      segment located closer to the end of the file takes
      precedence.

      When DSK data selection is unprioritized, data from competing
      segments are combined. For example, if two competing segments
      both represent a surface as sets of triangular plates, the
      union of those sets of plates is considered to represent the
      surface.

      Currently only unprioritized data selection is supported.
      Because prioritized data selection may be the default behavior
      in a later version of the routine, the UNPRIORITIZED keyword is
      required in the `method' argument.


      Syntax of the `method' input argument
      -------------------------------------

      The keywords and surface list in the `method' argument
      are called &quot;clauses.&quot; The clauses may appear in any
      order, for example

         UMBRAL/TANGENT/DSK/UNPRIORITIZED/&lt;surface list&gt;
         DSK/UMBRAL/TANGENT/&lt;surface list&gt;/UNPRIORITIZED
         UNPRIORITIZED/&lt;surface list&gt;/DSK/TANGENT/UMBRAL

      The simplest form of the `method' argument specifying use of
      DSK data is one that lacks a surface list, for example:

         'PENUMBRAL/TANGENT/DSK/UNPRIORITIZED'
         'UMBRAL/GUIDED/DSK/UNPRIORITIZED'

      For applications in which all loaded DSK data for the target
      body are for a single surface, and there are no competing
      segments, the above strings suffice. This is expected to be
      the usual case.

      When, for the specified target body, there are loaded DSK
      files providing data for multiple surfaces for that body, the
      surfaces to be used by this routine for a given call must be
      specified in a surface list, unless data from all of the
      surfaces are to be used together.

      The surface list consists of the string

         SURFACES =

      followed by a comma-separated list of one or more surface
      identifiers. The identifiers may be names or integer codes in
      string format. For example, suppose we have the surface
      names and corresponding ID codes shown below:

         Surface Name                              ID code
         ------------                              -------
         &quot;Mars MEGDR 128 PIXEL/DEG&quot;                1
         &quot;Mars MEGDR 64 PIXEL/DEG&quot;                 2
         &quot;Mars_MRO_HIRISE&quot;                         3

      If data for all of the above surfaces are loaded, then
      data for surface 1 can be specified by either

         'SURFACES = 1'

      or

         'SURFACES = &quot;Mars MEGDR 128 PIXEL/DEG&quot;'

      Double quotes are used to delimit the surface name because
      it contains blank characters.

      To use data for surfaces 2 and 3 together, any
      of the following surface lists could be used:

         'SURFACES = 2, 3'

         'SURFACES = &quot;Mars MEGDR  64 PIXEL/DEG&quot;, 3'

         'SURFACES = 2, Mars_MRO_HIRISE'

         'SURFACES = &quot;Mars MEGDR 64 PIXEL/DEG&quot;, Mars_MRO_HIRISE'

      An example of a `method' argument that could be constructed
      using one of the surface lists above is

      'NADIR/DSK/UNPRIORITIZED/SURFACES= &quot;Mars MEGDR 64 PIXEL/DEG&quot;,3'

</pre><h4><a name="Exceptions">Exceptions</a></h4><pre>

   1)  If the specified aberration correction is unrecognized, an
       error is signaled by a routine in the call tree of this
       routine.

   2)  If either the target or observer input strings cannot be
       converted to an integer ID code, the error
       SPICE(IDCODENOTFOUND) is signaled by a routine in the call
       tree of this routine.

   3)  If `obsrvr' and `target' map to the same NAIF integer ID code, the
       error SPICE(BODIESNOTDISTINCT) is signaled by a routine in the
       call tree of this routine.

   4)  If the input target body-fixed frame `fixref' is not recognized,
       the error SPICE(NOFRAME) is signaled by a routine in the call
       tree of this routine. A frame name may fail to be recognized
       because a required frame specification kernel has not been
       loaded; another cause is a misspelling of the frame name.

   5)  If the input frame `fixref' is not centered at the target body,
       the error SPICE(INVALIDFRAME) is signaled by a routine in the
       call tree of this routine.

   6)  If the input argument `method' is not recognized, the error
       SPICE(INVALIDMETHOD) is signaled by either this routine or a
       routine in the call tree of this routine.

   7)  If `method' contains an invalid limb type, the error
       SPICE(INVALIDLIMBTYPE) is signaled by a routine in the call
       tree of this routine.

   8)  If the target and observer have distinct identities but are
       at the same location, the error SPICE(NOSEPARATION) is
       signaled by a routine in the call tree of this routine.

   9)  If insufficient ephemeris data have been loaded prior to
       calling <b>cspice_limbpt</b>, an error is signaled by a routine in
       the call tree of this routine. When light time correction is
       used, sufficient ephemeris data must be available to
       propagate the states of both observer and target to the solar
       system barycenter.

   10) If the computation method requires an ellipsoidal target shape
       and triaxial radii of the target body have not been loaded
       into the kernel pool prior to calling <b>cspice_limbpt</b>, an error is
       signaled by a routine in the call tree of this routine.

       When the target shape is modeled by topographic data, radii
       of the reference triaxial ellipsoid are still required if
       the aberration correction locus is ELLIPSOID LIMB or if
       the limb point generation method is GUIDED.

   11) If the radii are available in the kernel pool but the count
       of radii values is not three, the error SPICE(BADRADIUSCOUNT)
       is signaled by a routine in the call tree of this routine.

   12) If the target body's shape is modeled as an ellipsoid, and if
       any of the radii of the target body are non-positive, an error
       is signaled by a routine in the call tree of this routine. The
       target must be an extended body.

   13) If PCK data specifying the target body-fixed frame orientation
       have not been loaded prior to calling <b>cspice_limbpt</b>, an error is
       signaled by a routine in the call tree of this routine.

   14) If `method' specifies that the target surface is represented by
       DSK data, and no DSK files are loaded for the specified
       target, an error is signaled by a routine in the call tree
       of this routine.

   15) If the array bound `maxn' is less than 1, the error
       SPICE(INVALIDSIZE) is signaled by a routine in the call tree
       of this routine.

   16) If the number of cutting half-planes specified by `ncuts' is
       negative or greater than `maxn', the error SPICE(INVALIDCOUNT)
       is signaled by a routine in the call tree of this routine.

   17) If the aberration correction locus is not recognized, the
       error SPICE(INVALIDLOCUS) is signaled by a routine in the call
       tree of this routine.

   18) If the aberration correction locus is 'ELLIPSOID LIMB' but
       limb type is not 'TANGENT', the error SPICE(BADLIMBLOCUSMIX)
       is signaled by a routine in the call tree of this routine.

   19) If the reference vector `refvec' is the zero vector, the error
       SPICE(ZEROVECTOR) is signaled by a routine in the call tree of
       this routine.

   20) If the reference vector `refvec' and the observer target vector
       are linearly dependent, the error SPICE(DEGENERATECASE) is
       signaled by a routine in the call tree of this routine.

   21) If the limb computation uses the target ellipsoid limb plane,
       and the limb plane normal and reference vector `refvec' are
       linearly dependent, the error SPICE(DEGENERATECASE) is
       signaled by a routine in the call tree of this routine.

   22) If the limb points cannot all be stored in the output `points'
       array, the error SPICE(OUTOFROOM) is signaled by a routine in
       the call tree of this routine.

   23) If the surface is represented by DSK data, and if the search
       step is non-positive, the error SPICE(INVALIDSEARCHSTEP) is
       signaled by a routine in the call tree of this routine.

   24) If the surface is represented by DSK data, and if the search
       tolerance is non-positive, the error SPICE(INVALIDTOLERANCE)
       is signaled by a routine in the call tree of this routine.

   25) If the roll step is non-positive and `ncuts' is greater than 1,
       the error SPICE(INVALIDROLLSTEP) is signaled by a routine in
       the call tree of this routine.

   26) If any of the input arguments, `method', `target', `et',
       `fixref', `abcorr', `corloc', `obsrvr', `refvec', `rolstp',
       `ncuts', `schstp', `soltol' or `maxn', is undefined, an error
       is signaled by the Matlab error handling system.

   27) If any of the input arguments, `method', `target', `et',
       `fixref', `abcorr', `corloc', `obsrvr', `refvec', `rolstp',
       `ncuts', `schstp', `soltol' or `maxn', is not of the expected
       type, or it does not have the expected dimensions and size, an
       error is signaled by the Mice interface.

</pre><h4><a name="Files">Files</a></h4><pre>

   Appropriate kernels must be loaded by the calling program before
   this routine is called.

   The following data are required:

   -  SPK data: ephemeris data for target and observer must be
      loaded. If aberration corrections are used, the states of
      target and observer relative to the solar system barycenter
      must be calculable from the available ephemeris data.
      Typically ephemeris data are made available by loading one
      or more SPK files via <a href="cspice_furnsh.html">cspice_furnsh</a>.

   -  Target body orientation data: these may be provided in a text
      or binary PCK file. In some cases, target body orientation
      may be provided by one more more CK files. In either case,
      data are made available by loading the files via <a href="cspice_furnsh.html">cspice_furnsh</a>.

   -  Shape data for the target body:

         PCK data:

            If the target body shape is modeled as an ellipsoid,
            triaxial radii for the target body must be loaded into
            the kernel pool. Typically this is done by loading a
            text PCK file via <a href="cspice_furnsh.html">cspice_furnsh</a>.

            Triaxial radii are also needed if the target shape is
            modeled by DSK data but one or both of the GUIDED limb
            definition method or the ELLIPSOID LIMB aberration
            correction locus are selected.

         DSK data:

            If the target shape is modeled by DSK data, DSK files
            containing topographic data for the target body must be
            loaded. If a surface list is specified, data for at
            least one of the listed surfaces must be loaded.

   The following data may be required:

   -  Frame data: if a frame definition is required to convert the
      observer and target states to the body-fixed frame of the
      target, that definition must be available in the kernel
      pool. Typically the definition is supplied by loading a
      frame kernel via <a href="cspice_furnsh.html">cspice_furnsh</a>.

   -  Surface name-ID associations: if surface names are specified
      in `method', the association of these names with their
      corresponding surface ID codes must be established by
      assignments of the kernel variables

         NAIF_SURFACE_NAME
         NAIF_SURFACE_CODE
         NAIF_SURFACE_BODY

      Normally these associations are made by loading a text
      kernel containing the necessary assignments. An example
      of such a set of assignments is

         NAIF_SURFACE_NAME += 'Mars MEGDR 128 PIXEL/DEG'
         NAIF_SURFACE_CODE += 1
         NAIF_SURFACE_BODY += 499

   -  SCLK data: if the target body's orientation is provided by
      CK files, an associated SCLK kernel must be loaded.


   In all cases, kernel data are normally loaded once per program
   run, NOT every time this routine is called.

</pre><h4><a name="Restrictions">Restrictions</a></h4><pre>

   1)  The light time approximations made by this routine may be
       unsuitable for some observation geometries. For example, when
       computing the limb of Mars as seen from the Earth, the
       tangent vectors returned by this routine may be in error by
       several km due to the light time error.

</pre><h4><a name="Required_Reading">Required_Reading</a></h4><pre>

   <a href="../req/mice.html">MICE.REQ</a>
   <a href="../req/abcorr.html">ABCORR.REQ</a>
   <a href="../req/ck.html">CK.REQ</a>
   <a href="../req/dsk.html">DSK.REQ</a>
   <a href="../req/frames.html">FRAMES.REQ</a>
   <a href="../req/naif_ids.html">NAIF_IDS.REQ</a>
   <a href="../req/pck.html">PCK.REQ</a>
   <a href="../req/spk.html">SPK.REQ</a>
   <a href="../req/time.html">TIME.REQ</a>

</pre><h4><a name="Literature_References">Literature_References</a></h4><pre>

   None.

</pre><h4><a name="Author_and_Institution">Author_and_Institution</a></h4><pre>

   N.J. Bachman        (JPL)
   J. Diaz del Rio     (ODC Space)
   M. Liukis           (JPL)
   E.D. Wright         (JPL)

</pre><h4><a name="Version">Version</a></h4><pre>

   -Mice Version 2.0.0, 26-NOV-2021 (NJB) (EDW) (JDR)

       Added support for transmission aberration corrections.

       Corrected description of iteration count for non-converged
       corrections.

       Edited -Examples section to comply with NAIF standard. Added call to
       &quot;kclear&quot; in code example. Added -Parameters, -Exceptions, -Files,
       -Restrictions, -Literature_References and -Author_and_Institution
       sections.

       Eliminated use of &quot;lasterror&quot; in rethrow.

       Removed reference to the function's corresponding CSPICE header from
       -Required_Reading section.

   -Mice Version 1.0.0, 15-DEC-2016 (EDW) (NJB) (ML)

</pre><h4><a name="Index_Entries">Index_Entries</a></h4><pre>

   find limb points on target body


</PRE>

      </td>
    </tr>
  </tbody>
</table>

   <pre>Fri Dec 31 18:44:25 2021</pre>

</body>
</html>

