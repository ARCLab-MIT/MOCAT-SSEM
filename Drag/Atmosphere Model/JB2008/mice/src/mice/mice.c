/*

-Procedure  mice (MATLAB to CSPICE interfaces),

-Abstract

   The file contains the coded gateways between CSPICE and MATLAB.

-Disclaimer

   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
   CALIFORNIA INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED "AS-IS"
   TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING ANY
   WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR A
   PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.

   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY, OR NASA
   BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING, BUT NOT
   LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF ANY KIND,
   INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY AND LOST PROFITS,
   REGARDLESS OF WHETHER CALTECH, JPL, OR NASA BE ADVISED, HAVE
   REASON TO KNOW, OR, IN FACT, SHALL KNOW OF THE POSSIBILITY.

   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE OF
   THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO INDEMNIFY
   CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING FROM THE
   ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.

-Required_Reading

   MICE.REQ

-Keywords

   MATLAB

*/


/*
   Recall the mexopts.sh file contains any user defined include path
   declarations ( -I...path... ) required for the build.
*/
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include "mex.h"
#include "SpiceUsr.h"
#include "SpiceZmc.h"
#include "SpiceZfc.h"
#include "mice.h"
#include "zzmice.h"
#include "zzerror.h"
#include "zzalloc.h"
#include "cspice_params.h"


/*
   ifdefs appropriate for compile against octave.
*/
#ifndef OCTAVE

#include "matrix.h"

#endif


#ifdef OCTAVE

#define true  1
#define false 0

#endif


/*

-Brief_I/O

   None.

-Detailed_Input

   None.

-Detailed_Output

   None.

-Parameters

   Also see mice.h, zzmice.h, cspice_params.h
*/

#define  Nx2i          ConstSpiceInt(*)[2]
#define  Nx3i          ConstSpiceInt(*)[3]
#define  Nx2d          ConstSpiceDouble(*)[2]
#define  Nx3d          ConstSpiceDouble(*)[3]
#define  Nx4d          ConstSpiceDouble(*)[4]
#define  Nx6d          ConstSpiceDouble(*)[6]
#define  HASHSIZE      1999
#define  STR_LEN       255


/*
-Exceptions

-Files

   None.

-Particulars

   PLEASE DO NOT EDIT THIS FILE. IF YOU MUST EDIT THE FILE, THINK IT THROUGH.

   If you have any questions about this package, feature request, or
   find any problems, please contact the MATLAB-CSPICE interface architect
   and designer:

      Ed Wright, ed.wright@jpl.nasa.gov

   1. The first input argument passes from MATLAB in prhs[1], not prhs[0].
   plhs[0] contains the name of the interface to execute. The first output
   variable returns to MATLAB in plhs[0].

   Mice functionality depends on a number of routines provided with MATLAB by
   Mathworks. These routines (descriptions quoted from mathworks.com):

      -mxCreateNumericArray returns:

      A pointer to the created mxArray, if successful. If unsuccessful in a
      stand-alone (non MEX-file) application, mxCreateNumericArray returns
      NULL. If unsuccessful in a MEX-file, the MEX-file terminates and control
      returns to the MATLAB prompt. mxCreateNumericArray is unsuccessful when
      there is not enough free heap space to create the mxArray.

      -mxCreateString returns:

      A pointer to the created string mxArray if successful, and NULL
      otherwise. The most likely cause of failure is insufficient free
      heap space.

      -mxCreateDoubleMatrix returns:

      A pointer to the created mxArray, if successful. If unsuccessful in a
      stand-alone (non MEX-file) application, mxCreateDoubleMatrix returns
      NULL. If unsuccessful in a MEX-file, the MEX-file terminates and control
      returns to the MATLAB prompt. mxCreateDoubleMatrix is unsuccessful when
      there is not enough free heap space to create the mxArray.

      -mxCreateCharMatrixFromStrings returns:

      A pointer to the created string mxArray, if successful. If unsuccessful
      in a stand-alone (non MEX-file) application,
      mxCreateCharMatrixFromStrings returns NULL. If unsuccessful in a
      MEX-file, the MEX-file terminates and control returns to the MATLAB
      prompt. Insufficient free heap space is the primary reason for
      mxCreateCharArray to be unsuccessful. Another possible reason for
      failure is that str contains fewer than m strings.

      -mxCreateDoubleScalar returns:

      A pointer to the created mxArray, if successful. mxCreateDoubleScalar is
      unsuccessful if there is not enough free heap space to create the
      mxArray. If mxCreateDoubleScalar is unsuccessful in a MEX-file, the
      MEX-file prints an "Out of Memory" message, terminates, and control
      returns to the MATLAB prompt. If mxCreateDoubleScalar is unsuccessful
      in a stand-alone (non MEX-file) application, mxCreateDoubleScalar
      returns NULL in C (0 in Fortran).

   2. The mice_dtpool interface returns the number of values "n" associated
   with the kernel pool variable "name" as a double precision rather than an
   integer.  This implementation removes the need to recast the integer field
   "n" to double in a wrapper.

   3. The 4xN and 3xN arguments passed the CK/DSK writers do not require an
   array transpose operation since the required form for these arrays in
   MATLAB notation resolves to the correct form for passing to the CSPICE
   call, i.e. Nx4 and Nx3.

   4. Several interfaces use mxMalloc for dynamic memory allocation as this
   function returns to top level on error without the need to check for a
   failed condition.

-Examples

   None.

-Restrictions

   Equo ne credite.

-Literature_References

   Mathworks External Interfaces Reference:

      http://www.mathworks.com/access/helpdesk/help/techdoc/matlab.html

-Author_and_Institution

   N.J. Bachman        (JPL)
   G. Chinn            (JPL)
   M. Costa Sitja      (JPL)
   J. Diaz del Rio     (ODC Space)
   S.C. Krening        (JPL)
   E.D. Wright         (JPL)

-Version

*/

#define VERSION  "Mice 1.6.0 05-NOV-2021 (EDW) (JDR) (MCS)"

/*
      Added interfaces:

         cspice_azlcpo
         cspice_azlrec
         cspice_badkpv
         cspice_bltfrm
         cspice_chbder
         cspice_chbigr
         cspice_chbint
         cspice_chbval
         cspice_ckfrot
         cspice_ckfxfm
         cspice_ckgr02
         cspice_ckgr03
         cspice_cklpf
         cspice_ckmeta
         cspice_cknr02
         cspice_cknr03
         cspice_ckupf
         cspice_dafhsf
         cspice_dafps
         cspice_dafrs
         cspice_dasadc
         cspice_dasadd
         cspice_dasadi
         cspice_dashfs
         cspice_daslla
         cspice_dasllc
         cspice_dasonw
         cspice_dasops
         cspice_dasopw
         cspice_dasrdc
         cspice_dasrdd
         cspice_dasrdi
         cspice_dasudc
         cspice_dasudd
         cspice_dasudi
         cspice_daswbr
         cspice_dazldr
         cspice_dlabbs
         cspice_dlabns
         cspice_dlaens
         cspice_dlafps
         cspice_dlaopn
         cspice_dnearp
         cspice_dpmax
         cspice_dpmin
         cspice_drdazl
         cspice_ednmpt
         cspice_edpnt
         cspice_evsgp4
         cspice_expool
         cspice_getelm
         cspice_getfat
         cspice_getfvn
         cspice_hrmesp
         cspice_hrmint
         cspice_intmax
         cspice_intmin
         cspice_invstm
         cspice_kplfrm
         cspice_ldpool
         cspice_lgresp
         cspice_lgrind
         cspice_lgrint
         cspice_nextwd
         cspice_nthwd
         cspice_oscltx
         cspice_polyds
         cspice_prop2b
         cspice_qderiv
         cspice_qdq2av
         cspice_qxq
         cspice_recazl
         cspice_repmc
         cspice_repmct
         cspice_repmd
         cspice_repmf
         cspice_repmi
         cspice_repml
         cspice_repmot
         cspice_rotvec
         cspice_scfmt
         cspice_scpart
         cspice_spkapo (mice_spkapo)
         cspice_spkez  (mice_spkez)
         cspice_spkgeo (mice_spkgeo)
         cspice_spklef
         cspice_spkssb
         cspice_spkuef
         cspice_spkw09
         cspice_spkw10
         cspice_spkw13
         cspice_stelab
         cspice_stlabx
         cspice_surfpv
         cspice_szpool
         cspice_tangpt
         cspice_tipbod
         cspice_tisbod
         cspice_tkfram
         cspice_tparch
         cspice_tparse
         cspice_trgsep
         cspice_twovxf
         cspice_vprojg
         cspice_vupack

      Updated argument names, for consistency with other routines, in:

         cspice_bodfnd
         cspice_bodvrd
         cspice_ccifrm (mice_ccifrm)
         cspice_cgv2el
         cspice_ckcov
         cspice_ckobj
         cspice_ckw01
         cspice_ckw02
         cspice_ckw03
         cspice_cyllat
         cspice_cylrec
         cspice_cylsph
         cspice_dafec
         cspice_dasec
         cspice_drdcyl
         cspice_drdsph
         cspice_dskobj
         cspice_dsksrf
         cspice_ducrss
         cspice_dvcrss
         cspice_dvhat
         cspice_dvnorm
         cspice_edterm
         cspice_ekgc
         cspice_el2cgv
         cspice_et2lst
         cspice_etcal
         cspice_fovray
         cspice_fovtrg
         cspice_frame
         cspice_frinfo
         cspice_gdpool
         cspice_gfilum
         cspice_gfoclt
         cspice_gfpa
         cspice_gfrfov
         cspice_gftfov
         cspice_gnpool
         cspice_inedpl
         cspice_kdata
         cspice_kinfo
         cspice_latcyl
         cspice_latrec
         cspice_latsph
         cspice_nvc2pl
         cspice_occult
         cspice_pckcov
         cspice_pckfrm
         cspice_pdpool
         cspice_phaseq
         cspice_pl2nvc
         cspice_reccyl
         cspice_reclat
         cspice_recsph
         cspice_sphcyl
         cspice_sphlat
         cspice_sphrec
         cspice_spkcov
         cspice_spkcpt
         cspice_spkcvo
         cspice_spkcvt
         cspice_spkezr (mice_spkezr)
         cspice_spkobj
         cspice_spkw08
         cspice_srfrec
         cspice_srfscc (mice_srfscc)
         cspice_stpool
         cspice_str2et
         cspice_termpt
         cspice_tkvrsn
         cspice_tpictr
         cspice_unitim
         cspice_vperp
         cspice_vproj
         cspice_wncard
         cspice_wnelmd
         cspice_wnfild
         cspice_wnfltd
         cspice_wnincd
         cspice_wnreld
         cspice_wnsumd (mice_wnsumd)
         cspice_xfmsta

      Changed variable "sizearray" type from "int" to "mwSize" in

         cspice_ckcov
         cspice_ckobj
         cspice_dafgda
         cspice_dafgs
         cspice_dafus
         cspice_dskd02
         cspice_dski02
         cspice_dskmi2
         cspice_dskobj
         cspice_dskp02
         cspice_dsksrf
         cspice_dskv02
         cspice_dskxsi
         cspice_dskxv
         cspice_edterm
         cspice_gdpool
         cspice_getfov
         cspice_gfdist
         cspice_gfilum
         cspice_gfoclt
         cspice_gfpa
         cspice_gfposc
         cspice_gfrfov
         cspice_gfrr
         cspice_gfsep
         cspice_gfsntc
         cspice_gfsubc
         cspice_gftfov
         cspice_gipool
         cspice_latsrf
         cspice_limbpt
         cspice_pckcov
         cspice_pckfrm
         cspice_spkcov
         cspice_spkobj
         cspice_srfnrm
         cspice_termpt
         cspice_wncomd
         cspice_wndifd
         cspice_wnexpd
         cspice_wnextd
         cspice_wnfild
         cspice_wnfltd
         cspice_wninsd
         cspice_wnintd
         cspice_wnunid
         cspice_wnvald

      Changed variables "size_termpts" and "size_plateIDs" type from "int"
      to "mwSize" in cspice_term_pl02.

      Changed variables "size_spoints" and "size_plateIDs" type from "int"
      to "mwSize" in cspice_llgrid_pl02.

      Changed variables "size_limbpts" and "size_plateIDs" type from "int"
      to "mwSize" in cspice_limb_pl02.

      Changed variable "i" type from "SpiceInt" to "mwIndex" in all vectorized
      interfaces.

      Corrected error message in cspice_ckw01, cspice_ckw02 and
      cspice_ckw03.

      Corrected the first "MICE(BUG)" message in cspice_stpool.

      Fixed bug in the cspice_unload gateway that prevented vectorized calls
      to work.  The mx_str array stores the data in a column major format and
      the gateway was reading the data as if it was stored in a row major
      format.

      Fixed bug in cspice_gfoclt, cspice_gfrfov and cspice_gftfov: the input
      argument providing the maximum number of intervals to be returned was
      not doubled in order to create the "result" window.

   -Mice 1.5.0 05-JAN-2017 (EDW) (NJB)

      Added interfaces:

         cspice_bodfnd
         cspice_ccifrm (mice_ccifrm)
         cspice_dascls
         cspice_dasec
         cspice_dasopr
         cspice_dlabfs
         cspice_dlafns
         cspice_dskb02
         cspice_dskcls
         cspice_dskd02
         cspice_dskgd
         cspice_dskgtl
         cspice_dski02
         cspice_dskmi2
         cspice_dskn02
         cspice_dskobj
         cspice_dskopn
         cspice_dskp02
         cspice_dskrb2
         cspice_dsksrf
         cspice_dskstl
         cspice_dskv02
         cspice_dskw02
         cspice_dskx02
         cspice_dskxsi
         cspice_dskxv
         cspice_dskz02
         cspice_illum_pl02
         cspice_illum_plid_pl02 (mice_illum_plid_pl02)
         cspice_illumf (mice_illumf)
         cspice_illumg (mice_illumg)
         cspice_latsrf
         cspice_limb_pl02
         cspice_limbpt
         cspice_llgrid_pl02
         cspice_lspcn
         cspice_pckcov
         cspice_pckfrm
         cspice_pltar
         cspice_pltexp
         cspice_pltnp
         cspice_pltnrm
         cspice_pltvol
         cspice_srfc2s (mice_srfc2s)
         cspice_srfcss (mice_srfcss)
         cspice_srfnrm
         cspice_srfrec
         cspice_srfs2c (mice_srfs2c)
         cspice_srfscc (mice_srfscc)
         cspice_subpt_pl02
         cspice_subsol_pl02
         cspice_term_pl02
         cspice_termpt

      Vectorized interfaces:

         cspice_subpnt (mice_subpnt)
         cspice_subslr (mice_subslr)

      Macros Nx3, Nx4, Nx6 renamed Nx3d, Nx4d, Nx6d. Added macro Nx3i, Nx2d.

      Various edits to header.

      Edits to return arguments of type MiceIlum replacing the field
      name "solar" with "incdnc" (incidence).

      Corrected cspice_edterm code with regards to memory. Memory management
      worked as expected only in non-error cases. Severe error, beyond
      bug status.

      Modified cspice_daffna, cspice_daffpa routines returning a 'found'
      SpiceBoolean as

         mxCreateDoubleScalar( found )

      to

         zzmice_CreateIntScalar( found )

      SpiceBooleans should return as either integers or as
      booleans in structures.

   -Mice 1.4.0 31-OCT-2012 (EDW)(SCK)

      Added interfaces:

         cspice_cidfrm (mice_cidfrm)
         cspice_cnmfrm (mice_cnmfrm)
         cspice_dafac
         cspice_dafbbs
         cspice_dafbfs
         cspice_dafcls
         cspice_dafcs
         cspice_dafdc
         cspice_dafec
         cspice_daffna
         cspice_daffpa
         cspice_dafgda
         cspice_dafgn
         cspice_dafgs
         cspice_dafopr
         cspice_dafopw
         cspice_dafus
         cspice_dcyldr
         cspice_dgeodr
         cspice_dlatdr
         cspice_dpgrdr
         cspice_drdcyl
         cspice_drdgeo
         cspice_drdlat
         cspice_drdpgr
         cspice_drdsph
         cspice_dsphdr
         cspice_dvpool
         cspice_edlimb (mice_edlimb)
         cspice_edterm
         cspice_fovray
         cspice_fovtrg
         cspice_frame
         cspice_frinfo (mice_frinfo)
         cspice_frmnam
         cspice_gfilum
         cspice_gfpa
         cspice_gfstol
         cspice_inedpl
         cspice_inelpl
         cspice_inrypl
         cspice_invort
         cspice_namfrm
         cspice_npedln (mice_npedln)
         cspice_npelpt (mice_npelpt)
         cspice_nplnpt (mice_nplnpt)
         cspice_occult
         cspice_phaseq
         cspice_pjelpl (mice_pjelpl)
         cspice_pl2nvc
         cspice_pl2nvp
         cspice_pl2psv
         cspice_psv2pl
         cspice_pxfrm2
         cspice_spkcls
         cspice_spkcpo (mice_spkcpo)
         cspice_spkcpt (mice_spkcpt)
         cspice_spkcvo (mice_spkcvo)
         cspice_spkcvt (mice_spkcvt)
         cspice_spkopn
         cspice_spkpvn
         cspice_spksfs
         cspice_spkw08
         cspice_surfpt (mice_surfpt)
         cspice_timdef_get
         cspice_timdef_set
         cspice_vprjp
         cspice_vprjpi
         cspice_vproj
         cspice_xfmsta

      Structure MiceBodID renamed MiceNameID.

      Structure MiceSurf renamed MiceNear.

      Many, many code and comment cleanups.

      Recoded cspice_gdpool, cspice_gipool, cspice_getfov to use mxAlloc
      instead of mxCreateNumericArray, reducing memory usage and eliminating
      possible memory leak.

      Input boolean arguments pass from the Matlab layer as integers.
      Those interface routines with boolean inputs had argcheck structs
      tagging the arguments as MiceBoolean instead of MiceInt. Corrected.

      Several memcpy calls replaced with the MOVED macro.

   -Mice 1.3.0 12-JUL-2010 (EDW)

      Added an mxDestroyArray call prior to each mxSetField call. This
      eliminates a memory leak caused when returning scalar values in
      structure members (dumb bug caused by designer who should be beaten
      with a sack of soggy rutabagas).

      Corrected dimension declaration of "ptarg[6]" to "ptarg[3]"
      for spkpos_c interface.

   -Mice 1.2.0 28-APR-2010 (EDW)

      Added interfaces:

         cspice_bodc2s (mice_bodc2s)
         cspice_ducrss
         cspice_dvcrss
         cspice_dvdot
         cspice_dvhat
         cspice_dvnorm
         cspice_dvsep
         cspice_ekfind
         cspice_ekgc
         cspice_ekgd
         cspice_ekgi
         cspice_eknelt
         cspice_gfrr
         cspice_vnorm
         cspice_vperp
         cspice_unitim

      Replaced use of *mxGetLogicals for logical arguments returned
      in structure fields with the

         mxSetField( ..., mxCreateLogicalScalar(...), ... )

      construct.

      Added ifdef block to eliminate use of "matrix.h" for octave builds.
      Need to eliminate "matrix.h" during octave builds first described by
      Peter Wolff.

      Corrected failure to release allocated memory in cspice_sce2s and
      cspice_scdecd after corresponding CSPICE call failures.

      Hash size increased to 1999.

      Corrected ArgCheck structure entry for boddef_c. Input variables
      were incorrectly marked as vectorized.

   -Mice 1.1.0 23-FEB-2009 (EDW)

      Altered function of the 'size' argument' in cspice_spkcov and
      cspice_ckcov to represent the number of intervals for the workspace
      window rather than the number of values in the window.

      All interfaces that add a scalar double precision value to a structure
      use a mxSetField call.

      Added interfaces:

         cspice_el2cgv
         cspice_gfdist
         cspice_gfposc
         cspice_gfrfov
         cspice_gfsep
         cspice_gfsntc
         cspice_gfsubc
         cspice_gftfov
         cspice_lmpool
         cspice_nvc2pl
         cspice_nvp2pl
         cspice_saelgv
         cspice_vrotv
         cspice_wncard
         cspice_wnsumd (mice_wnsumd)
         cspice_wnvald

      Corrected spelling error "carfinality."

   -Mice 1.0.0 14-FEB-2008 (EDW)

-Index_Entries

   MATLAB

-&
*/


/*

Calculate/assign common values, size of the default string length.
Note, find the DEFAULT_STR_LENGTH definitions in mice.h.

*/
SpiceInt default_str_size = DEFAULT_STR_LENGTH * sizeof(SpiceChar);


/*
No need to calculate this value multiple times.
*/
SpiceInt m2 = HASHSIZE;



/*
The hashtable routines implemented by Gilbert Chinn.
*/

struct bucket
   {
   char           * key;
   void           (*binding)(int, mxArray*[], int, const mxArray*[]);
   struct bucket  * next;
   };

static struct bucket *table[HASHSIZE];


/*
-Procedure  hashtable_destroy
*/
void hashtable_destroy()
   {
   int              i;
   struct bucket  * b;

   for (i=0;i<HASHSIZE;++i)
      {
      while ( (b = table[i]) )
         {
         table[i] = table[i]->next;
         free(b);
         }
      table[i] = NULL;
      }

   }




/*
-Procedure  hashtable_lookup
*/
void ( *hashtable_lookup(char *key) )(int, mxArray*[], int, const mxArray*[])
   {
   int index =  zzhash2_(key, &m2, strlen(key));
   struct bucket  * b;

   for (b=table[index]; b; b=b->next)
      {
      if (0==strcmp(b->key,key))
         {
         return b->binding;
         }
      }

   return NULL;

   }




/*
-Procedure Bucket
*/
struct bucket *Bucket( char *key,
                       void (*binding)(int, mxArray*[], int, const mxArray*[]),
                       struct bucket *next )
   {
   struct bucket *b = malloc(sizeof(struct bucket));

   if ( b == NULL )
      {
      mexErrMsgTxt( "MICE(MALLOCFAILED): malloc failed in struct bucket. "
                    "This is a fatal error. Please contact NAIF.");
      }

   b->key      = key;
   b->binding  = binding;
   b->next     = next;
   return b;

   }




/*
-Procedure hashtable_insert
*/
void hashtable_insert(char *key,
                      void (*binding)(int, mxArray*[], int, const mxArray*[]))
   {
   int index    = zzhash2_(key, &m2, strlen(key));
   table[index] = Bucket(key, binding, table[index]);

   }




/*
Block of wrapper function calls. All calls have the same form:

   cspice_name(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[]);

      or

   mice_name(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[]);

*/

void cspice_mice(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            item  [DEFAULT_STR_LENGTH+1];
   SpiceChar            value [DEFAULT_STR_LENGTH+1];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "item",  MiceChar, 0, {0}, 0},
      { "value", MiceChar, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 1, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], item, DEFAULT_STR_LENGTH);

   /*
   Decide what to return based on the value of 'item.'

      __DATE__, a compiler directive, the date string of the compilation
      of the interface.

      __TIME__, a compiler directive, the time string of the compilation
      of the interface.

      VERSION, the string describing the version of Mice

   */
   if ( eqstr_c( "DATE", item ) )
      {
      strcpy( value, __DATE__ );
      }
   else if ( eqstr_c( "TIME", item ) )
      {
      strcpy( value, __TIME__ );
      }
   else if ( eqstr_c( "VERSION", item ) )
      {
      strcpy( value,  VERSION );
      }
   else
      {
      strcpy( value, "UNKNOWN" );
      }

   plhs[0] = mxCreateString( value );
   if ( plhs[0] == NULL )
      {
      mexErrMsgTxt( "MICE(BUG): mxCreateString failed in cspice_mice" );
      }

   }





/*

   void              axisar_c( ConstSpiceDouble     axis   [3],
                               SpiceDouble          angle,
                               SpiceDouble          r      [3][3]  );

*/
void cspice_axisar(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble  * axis;
   SpiceDouble    angle;
   SpiceDouble  * r;
   SpiceDouble    xr[3][3];

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "axis",  MiceDouble, 1, {3},    0},
      { "angle", MiceDouble, 0, {0},    0},
      { "r",     MiceDouble, 2, {3, 3}, 0},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   axis   = A_DBL_ARGV(1);
   angle  = S_DBL_ARGV(2);
   r      = A_DBL_RET_ARGV(0);

   axisar_c( axis, angle, (SpiceDouble(*)[3])xr);
   CHECK_CALL_FAILURE(SCALAR);

   xpose_c( xr, (SpiceDouble(*)[3])r );

   }




/*
   void azlcpo_c ( ConstSpiceChar    * method,
                   ConstSpiceChar    * target,
                   SpiceDouble         et,
                   ConstSpiceChar    * abcorr,
                   SpiceBoolean        azccw,
                   SpiceBoolean        elplsz,
                   ConstSpiceDouble    obspos [3],
                   ConstSpiceChar    * obsctr,
                   ConstSpiceChar    * obsref,
                   SpiceDouble         azlsta [6],
                   SpiceDouble       * lt         )
*/
void cspice_azlcpo(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            method [DEFAULT_STR_LENGTH+1];
   SpiceChar            target [DEFAULT_STR_LENGTH+1];
   SpiceDouble          et;
   SpiceChar            abcorr [DEFAULT_STR_LENGTH+1];
   SpiceBoolean         azccw;
   SpiceBoolean         elplsz;
   SpiceDouble        * obspos;
   SpiceChar            obsctr [DEFAULT_STR_LENGTH+1];
   SpiceChar            obsref [DEFAULT_STR_LENGTH+1];
   SpiceDouble        * azlsta;
   SpiceDouble        * lt;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "method",  MiceChar,     0, {0},   0},
      { "target",  MiceChar,     0, {0},   0},
      { "et",      MiceDouble,   0, {0},   0},
      { "abcorr",  MiceChar,     0, {0},   0},
      { "azccw",   MiceInt,      0, {0},   0},
      { "elplsz",  MiceInt,      0, {0},   0},
      { "obspos",  MiceDouble,   1, {3},   0},
      { "obsctr",  MiceChar,     0, {0},   0},
      { "obsref",  MiceChar,     0, {0},   0},
      { "azlsta",  MiceDouble,   1, {6},   0},
      { "lt",      MiceDouble,   0, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 9, 2 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], method, DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], target, DEFAULT_STR_LENGTH);

   et       = S_DBL_ARGV(3);

   mxGetString(prhs[4], abcorr, DEFAULT_STR_LENGTH);

   azccw    = *(SpiceBoolean*)mxGetData(prhs[5]);
   elplsz   = *(SpiceBoolean*)mxGetData(prhs[6]);

   obspos   = A_DBL_ARGV(7);

   mxGetString(prhs[8], obsctr, DEFAULT_STR_LENGTH);
   mxGetString(prhs[9], obsref, DEFAULT_STR_LENGTH);

   azlsta   = A_DBL_RET_ARGV(0);
   lt       = A_DBL_RET_ARGV(1);

   azlcpo_c ( method, target, et,     abcorr, azccw, elplsz,
              obspos, obsctr, obsref, azlsta, lt );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void azlrec_c ( SpiceDouble         range,
                   SpiceDouble         az,
                   SpiceDouble         el,
                   SpiceBoolean        azccw,
                   SpiceBoolean        elplsz,
                   SpiceDouble         rectan [3] )
*/
void cspice_azlrec(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble          range;
   SpiceDouble          az;
   SpiceDouble          el;
   SpiceBoolean         azccw;
   SpiceBoolean         elplsz;
   SpiceDouble        * rectan;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "range",   MiceDouble,   0, {0},   0},
      { "az",      MiceDouble,   0, {0},   0},
      { "el",      MiceDouble,   0, {0},   0},
      { "azccw",   MiceInt,      0, {0},   0},
      { "elplsz",  MiceInt,      0, {0},   0},
      { "rectan",  MiceDouble,   1, {3},   0},
      };

   check_arg_num( nrhs, nlhs, 5, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   range    = S_DBL_ARGV(1);
   az       = S_DBL_ARGV(2);
   el       = S_DBL_ARGV(3);

   azccw    = *(SpiceBoolean*)mxGetData(prhs[4]);
   elplsz   = *(SpiceBoolean*)mxGetData(prhs[5]);

   rectan   = A_DBL_RET_ARGV(0);

   azlrec_c ( range, az, el, azccw, elplsz, rectan );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   SpiceDouble              b1900_c( void )
*/
void cspice_b1900(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   check_arg_num( nrhs, nlhs, 0, 1 );

   /*
   Directly return the scalar value. This simple case needs no
   error checks.
   */
   plhs[0] = mxCreateDoubleScalar( b1900_c() );

   }




/*
   SpiceDouble              b1950_c( void )
*/
void cspice_b1950(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   check_arg_num( nrhs, nlhs, 0, 1 );

   /*
   Directly return the scalar value. This simple case needs no
   error checks.
   */
   plhs[0] = mxCreateDoubleScalar( b1950_c() );

   }




/*
   SpiceBoolean badkpv_c ( ConstSpiceChar    *caller,
                           ConstSpiceChar    *name,
                           ConstSpiceChar    *comp,
                           SpiceInt           size,
                           SpiceInt           divby,
                           SpiceChar          type   )
*/
void cspice_badkpv(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            caller [DEFAULT_STR_LENGTH+1];
   SpiceChar            name   [DEFAULT_STR_LENGTH+1];
   SpiceChar            comp   [DEFAULT_STR_LENGTH+1];
   SpiceInt             size;
   SpiceInt             divby;
   SpiceChar            type   [2];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "caller",  MiceChar,     0, {0},   0},
      { "name",    MiceChar,     0, {0},   0},
      { "comp",    MiceChar,     0, {0},   0},
      { "size",    MiceInt,      0, {0},   0},
      { "divby",   MiceInt,      0, {0},   0},
      { "type",    MiceChar,     0, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 6, 0 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], caller, DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], name, DEFAULT_STR_LENGTH);
   mxGetString(prhs[3], comp, DEFAULT_STR_LENGTH);

   size     = S_INT_ARGV(4);
   divby    = S_INT_ARGV(5);

   mxGetString(prhs[6], type, 2);

   /*
   Despite the use of a return variable, this interface does not return a
   value to the Matlab environment. A badkpv_c failure causes a SPICE error.
   */
   badkpv_c ( caller, name, comp, size, divby, (SpiceChar)type[0] );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void bltfrm_c ( SpiceInt      frmcls,
                   SpiceCell   * idset  )
*/
void cspice_bltfrm(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             frmcls;
   SpiceInt             room;
   SpiceInt           * idset;
   SpiceInt           * idset_f;
   mwSize               sizearr_idset[2];

   /*
   Initialize the cells with zero size and zero cardinality.
   */
   SpiceCell           idset_cell  = { SPICE_INT,
                                       0,
                                       0,
                                       0,
                                       SPICETRUE,
                                       SPICEFALSE,
                                       SPICEFALSE,
                                       NULL,
                                       NULL };


   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "frmcls",  MiceInt,      0, {0},   0},
      { "room",    MiceInt,      0, {0},   0},
      { "idset",   MiceIgnore,   0, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   frmcls   = S_INT_ARGV(1);
   room     = S_INT_ARGV(2);

   /*
   mxMalloc returns to top level on error.
   */
   idset = (SpiceInt*)
            mxMalloc( (room + SPICE_CELL_CTRLSZ)*sizeof(SpiceInt) );

   /*
   Set the struct fields to initialize the 'idset_cell' cell.
   The cardinality remains zero as this assignment occurs prior
   to use.
   */
   idset_cell.size = room;
   idset_cell.base = idset;
   idset_cell.data = &idset[SPICE_CELL_CTRLSZ];


   bltfrm_c ( frmcls, &idset_cell );

   /*
   Check for a failure signal. Free the memory assigned to 'idset'
   before signaling a Matlab error.
   */
   if ( failed_c())
      {
      mxFree( idset );

      /*
      The mice_fail call creates the error string then returns control
      to the MATLAB interpreter.
      */
      mice_fail(SCALAR);
      }

   /*
   Create an output array CARDx1.
   */
   sizearr_idset[0] = card_c( &idset_cell );
   sizearr_idset[1] = 1;

   plhs[0]  = mxCreateNumericArray( 2, sizearr_idset, mxINT32_CLASS, mxREAL);
   idset_f  = A_INT_RET_ARGV(0);

   /*
   Copy the data contents of 'idset' to 'idset_f'. The set of window data
   starts at 'idset' array index SPICE_CELL_CTRLSZ and contains
   'sizearr_idset[0]' elements.
   */
   MOVEI( idset + SPICE_CELL_CTRLSZ, sizearr_idset[0], idset_f );

   mxFree( idset );

   }




/*
   void              bodc2n_c ( SpiceInt             code,
                                SpiceInt             namelen,
                                SpiceChar          * name,
                                SpiceBoolean       * found   );
*/
void mice_bodc2n(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            name [DEFAULT_STR_LENGTH+1];
   SpiceInt             code;
   SpiceInt           * vec_code;
   SpiceBoolean         found;

   mwIndex              i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "code", MiceInt,    0, {0}, 1},
      { "name", MiceNameID, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 1, 1 );

   memset( name, 0, default_str_size );

   extra    = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_code = A_INT_ARGV(1);
   code     = *vec_code;

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         code = *(vec_code  + i*extra->offset[0]);

         bodc2n_c( code, DEFAULT_STR_LENGTH, name, &found );
         CHECK_CALL_FAILURE(i);

          mxDestroyArray( mxGetField( plhs[0], i, "name" ) );
          if ( found )
             {
             mxSetField( plhs[0], i, "name", mxCreateString(name)   );
             }
          else
             {
             mxSetField(plhs[0], i, "name", mxCreateString("\0") );
             code = 0;
             }

          mxDestroyArray( mxGetField( plhs[0], i, "code" ) );
          mxSetField( plhs[0], i, "code", zzmice_CreateIntScalar(code) );

          mxDestroyArray( mxGetField( plhs[0], i, "found" ) );
          mxSetField( plhs[0], i, "found",
                            mxCreateLogicalScalar(found ? true: false));
         }

      }
   else
      {

      bodc2n_c( code, DEFAULT_STR_LENGTH, name, &found );
      CHECK_CALL_FAILURE(SCALAR);

      mxDestroyArray( mxGetField( plhs[0], 0, "name" ) );
      if ( found )
         {
         mxSetField(plhs[0], 0, "name", mxCreateString(name)   );
         }
      else
         {
         mxSetField(plhs[0], 0, "name", mxCreateString("\0") );
         code = 0;
         }

      mxDestroyArray( mxGetField( plhs[0], 0, "code" ) );
      mxSetField( plhs[0], 0,"code", zzmice_CreateIntScalar(code)  );

      mxDestroyArray( mxGetField( plhs[0], 0, "found" ) );
      mxSetField( plhs[0], 0, "found",
                  mxCreateLogicalScalar(found ? true: false));
      }

   }



/*
   void              bodc2s_c ( SpiceInt        code,
                                SpiceInt        lenout,
                                SpiceChar     * name )

*/
void mice_bodc2s(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            name [DEFAULT_STR_LENGTH+1];
   SpiceInt             code;
   SpiceInt           * vec_code;

   mwIndex              i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "code", MiceInt,   0, {0}, 1},
      { "name", MiceNameID, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 1, 1 );

   memset( name, 0, default_str_size );

   extra    = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_code = A_INT_ARGV(1);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         code = *(vec_code  + i*extra->offset[0]);

         bodc2s_c( code, DEFAULT_STR_LENGTH, name );
         CHECK_CALL_FAILURE(i);

         mxDestroyArray( mxGetField( plhs[0], i, "name" ) );
         mxSetField( plhs[0], i, "name", mxCreateString(name) );

         mxDestroyArray( mxGetField( plhs[0], i, "code" ) );
         mxSetField( plhs[0], i, "code", zzmice_CreateIntScalar(code) );

         /*
         In this case, found should always return true.
         */
         mxDestroyArray( mxGetField( plhs[0], i, "found" ) );
         mxSetField( plhs[0], i, "found", mxCreateLogicalScalar(true) );
         }

      }
   else
      {

      code = *vec_code;

      bodc2s_c( code, DEFAULT_STR_LENGTH, name );
      CHECK_CALL_FAILURE(SCALAR);

      mxDestroyArray( mxGetField( plhs[0], 0, "name" ) );
      mxSetField( plhs[0], 0, "name", mxCreateString(name) );

      mxDestroyArray( mxGetField( plhs[0], 0, "code" ) );
      mxSetField( plhs[0], 0, "code", zzmice_CreateIntScalar(code) );

      /*
      In this case, found should always return true.
      */
      mxDestroyArray( mxGetField( plhs[0], 0, "found" ) );
      mxSetField( plhs[0], 0, "found", mxCreateLogicalScalar(true) );
      }

   }



/*
   void              boddef_c ( ConstSpiceChar     * name,
                                SpiceInt             code );

*/
void cspice_boddef(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            name [DEFAULT_STR_LENGTH+1];
   SpiceInt             code;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "name", MiceChar, 0, {0}, 0},
      { "code", MiceInt,  0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 2, 0 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], name, DEFAULT_STR_LENGTH);
   code = S_INT_ARGV(2);

   boddef_c(name,code);
   CHECK_CALL_FAILURE(SCALAR);

   }



/*
   SpiceBoolean      bodfnd_c ( SpiceInt             body,
                                ConstSpiceChar     * item );
*/
void cspice_bodfnd(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             body;
   SpiceChar            item  [DEFAULT_STR_LENGTH+1];
   SpiceBoolean       * found;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "body",   MiceInt,     0, {0}, 0},
      { "item",   MiceChar,    0, {0}, 0},
      { "bodfnd", MiceBoolean, 0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 2, 1);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   body = S_INT_ARGV(1);
   mxGetString(prhs[2], item, DEFAULT_STR_LENGTH);

   found  = A_BOOL_RET_ARGV(0);

   *found = bodfnd_c ( body, item );
   CHECK_CALL_FAILURE(SCALAR);

   }



/*
   void              bodn2c_c ( ConstSpiceChar     * name,
                                SpiceInt           * code,
                                SpiceBoolean       * found );
*/
void mice_bodn2c(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            name[DEFAULT_STR_LENGTH+1];
   mxChar             * mx_name;
   SpiceInt             code;
   SpiceBoolean         found;

   mwIndex              i;
   SpiceInt             j;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "name", MiceChar,   0, {0}, 1},
      { "code", MiceNameID, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 1, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);


   if (extra->count>1)
      {
      mx_name = (mxChar *)mxGetChars(prhs[1]);

      for (i=0;i<extra->count;i++)
         {

         /*
         Extract the string data, character by character, into
         CSPICE strings. The mx_str array stores the data in a column
         major format, we need to extract the data by rows.
         */
         for ( j=0; j<extra->offset[0]; j++)
            {
            name[j] = (SpiceChar)mx_name[i + (extra->count*j)];
            }

         name[extra->offset[0]] = '\0';

         bodn2c_c( name, &code, &found );
         CHECK_CALL_FAILURE(i);

          mxDestroyArray( mxGetField( plhs[0], i, "name") );
          if ( found )
             {
             mxSetField( plhs[0], i, "name", mxCreateString(name) );
             }
          else
             {
             mxSetField(plhs[0], i, "name",  mxCreateString("\0") );
             code = 0;
             }

          mxDestroyArray( mxGetField( plhs[0], i, "code") );
          mxSetField( plhs[0], i,"code", zzmice_CreateIntScalar(code) );

          mxDestroyArray( mxGetField( plhs[0], i, "found") );
          mxSetField( plhs[0], i, "found",
                      mxCreateLogicalScalar(found ? true: false));
         }

      }
   else
      {
      mxGetString(prhs[1], name, DEFAULT_STR_LENGTH);

      bodn2c_c( name, &code, &found );
      CHECK_CALL_FAILURE(SCALAR);

      mxDestroyArray( mxGetField( plhs[0], 0, "name") );
      if ( found )
         {
         mxSetField(plhs[0], 0, "name",  mxCreateString(name)   );
         }
      else
         {
         mxSetField(plhs[0], 0, "name",  mxCreateString("\0") );
         code = 0;
         }

      mxDestroyArray( mxGetField( plhs[0], 0, "code") );
      mxSetField( plhs[0], 0,"code", zzmice_CreateIntScalar(code) );

      mxDestroyArray( mxGetField( plhs[0], 0, "found") );
      mxSetField( plhs[0], 0, "found",
                  mxCreateLogicalScalar(found ? true: false));
      }

   }




/*
   void              bods2c_c ( ConstSpiceChar     * name,
                                SpiceInt           * code,
                                SpiceBoolean       * found );
*/
void mice_bods2c(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            name[DEFAULT_STR_LENGTH+1];
   mxChar             * mx_name;
   SpiceInt             code;
   SpiceBoolean         found;

   mwIndex              i;
   SpiceInt             j;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "name", MiceChar,   0, {0}, 1},
      { "code", MiceNameID, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 1, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);


   if (extra->count>1)
      {
      mx_name = (mxChar *)mxGetChars(prhs[1]);

      for (i=0;i<extra->count;i++)
         {

         /*
         Extract the string data, character by character, into
         CSPICE strings. The mx_str array stores the data in a column
         major format, we need to extract the data by rows.
         */
         for ( j=0; j<extra->offset[0]; j++)
            {
            name[j] = (SpiceChar)mx_name[i + (extra->count*j)];
            }

         name[extra->offset[0]] = '\0';

         bods2c_c( name, &code, &found );
         CHECK_CALL_FAILURE(i);

          mxDestroyArray( mxGetField( plhs[0], i, "name" ) );
          if ( found )
             {
             mxSetField( plhs[0], i, "name", mxCreateString(name)   );
             }
          else
             {
             mxSetField( plhs[0], i, "name", mxCreateString("\0") );
             code = 0;
             }

          mxDestroyArray( mxGetField( plhs[0], i,"code" ) );
          mxSetField( plhs[0], i,"code", zzmice_CreateIntScalar(code) );

          mxDestroyArray( mxGetField( plhs[0], i, "found" ) );
          mxSetField( plhs[0], i, "found",
                      mxCreateLogicalScalar(found ? true: false));
         }

      }
   else
      {
      mxGetString(prhs[1], name, DEFAULT_STR_LENGTH);

      bods2c_c( name, &code, &found );
      CHECK_CALL_FAILURE(SCALAR);

      mxDestroyArray( mxGetField( plhs[0], 0, "name" ) );
      if ( found )
         {
         mxSetField(plhs[0], 0, "name", mxCreateString(name)   );
         }
      else
         {
         mxSetField( plhs[0], 0, "name",  mxCreateString("\0") );
         code = 0;
         }

      mxDestroyArray( mxGetField( plhs[0], 0,"code" ) );
      mxSetField( plhs[0], 0,"code", zzmice_CreateIntScalar(code));

      mxDestroyArray( mxGetField( plhs[0], 0, "found" ) );
      mxSetField( plhs[0], 0, "found",
                  mxCreateLogicalScalar(found ? true: false));
      }

   }





/*
 void              bodvcd_c ( SpiceInt           bodyid,
                              ConstSpiceChar     * item,
                              SpiceInt             maxn,
                              SpiceInt           * dim,
                              SpiceDouble        * values );


*/
void cspice_bodvcd(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             bodyid;
   SpiceChar            item       [DEFAULT_STR_LENGTH+1];
   SpiceInt             maxn;
   SpiceInt             dim;
   SpiceDouble        * values;
   SpiceDouble          ret_values [MAXVAL];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "bodyid", MiceInt,    0, {0}, 0},
      { "item",   MiceChar,   0, {0}, 0},
      { "maxn",   MiceInt,    0, {0}, 0},
      { "values", MiceIgnore, 0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   bodyid = S_INT_ARGV(1);
   mxGetString( prhs[2], item, DEFAULT_STR_LENGTH );

   maxn = S_INT_ARGV(3);

   bodvcd_c( bodyid, item, maxn, &dim, ret_values);
   CHECK_CALL_FAILURE(SCALAR);

   /*
   Allocate the needed memory to return a vector of size 'dim'
   to MATLAB.
   */
   plhs[0]  = mxCreateDoubleMatrix( dim, 1, mxREAL );
   values   = A_DBL_RET_ARGV(0);

   MOVED( ret_values, dim, values );

   }




/*
 void              bodvrd_c ( ConstSpiceChar     * bodynm,
                              ConstSpiceChar     * item,
                              SpiceInt             maxn,
                              SpiceInt           * dim,
                              SpiceDouble        * values );

*/
void cspice_bodvrd(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            item       [DEFAULT_STR_LENGTH+1];
   SpiceChar            bodynm     [DEFAULT_STR_LENGTH+1];
   SpiceInt             maxn;
   SpiceInt             dim;
   SpiceDouble        * values;
   SpiceDouble          ret_values [MAXVAL];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "bodynm", MiceChar,   0, {0}, 0},
      { "item",   MiceChar,   0, {0}, 0},
      { "maxn",   MiceInt,    0, {0}, 0},
      { "values", MiceIgnore, 0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString( prhs[1], bodynm, DEFAULT_STR_LENGTH );
   mxGetString( prhs[2], item,   DEFAULT_STR_LENGTH );

   maxn = S_INT_ARGV(3);

   bodvrd_c(bodynm, item, maxn, &dim, ret_values);
   CHECK_CALL_FAILURE(SCALAR);

   /*
   Allocate the needed memory to return a vector of size 'dim'
   to MATLAB.
   */
   plhs[0]  = mxCreateDoubleMatrix( dim, 1, mxREAL );
   values   = A_DBL_RET_ARGV(0);

   MOVED( ret_values, dim, values );

   }




/*
   void              ccifrm_c ( SpiceInt          frclss,
                                SpiceInt          clssid,
                                SpiceInt          lenout,
                                SpiceInt        * frcode,
                                SpiceChar       * frname,
                                SpiceInt        * cent,
                                SpiceBoolean    * found   )
*/
void mice_ccifrm(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             frclss;
   SpiceInt             clssid;
   SpiceChar            frname[DEFAULT_STR_LENGTH+1];
   SpiceInt             frcode;
   SpiceInt           * cent;
   SpiceBoolean         found;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "frclss", MiceInt,    0, {0}, 0},
      { "clssid", MiceInt,    0, {0}, 0},
      { "cnmfrm", MiceNameID, 0, {0}, 0},
      { "cent",   MiceInt,    0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 2, 2 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   frclss = S_INT_ARGV(1);
   clssid = S_INT_ARGV(2);

   cent   = A_INT_RET_ARGV(1);

   (void) ccifrm_c ( frclss,
                     clssid,
                     DEFAULT_STR_LENGTH,
                     &frcode,
                     frname,
                     cent,
                     &found   );

   CHECK_CALL_FAILURE(SCALAR);

   mxDestroyArray( mxGetField( plhs[0], 0, "name" ) );
   if ( found )
      {
      mxSetField(plhs[0], 0, "name", mxCreateString(frname)   );
      }
   else
      {
      mxSetField( plhs[0], 0, "name",  mxCreateString("\0") );
      frcode = 0;
      cent = 0;
      }

   mxDestroyArray( mxGetField( plhs[0], 0,"code" ) );
   mxSetField( plhs[0], 0,"code", zzmice_CreateIntScalar(frcode));

   mxDestroyArray( mxGetField( plhs[0], 0, "found" ) );
   mxSetField( plhs[0], 0, "found",
               mxCreateLogicalScalar(found ? true: false));

   }




/*
   void              cgv2el_c ( ConstSpiceDouble    center[3],
                                ConstSpiceDouble    vec1  [3],
                                ConstSpiceDouble    vec2  [3],
                                SpiceEllipse      * ellips   );

*/
void cspice_cgv2el(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * center;
   SpiceDouble        * vec1;
   SpiceDouble        * vec2;
   SpiceEllipse         ellips;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "center", MiceDouble,  1, {3}, 0},
      { "vec1",   MiceDouble,  1, {3}, 0},
      { "vec2",   MiceDouble,  1, {3}, 0},
      { "ellips", MiceEllipse, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   center = A_DBL_ARGV(1);
   vec1   = A_DBL_ARGV(2);
   vec2   = A_DBL_ARGV(3);

   cgv2el_c ( center, vec1, vec2,  &ellips );
   CHECK_CALL_FAILURE( SCALAR );

   memcpy( mxGetPr( mxGetField( plhs[0], 0,"center") ),
           ellips.center,
           3*sizeof(SpiceDouble)
         );

   memcpy( mxGetPr( mxGetField( plhs[0], 0,"semiMajor") ),
           ellips.semiMajor,
           3*sizeof(SpiceDouble)
         );

   memcpy( mxGetPr( mxGetField( plhs[0], 0,"semiMinor") ),
           ellips.semiMinor,
           3*sizeof(SpiceDouble)
         );

   }




/*
   void chbder_c ( ConstSpiceDouble * cp,
                   SpiceInt           degp,
                   SpiceDouble        x2s[2],
                   SpiceDouble        x,
                   SpiceInt           nderiv,
                   SpiceDouble      * partdp,
                   SpiceDouble      * dpdxs )
*/
void cspice_chbder(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   ConstSpiceDouble   * cp;
   SpiceInt             degp;
   SpiceDouble        * x2s;
   SpiceDouble          x;
   SpiceInt             nderiv;
   SpiceDouble        * partdp;
   SpiceDouble        * dpdxs;

   SpiceInt             nWork;
   SpiceInt             dpdxs_size;
   SpiceDouble        * ret_dpdxs;

   SpiceInt             cplen;

   /* The message buffer to write an error message */
   char                 msg[1024];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "cp",      MiceDouble,   1, {0},   0},
      { "degp",    MiceInt,      0, {0},   0},
      { "x2s",     MiceDouble,   1, {2},   0},
      { "x",       MiceDouble,   0, {0},   0},
      { "nderiv",  MiceInt,      0, {0},   0},
      { "dpdxs",   MiceIgnore,   1, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 5, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   cp       = A_DBL_ARGV(1);
   degp     = S_INT_ARGV(2);
   x2s      = A_DBL_ARGV(3);
   x        = S_DBL_ARGV(4);
   nderiv   = S_INT_ARGV(5);

   /*
   Check that `cp' has enough data.
   */
   cplen  = A_LEN_ARGV(1);

   if ( cplen < degp+1 )
   {
      sprintf( msg, "MICE(INSUFFICIENTDATA): `cp` does not have enough "
               "data: %ld elements required; only %ld provided.",
               (long)degp+1, (long)cplen );
      mexErrMsgTxt( msg );
   }

   /*
   Allocate the workspace.

   This gateway is not following the standard approach when it comes to
   producing gateways for CSPICE wrappers of SPICELIB routines that use
   workspaces.

   Normally, the workspaces required by SPICELIB code are allocated
   within the CSPICE code, and the Mice gateways are just calling
   CSPICE, without dealing with that memory allocation.

   In the case of cspice_chbder, CSPICE does not allocate memory for the
   workspace. Instead, it requires the user to provide as input to the
   routines the workspace, and therefore the Mice gateway code must do it.

   We use mxMalloc to create a 1-dimensional array of nWork elements.
   mxMalloc returns to top level in case of error.
   */
   nWork  = 3 * (nderiv + 1);
   partdp = (SpiceDouble*) mxMalloc( nWork * sizeof(SpiceDouble) );

   /*
   Allocate the necessary memory for `ret_dpdxs'.
   mxMalloc returns to top level in case of error.
   */
   dpdxs_size = nderiv + 1;
   ret_dpdxs  = (SpiceDouble*) mxMalloc( dpdxs_size * sizeof(SpiceDouble) );

   chbder_c ( cp, degp, x2s, x, nderiv, partdp, ret_dpdxs );

   /*
   Free workspace memory.
   */
   mxFree( partdp );

   /*
   Check for a failure signal. Free the memory assigned to `ret_dpdxs'
   before signaling a Matlab error.
   */
   if ( failed_c())
      {
      mxFree( ret_dpdxs );

      /*
      The mice_fail call creates the error string then returns control
      to the MATLAB interpreter.
      */
      mice_fail(SCALAR);
      }

   /*
   Allocate the needed memory to return a vector of size `dpdxs_size'
   to MATLAB.
   */
   plhs[0]  = mxCreateDoubleMatrix( dpdxs_size, 1, mxREAL );
   dpdxs    = A_DBL_RET_ARGV(0);
   MOVED( ret_dpdxs, dpdxs_size, dpdxs );
   mxFree( ret_dpdxs );

   }




/*
   void chbigr_c ( SpiceInt            degp,
                   ConstSpiceDouble    cp     [],
                   ConstSpiceDouble    x2s    [2],
                   SpiceDouble         x,
                   SpiceDouble       * p,
                   SpiceDouble       * itgrlp     )
*/
void cspice_chbigr(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             degp;
   ConstSpiceDouble   * cp;
   SpiceDouble        * x2s;
   SpiceDouble          x;
   SpiceDouble        * p;
   SpiceDouble        * itgrlp;

   SpiceInt             cplen;

   /* The message buffer to write an error message */
   char                 msg[1024];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "degp",    MiceInt,      0, {0},   0},
      { "cp",      MiceDouble,   1, {0},   0},
      { "x2s",     MiceDouble,   1, {2},   0},
      { "x",       MiceDouble,   0, {0},   0},
      { "p",       MiceDouble,   0, {0},   0},
      { "itgrlp",  MiceDouble,   0, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 4, 2 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   degp     = S_INT_ARGV(1);
   cp       = A_DBL_ARGV(2);
   x2s      = A_DBL_ARGV(3);
   x        = S_DBL_ARGV(4);

   /*
   Check that `cp' has enough data.
   */
   cplen  = A_LEN_ARGV(2);

   if ( cplen < degp+1 )
   {
      sprintf( msg, "MICE(INSUFFICIENTDATA): `cp` does not have enough "
               "data: %ld elements required; only %ld provided.",
               (long)degp+1, (long)cplen );
      mexErrMsgTxt( msg );
   }

   p        = A_DBL_RET_ARGV(0);
   itgrlp   = A_DBL_RET_ARGV(1);

   chbigr_c ( degp, cp, x2s, x, p, itgrlp );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void chbint_c ( ConstSpiceDouble    cp     [],
                   SpiceInt            degp,
                   ConstSpiceDouble    x2s    [2],
                   SpiceDouble         x,
                   SpiceDouble       * p,
                   SpiceDouble       * dpdx       )
*/
void cspice_chbint(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   ConstSpiceDouble   * cp;
   SpiceInt             degp;
   SpiceDouble        * x2s;
   SpiceDouble          x;
   SpiceDouble        * p;
   SpiceDouble        * dpdx;

   SpiceInt             cplen;

   /* The message buffer to write an error message */
   char                 msg[1024];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "cp",      MiceDouble,   1, {0},   0},
      { "degp",    MiceInt,      0, {0},   0},
      { "x2s",     MiceDouble,   1, {2},   0},
      { "x",       MiceDouble,   0, {0},   0},
      { "p",       MiceDouble,   0, {0},   0},
      { "dpdx",    MiceDouble,   0, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 4, 2 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   cp       = A_DBL_ARGV(1);
   degp     = S_INT_ARGV(2);
   x2s      = A_DBL_ARGV(3);
   x        = S_DBL_ARGV(4);

   /*
   Check that `cp' has enough data.
   */
   cplen  = A_LEN_ARGV(1);

   if ( cplen < degp+1 )
   {
      sprintf( msg, "MICE(INSUFFICIENTDATA): `cp` does not have enough "
               "data: %ld elements required; only %ld provided.",
               (long)degp+1, (long)cplen );
      mexErrMsgTxt( msg );
   }

   p        = A_DBL_RET_ARGV(0);
   dpdx     = A_DBL_RET_ARGV(1);

   chbint_c ( cp, degp, x2s, x, p, dpdx );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void chbval_c ( ConstSpiceDouble    cp     [],
                   SpiceInt            degp,
                   ConstSpiceDouble    x2s    [2],
                   SpiceDouble         x,
                   SpiceDouble       * p          )
*/
void cspice_chbval(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   ConstSpiceDouble   * cp;
   SpiceInt             degp;
   SpiceDouble        * x2s;
   SpiceDouble          x;
   SpiceDouble        * p;

   SpiceInt             cplen;

   /* The message buffer to write an error message */
   char                 msg[1024];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "cp",      MiceDouble,   1, {0},   0},
      { "degp",    MiceInt,      0, {0},   0},
      { "x2s",     MiceDouble,   1, {2},   0},
      { "x",       MiceDouble,   0, {0},   0},
      { "p",       MiceDouble,   0, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 4, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   cp       = A_DBL_ARGV(1);
   degp     = S_INT_ARGV(2);
   x2s      = A_DBL_ARGV(3);
   x        = S_DBL_ARGV(4);

   /*
   Check that `cp' has enough data.
   */
   cplen  = A_LEN_ARGV(1);

   if ( cplen < degp+1 )
   {
      sprintf( msg, "MICE(INSUFFICIENTDATA): `cp` does not have enough "
               "data: %ld elements required; only %ld provided.",
               (long)degp+1, (long)cplen );
      mexErrMsgTxt( msg );
   }

   p        = A_DBL_RET_ARGV(0);

   chbval_c ( cp, degp, x2s, x, p );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              cidfrm_c ( SpiceInt            cent,
                                SpiceInt            lenout,
                                SpiceInt          * frcode,
                                SpiceChar         * frname,
                                SpiceBoolean      * found  );
*/
void mice_cidfrm(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             cent;
   SpiceInt           * vec_cent;
   SpiceChar            frname[DEFAULT_STR_LENGTH+1];
   SpiceInt             frcode;
   SpiceBoolean         found;

   mwIndex              i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "cent",   MiceInt,    0, {0}, 1},
      { "cnmfrm", MiceNameID, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 1, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_cent = A_INT_ARGV(1);

   if (extra->count>1)
      {
      for (i=0;i<extra->count;i++)
         {

         cent = *(vec_cent  + i*extra->offset[0]);

         cidfrm_c ( cent,
                    DEFAULT_STR_LENGTH,
                    &frcode,
                    frname,
                    &found   );
         CHECK_CALL_FAILURE(i);

         mxDestroyArray( mxGetField( plhs[0], i, "frname" ) );
         if ( found )
            {
            mxSetField( plhs[0], i, "name", mxCreateString(frname) );
            }
         else
            {
            mxSetField( plhs[0], i, "name", mxCreateString("\0") );
            frcode = 0;
            }

         mxDestroyArray( mxGetField( plhs[0], i,"code" ) );
         mxSetField( plhs[0], i,"code", zzmice_CreateIntScalar(frcode) );

         mxDestroyArray( mxGetField( plhs[0], i, "found" ) );
         mxSetField( plhs[0], i, "found",
                          mxCreateLogicalScalar(found ? true: false));
         }

      }
   else
      {

      cent = *vec_cent;

      cidfrm_c ( cent,
                 DEFAULT_STR_LENGTH,
                 &frcode,
                 frname,
                 &found   );
      CHECK_CALL_FAILURE(SCALAR);

      mxDestroyArray( mxGetField( plhs[0], 0, "name" ) );
      if ( found )
         {
         mxSetField(plhs[0], 0, "name", mxCreateString(frname)   );
         }
      else
         {
         mxSetField( plhs[0], 0, "name",  mxCreateString("\0") );
         frcode = 0;
         }

      mxDestroyArray( mxGetField( plhs[0], 0,"code" ) );
      mxSetField( plhs[0], 0,"code", zzmice_CreateIntScalar(frcode));

      mxDestroyArray( mxGetField( plhs[0], 0, "found" ) );
      mxSetField( plhs[0], 0, "found",
                  mxCreateLogicalScalar(found ? true: false));
      }

   }




/*
   void              ckcls_c  ( SpiceInt            handle )
*/
void cspice_ckcls(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             handle;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle", MiceInt, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 1, 0);

   extra  = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle = S_INT_ARGV(1);

   ckcls_c( handle );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              ckcov_c ( ConstSpiceChar    * ck,
                               SpiceInt            idcode,
                               SpiceBoolean        needav,
                               ConstSpiceChar    * level,
                               SpiceDouble         tol,
                               ConstSpiceChar    * timsys,
                               SpiceCell         * cover   )

*/
void cspice_ckcov(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {
   SpiceChar           ck    [DEFAULT_STR_LENGTH+1];
   SpiceChar           level [DEFAULT_STR_LENGTH+1];
   SpiceChar           timsys[DEFAULT_STR_LENGTH+1];
   mxChar            * mx_ck;

   mwIndex             i;
   SpiceInt            j;
   mwSize              sizearray[2];

   SpiceInt            card = 0;
   SpiceInt            size;
   SpiceInt            idcode;

   SpiceDouble       * cover_f;
   SpiceDouble       * cover;
   SpiceDouble         tol;

   SpiceBoolean        needav;

   struct extra_dims * extra;
   struct argcheck ArgCheck[] =
      {
      { "ckfnm",    MiceChar,    0, {0}, 1},
      { "idcode",   MiceInt,     0, {0}, 0},
      { "needav",   MiceInt,     0, {0}, 0},
      { "level",    MiceChar,    0, {0}, 0},
      { "tol",      MiceDouble,  0, {0}, 0},
      { "timsys",   MiceChar,    0, {0}, 0},
      { "size",     MiceInt,     0, {0}, 0},
      { "cover_f",  MiceIgnore,  0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 7, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   idcode = S_INT_ARGV(2);
   needav = *(SpiceBoolean*)mxGetData(prhs[3]);

   mxGetString(prhs[4], level, DEFAULT_STR_LENGTH);

   tol = S_DBL_ARGV(5);

   mxGetString(prhs[6], timsys, DEFAULT_STR_LENGTH);

   /*
   'size' defines the number of intervals for the workspace window,
   so double the value of size since an interval consists of
   two double precision values.
   */
   size = S_INT_ARGV(7) * 2;

   cover = (SpiceDouble*)
            mxMalloc( (size + SPICE_CELL_CTRLSZ)*sizeof(SpiceDouble)  );

   ssized_( ( integer * ) &size, ( double * ) cover );
   scardd_( ( integer * ) &card, ( double * ) cover );

   if (extra->count>1)
      {

      mx_ck = (mxChar *)mxGetChars(prhs[1]);

      for ( i=0; i<extra->count; i++)
         {

         /*
         Extract the string data, character by character, into
         CSPICE strings. The mx_str array stores the data in a column
         major format, we need to extract the data by rows.
         */
         for ( j=0; j<extra->offset[0]; j++)
            {
            ck[j] = (char)mx_ck[i + (extra->count*j)];
            }

         ck[extra->offset[0]] = '\0';

         ckcov_(  ( char       * ) ck,
                  ( integer    * ) &idcode,
                  ( logical    * ) &needav,
                  ( char       * ) level,
                  ( doublereal * ) &tol,
                  ( char       * ) timsys,
                  ( doublereal * ) (cover),
                  ( ftnlen       ) strlen(ck),
                  ( ftnlen       ) strlen(level),
                  ( ftnlen       ) strlen(timsys)  );

         /*
         Check for a failure signal. Free the memory assigned to 'cover'
         before signaling a Matlab error.
         */
         if ( failed_c())
            {
            mxFree( cover );

            /*
            The mice_fail call creates the error string then returns control
            to the MATLAB interpreter.
            */
            mice_fail(i);
            }

         }

      }
   else
      {
      mxGetString(prhs[1], ck, DEFAULT_STR_LENGTH);

      ckcov_(  ( char       * ) ck,
               ( integer    * ) &idcode,
               ( logical    * ) &needav,
               ( char       * ) level,
               ( doublereal * ) &tol,
               ( char       * ) timsys,
               ( doublereal * ) (cover),
               ( ftnlen       ) strlen(ck),
               ( ftnlen       ) strlen(level),
               ( ftnlen       ) strlen(timsys)  );

      /*
      Check for a failure signal. Free the memory assigned to 'cover'
      before signaling a Matlab error.
      */
      if ( failed_c())
         {
         mxFree( cover );

         /*
         The mice_fail call creates the error string then returns control
         to the MATLAB interpreter.
         */
         mice_fail(SCALAR);
         }

      }

   /*
   Array element 6, index 5, contains the cell cardinality. Create an output
   array CARDx1.
   */
   sizearray[0] = cover[5];
   sizearray[1] = 1;

   plhs[0] = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
   cover_f = A_DBL_RET_ARGV(0);

   /*
   Copy the data contents of 'cover' to 'cover_f'. The set of window data
   starts at 'cover' array index SPICE_CELL_CTRLSZ and contains 'cover[5]'
   elements.
   */
   MOVED( cover + SPICE_CELL_CTRLSZ, cover[5], cover_f );
   mxFree( cover );

   }




/*
   void ckfrot_c ( SpiceInt            inst,
                   SpiceDouble         et,
                   SpiceDouble         rotate [3][3],
                   SpiceInt          * ref,
                   SpiceBoolean      * found         )
*/
void cspice_ckfrot(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             inst;
   SpiceDouble          et;
   SpiceDouble        * rotate;
   SpiceDouble          ret_rotate[3][3];
   SpiceInt           * ref;
   SpiceBoolean       * found;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "inst",    MiceInt,      0, {0},   0},
      { "et",      MiceDouble,   0, {0},   0},
      { "rotate",  MiceDouble,   2, {3,3}, 0},
      { "ref",     MiceInt,      0, {0},   0},
      { "found",   MiceBoolean,  0, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 2, 3 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   inst     = S_INT_ARGV(1);
   et       = S_DBL_ARGV(2);

   rotate   = A_DBL_RET_ARGV(0);
   ref      = A_INT_RET_ARGV(1);
   found    = A_BOOL_RET_ARGV(2);

   ckfrot_c ( inst, et, (SpiceDouble(*)[3])ret_rotate, ref, found );
   CHECK_CALL_FAILURE(SCALAR);

   xpose_c ( ret_rotate, (SpiceDouble(*)[3])rotate );

   }




/*
   void ckfxfm_c ( SpiceInt            inst,
                   SpiceDouble         et,
                   SpiceDouble         xform  [6][6],
                   SpiceInt          * ref,
                   SpiceBoolean      * found         )
*/
void cspice_ckfxfm(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             inst;
   SpiceDouble          et;
   SpiceDouble        * xform;
   SpiceDouble          ret_xform[6][6];
   SpiceInt           * ref;
   SpiceBoolean       * found;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "inst",    MiceInt,      0, {0},   0},
      { "et",      MiceDouble,   0, {0},   0},
      { "xform",   MiceDouble,   2, {6,6}, 0},
      { "ref",     MiceInt,      0, {0},   0},
      { "found",   MiceBoolean,  0, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 2, 3 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   inst     = S_INT_ARGV(1);
   et       = S_DBL_ARGV(2);

   xform    = A_DBL_RET_ARGV(0);
   ref      = A_INT_RET_ARGV(1);
   found    = A_BOOL_RET_ARGV(2);

   ckfxfm_c ( inst, et, (SpiceDouble(*)[6])ret_xform, ref, found );
   CHECK_CALL_FAILURE(SCALAR);

   xpose6_c ( ret_xform, (SpiceDouble(*)[6])xform );

   }




/*
   void              ckgp_c( SpiceInt            inst,
                              SpiceDouble         sclkdp,
                              SpiceDouble         tol,
                              ConstSpiceChar    * ref,
                              SpiceDouble         cmat[3][3],
                              SpiceDouble       * clkout,
                              SpiceBoolean      * found      )
*/
void cspice_ckgp(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_sclkdp;
   SpiceDouble        * vec_cmat;
   SpiceDouble        * vec_clkout;
   SpiceBoolean       * vec_found;
   SpiceInt             inst;
   SpiceDouble          sclkdp;
   SpiceDouble          tol;
   SpiceChar            ref[DEFAULT_STR_LENGTH+1];
   SpiceDouble        * cmat;
   SpiceDouble        * clkout;
   SpiceBoolean       * found;
   SpiceDouble          xr[3][3];

   mwIndex              i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "inst",   MiceInt,     0, {0},    0},
      { "sclkdp", MiceDouble,  0, {0},    1},
      { "tol",    MiceDouble,  0, {0},    0},
      { "ref",    MiceChar,    0, {0},    0},
      { "cmat",   MiceDouble,  2, {3, 3}, 1},
      { "clkout", MiceDouble,  0, {0},    1},
      { "found",  MiceBoolean, 0, {0},    1},
      };

   check_arg_num( nrhs, nlhs, 4, 3);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_sclkdp = A_DBL_ARGV(2);
   inst       = S_INT_ARGV(1);
   sclkdp     = *(vec_sclkdp);
   tol        = S_DBL_ARGV(3);

   mxGetString(prhs[4], ref, DEFAULT_STR_LENGTH);

   vec_cmat   = A_DBL_RET_ARGV(0);
   vec_clkout = A_DBL_RET_ARGV(1);
   vec_found  = A_BOOL_RET_ARGV(2);

   if (extra->count>1)
      {
      for (i=0;i<extra->count;i++)
         {
         sclkdp = *(vec_sclkdp + i*extra->offset[1]);
         cmat   =  (vec_cmat   + i*extra->offset[4]);
         clkout =  (vec_clkout + i*extra->offset[5]);
         found  =  (vec_found  + i*extra->offset[6]);

         ckgp_c(inst, sclkdp, tol, ref,
                (SpiceDouble(*)[3])xr, clkout, found);
         CHECK_CALL_FAILURE(i);

         xpose_c( xr, (SpiceDouble(*)[3])cmat);

         }

      }
   else
      {
      cmat   = vec_cmat;
      clkout = vec_clkout;
      found  = vec_found;

      ckgp_c(inst, sclkdp, tol, ref, (SpiceDouble(*)[3])xr, clkout, found);
      CHECK_CALL_FAILURE(SCALAR);

      xpose_c( xr, (SpiceDouble(*)[3])cmat);

      }

   }




/*
   void              ckgpav_c( SpiceInt            inst,
                                SpiceDouble         sclkdp,
                                SpiceDouble         tol,
                                ConstSpiceChar    * ref,
                                SpiceDouble         cmat[3][3],
                                SpiceDouble         av[3],
                                SpiceDouble       * clkout,
                                SpiceBoolean      * found      )
*/
void cspice_ckgpav(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_sclkdp;
   SpiceDouble        * vec_cmat;
   SpiceDouble        * vec_av;
   SpiceDouble        * vec_clkout;
   SpiceBoolean       * vec_found;
   SpiceInt             inst;
   SpiceDouble          sclkdp;
   SpiceDouble          tol;
   SpiceChar            ref[DEFAULT_STR_LENGTH+1];
   SpiceDouble        * cmat;
   SpiceDouble        * av;
   SpiceDouble        * clkout;
   SpiceBoolean       * found;
   SpiceDouble          xr[3][3];

   mwIndex              i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "inst",   MiceInt,     0, {0},    0},
      { "sclkdp", MiceDouble,  0, {0},    1},
      { "tol",    MiceDouble,  0, {0},    0},
      { "ref",    MiceChar,    0, {0},    0},
      { "cmat",   MiceDouble,  2, {3, 3}, 1},
      { "av",     MiceDouble,  1, {3},    1},
      { "clkout", MiceDouble,  0, {0},    1},
      { "found",  MiceBoolean, 0, {0},    1},
      };

   check_arg_num( nrhs, nlhs, 4, 4);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   inst       = S_INT_ARGV(1);
   vec_sclkdp = A_DBL_ARGV(2);
   tol        = S_DBL_ARGV(3);
   mxGetString(prhs[4], ref, DEFAULT_STR_LENGTH);

   vec_cmat   = A_DBL_RET_ARGV(0);
   vec_av     = A_DBL_RET_ARGV(1);
   vec_clkout = A_DBL_RET_ARGV(2);
   vec_found  = A_BOOL_RET_ARGV(3);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         sclkdp = *(vec_sclkdp + i*extra->offset[1]);
         cmat   =  (vec_cmat   + i*extra->offset[4]);
         av     =  (vec_av     + i*extra->offset[5]);
         clkout =  (vec_clkout + i*extra->offset[6]);
         found  =  (vec_found  + i*extra->offset[7]);

         ckgpav_c(inst, sclkdp, tol, ref,
                  (SpiceDouble(*)[3])xr, av, clkout, found);
         CHECK_CALL_FAILURE(i);

         xpose_c( xr, (SpiceDouble(*)[3])cmat);
         }

      }
   else
      {

      sclkdp = *(vec_sclkdp);

      cmat   = vec_cmat;
      av     = vec_av;
      clkout = vec_clkout;
      found  = vec_found;

      ckgpav_c(inst,
               sclkdp,
               tol,
               ref,
               (SpiceDouble(*)[3])xr,
               av,
               clkout,
               found);
      CHECK_CALL_FAILURE(SCALAR);

      xpose_c( xr, (SpiceDouble(*)[3])cmat);
      }

   }




/*
   void ckgr02_c ( SpiceInt            handle,
                   ConstSpiceDouble    descr  [],
                   SpiceInt            recno,
                   SpiceDouble         record [] )
*/
void cspice_ckgr02(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             handle;
   ConstSpiceDouble   * descr;
   SpiceInt             recno;
   SpiceDouble        * record;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle",  MiceInt,      0, {0},   0},
      { "descr",   MiceDouble,   1, {5},   0},
      { "recno",   MiceInt,      0, {0},   0},
      { "record",  MiceDouble,   1, {10},  0},
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle   = S_INT_ARGV(1);
   descr    = A_DBL_ARGV(2);
   recno    = S_INT_ARGV(3);

   record   = A_DBL_RET_ARGV(0);

   ckgr02_c ( handle, descr, recno, record );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void ckgr03_c ( SpiceInt            handle,
                   ConstSpiceDouble    descr  [],
                   SpiceInt            recno,
                   SpiceDouble         record [] )
*/
void cspice_ckgr03(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             handle;
   ConstSpiceDouble   * descr;
   SpiceInt             recno;
   SpiceDouble        * record;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle",  MiceInt,      0, {0},   0},
      { "descr",   MiceDouble,   1, {5},   0},
      { "recno",   MiceInt,      0, {0},   0},
      { "record",  MiceDouble,   1, {8},   0},
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle   = S_INT_ARGV(1);
   descr    = A_DBL_ARGV(2);
   recno    = S_INT_ARGV(3);

   record   = A_DBL_RET_ARGV(0);

   ckgr03_c ( handle, descr, recno, record );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void cklpf_c ( ConstSpiceChar * fname,
                  SpiceInt       * handle )
*/
void cspice_cklpf(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            fname  [DEFAULT_STR_LENGTH+1];
   SpiceInt           * handle;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "fname",   MiceChar,     0, {0},   0},
      { "handle",  MiceInt,      0, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 1, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], fname, DEFAULT_STR_LENGTH);

   handle   = A_INT_RET_ARGV(0);

   cklpf_c ( fname, handle );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void ckmeta_c ( SpiceInt            ckid,
                   ConstSpiceChar    * meta,
                   SpiceInt          * idcode )
*/
void cspice_ckmeta(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             ckid;
   SpiceChar            meta   [DEFAULT_STR_LENGTH+1];
   SpiceInt           * idcode;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "ckid",    MiceInt,      0, {0},   0},
      { "meta",    MiceChar,     0, {0},   0},
      { "idcode",  MiceInt,      0, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   ckid     = S_INT_ARGV(1);

   mxGetString(prhs[2], meta, DEFAULT_STR_LENGTH);

   idcode   = A_INT_RET_ARGV(0);

   ckmeta_c ( ckid, meta, idcode );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void cknr02_c ( SpiceInt            handle,
                   ConstSpiceDouble    descr  [],
                   SpiceInt          * nrec      )
*/
void cspice_cknr02(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             handle;
   ConstSpiceDouble   * descr;
   SpiceInt           * nrec;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle",  MiceInt,      0, {0},   0},
      { "descr",   MiceDouble,   1, {5},   0},
      { "nrec",    MiceInt,      0, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle   = S_INT_ARGV(1);
   descr    = A_DBL_ARGV(2);
   nrec     = A_INT_RET_ARGV(0);

   cknr02_c ( handle, descr, nrec );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void cknr03_c ( SpiceInt            handle,
                   ConstSpiceDouble    descr  [],
                   SpiceInt          * nrec      )
*/
void cspice_cknr03(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             handle;
   ConstSpiceDouble   * descr;
   SpiceInt           * nrec;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle",  MiceInt,      0, {0},   0},
      { "descr",   MiceDouble,   1, {5},   0},
      { "nrec",    MiceInt,      0, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle   = S_INT_ARGV(1);
   descr    = A_DBL_ARGV(2);
   nrec     = A_INT_RET_ARGV(0);

   cknr03_c ( handle, descr, nrec );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              ckobj_c ( ConstSpiceChar    * ck,
                               SpiceCell         * ids );

*/
void cspice_ckobj(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {
   SpiceChar           ck[DEFAULT_STR_LENGTH+1];
   mxChar            * mx_ck;

   mwIndex             i;
   SpiceInt            j;
   mwSize              sizearray[2];

   SpiceInt            card = 0;
   SpiceInt            size;
   SpiceInt          * ids_f;
   SpiceInt          * ids;

   struct extra_dims * extra;
   struct argcheck ArgCheck[] =
      {
      { "ckfnm", MiceChar,   0, {0}, 1},
      { "size",  MiceInt,    0, {0}, 0},
      { "ids",   MiceIgnore, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   size = S_INT_ARGV(2);
   ids  = (SpiceInt*)mxMalloc( (size + SPICE_CELL_CTRLSZ)*sizeof(SpiceInt)  );

   ssizei_( ( integer * ) &size, ( integer * ) ids   );
   scardi_( ( integer * ) &card, ( integer * ) ids   );

   if (extra->count>1)
      {

      mx_ck = (mxChar *)mxGetChars(prhs[1]);

      for ( i=0; i<extra->count; i++)
         {

         /*
         Extract the string data, character by character, into
         CSPICE strings. The mx_str array stores the data in a column
         major format, we need to extract the data by rows.
         */
         for ( j=0; j<extra->offset[0]; j++)
            {
            ck[j] = (char)mx_ck[i + (extra->count*j)];
            }

         ck[extra->offset[0]] = '\0';

         ckobj_(  ( char        * ) ck,
                   ( integer    * ) (ids),
                   ( ftnlen       ) strlen(ck)   );

         /*
         Check for a failure signal. Free the memory assigned to 'ids'
         before signaling a Matlab error.
         */
         if ( failed_c())
            {
            mxFree( ids );

            /*
            The mice_fail call creates the error string then returns control
            to the MATLAB interpreter.
            */
            mice_fail(i);
            }

         }

      }
   else
      {
      mxGetString(prhs[1], ck, DEFAULT_STR_LENGTH);

      ckobj_(  ( char        * ) ck,
                ( integer    * ) (ids),
                ( ftnlen       ) strlen(ck)   );

      /*
      Check for a failure signal. Free the memory assigned to 'ids'
      before signaling a Matlab error.
      */
      if ( failed_c())
         {
         mxFree( ids );

         /*
         The mice_fail call creates the error string then returns control
         to the MATLAB interpreter.
         */
         mice_fail(SCALAR);
         }

      }

   /*
   Array element 6, index 5, contains the cell cardinality. Create an output
   array CARDx1.
   */
   sizearray[0] = ids[5];
   sizearray[1] = 1;

   plhs[0] = mxCreateNumericArray( 2, sizearray, mxINT32_CLASS, mxREAL);
   ids_f   = A_INT_RET_ARGV(0);

   MOVEI( ids + SPICE_CELL_CTRLSZ, ids[5], ids_f );
   mxFree( ids );

   }




/*
   void              ckopn_c  ( ConstSpiceChar    * fname,
                                ConstSpiceChar    * ifname,
                                SpiceInt            ncomch,
                                SpiceInt          * handle  )
*/
void cspice_ckopn(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            fname [DEFAULT_STR_LENGTH+1];
   SpiceChar            ifname[DEFAULT_STR_LENGTH+1];
   SpiceInt             ncomch;
   SpiceInt           * handle;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "fname",  MiceChar, 0, {0}, 0},
      { "ifname", MiceChar, 0, {0}, 0},
      { "ncomch", MiceInt,  0, {0}, 0},
      { "handle", MiceInt,  0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 3, 1);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], fname,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], ifname, DEFAULT_STR_LENGTH);

   ncomch = S_INT_ARGV(3);
   handle = A_INT_RET_ARGV(0);

   ckopn_c( fname, ifname, ncomch, handle );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void ckupf_c ( SpiceInt handle )
*/
void cspice_ckupf(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             handle;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle",  MiceInt,      0, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 1, 0 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle   = S_INT_ARGV(1);


   ckupf_c ( handle );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              ckw01_c  ( SpiceInt            handle,
                                SpiceDouble         begtim,
                                SpiceDouble         endtim,
                                SpiceInt            inst,
                                ConstSpiceChar    * ref,
                                SpiceBoolean        avflag,
                                ConstSpiceChar    * segid,
                                SpiceInt            nrec,
                                ConstSpiceDouble    sclkdp [],
                                ConstSpiceDouble    quats  [][4],
                                ConstSpiceDouble    avvs   [][3]  );

*/
void cspice_ckw01(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             handle;
   SpiceDouble          begtim;
   SpiceDouble          endtim;
   SpiceInt             inst;
   SpiceChar            ref   [DEFAULT_STR_LENGTH+1];
   SpiceBoolean         avflag;
   SpiceChar            segid [DEFAULT_STR_LENGTH+1];
   SpiceInt             sclkdp_size;

   ConstSpiceDouble   * sclkdp;
   ConstSpiceDouble   * quats;
   ConstSpiceDouble   * avvs;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle",  MiceInt,     0, { 0 },    0},
      { "begtim",  MiceDouble,  0, { 0 },    0},
      { "endtim",  MiceDouble,  0, { 0 },    0},
      { "inst",    MiceInt,     0, { 0 },    0},
      { "ref",     MiceChar,    0, { 0 },    0},
      { "avflag",  MiceInt,     0, { 0 },    0},
      { "segid",   MiceChar,    0, { 0 },    0},
      { "sclkdp",  MiceDouble,  1, { 0 },    0},
      { "quats",   MiceDouble,  2, { 4, 0 }, 0},
      { "avvs",    MiceDouble,  2, { 3, 0 }, 0},
      };

   check_arg_num( nrhs, nlhs, 10, 0);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   sclkdp_size = mxGetNumberOfElements( prhs[8] );

   if( 4*sclkdp_size !=  (SpiceInt)mxGetNumberOfElements( prhs[9] ) )
      {
      mexErrMsgTxt( "MICE(INVALIDSIZE): Matrix `quats` must have the same "
                            "measure of vectorization as `sclkdp`" );
      }

   if( 3*sclkdp_size != (SpiceInt)mxGetNumberOfElements( prhs[10] ) )
      {
      mexErrMsgTxt( "MICE(INVALIDSIZE): Matrix `avvs` must have the same "
                            "measure of vectorization as `sclkdp`" );
      }

   handle  = S_INT_ARGV(1);
   begtim  = S_DBL_ARGV(2);
   endtim  = S_DBL_ARGV(3);
   inst    = S_INT_ARGV(4);

   mxGetString(prhs[5], ref, DEFAULT_STR_LENGTH);

   avflag  = *(SpiceBoolean*)mxGetData(prhs[6]);

   mxGetString(prhs[7], segid, DEFAULT_STR_LENGTH);

   sclkdp  = (ConstSpiceDouble*)mxGetData(prhs[8]);
   quats   = (ConstSpiceDouble*)mxGetData(prhs[9]);
   avvs    = (ConstSpiceDouble*)mxGetData(prhs[10]);

   ckw01_c( handle,
            begtim,
            endtim,
            inst,
            ref,
            avflag,
            segid,
            sclkdp_size,
            sclkdp,
            (Nx4d)quats,
            (Nx3d)avvs);

   CHECK_CALL_FAILURE( SCALAR );

   }




/*
   void              ckw02_c  ( SpiceInt            handle,
                                SpiceDouble         begtim,
                                SpiceDouble         endtim,
                                SpiceInt            inst,
                                ConstSpiceChar    * ref,
                                ConstSpiceChar    * segid,
                                SpiceInt            nrec,
                                ConstSpiceDouble    start  [],
                                ConstSpiceDouble    stop   [],
                                ConstSpiceDouble    quats  [][4],
                                ConstSpiceDouble    avvs   [][3],
                                ConstSpiceDouble    rates  []    )
*/
void cspice_ckw02(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             handle;
   SpiceDouble          begtim;
   SpiceDouble          endtim;
   SpiceInt             inst;
   SpiceChar            ref   [DEFAULT_STR_LENGTH+1];
   SpiceChar            segid [DEFAULT_STR_LENGTH+1];
   SpiceInt             start_size;

   ConstSpiceDouble   * start;
   ConstSpiceDouble   * stop;
   ConstSpiceDouble   * quats;
   ConstSpiceDouble   * avvs;
   ConstSpiceDouble   * rates;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle",  MiceInt,     0, { 0 },    0},
      { "begtim",  MiceDouble,  0, { 0 },    0},
      { "endtim",  MiceDouble,  0, { 0 },    0},
      { "inst",    MiceInt,     0, { 0 },    0},
      { "ref",     MiceChar,    0, { 0 },    0},
      { "segid",   MiceChar,    0, { 0 },    0},
      { "start",   MiceDouble,  1, { 0 },    0},
      { "stop",    MiceDouble,  1, { 0 },    0},
      { "quats",   MiceDouble,  2, { 4, 0 }, 0},
      { "avvs",    MiceDouble,  2, { 3, 0 }, 0},
      { "rates",   MiceDouble,  1, { 0 },    0},
      };

   check_arg_num( nrhs, nlhs, 11, 0);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   start_size = mxGetNumberOfElements( prhs[7] );

   if( start_size !=  (SpiceInt)mxGetNumberOfElements( prhs[8] ) )
      {
      mexErrMsgTxt( "MICE(INVALIDSIZE): Array `stop` must have the same "
                            "measure of vectorization as `start`" );
      }

   if( 4*start_size !=  (SpiceInt)mxGetNumberOfElements( prhs[9] ) )
      {
      mexErrMsgTxt( "MICE(INVALIDSIZE): Matrix `quats` must have the same "
                            "measure of vectorization as `start`" );
      }

   if( 3*start_size !=  (SpiceInt)mxGetNumberOfElements( prhs[10] ) )
      {
      mexErrMsgTxt( "MICE(INVALIDSIZE): Matrix `avvs` must have the same "
                            "measure of vectorization as `start`" );
      }

   if( start_size !=  (SpiceInt)mxGetNumberOfElements( prhs[11] ) )
      {
      mexErrMsgTxt( "MICE(INVALIDSIZE): Array `rates` must have the same "
                            "measure of vectorization as `start`" );
      }

   handle  = S_INT_ARGV(1);
   begtim  = S_DBL_ARGV(2);
   endtim  = S_DBL_ARGV(3);
   inst    = S_INT_ARGV(4);

   mxGetString(prhs[5], ref,   DEFAULT_STR_LENGTH);
   mxGetString(prhs[6], segid, DEFAULT_STR_LENGTH);

   start   = (ConstSpiceDouble*)mxGetData(prhs[7]);
   stop    = (ConstSpiceDouble*)mxGetData(prhs[8]);
   quats   = (ConstSpiceDouble*)mxGetData(prhs[9]);
   avvs    = (ConstSpiceDouble*)mxGetData(prhs[10]);
   rates   = (ConstSpiceDouble*)mxGetData(prhs[11]);

   ckw02_c( handle,
            begtim,
            endtim,
            inst,
            ref,
            segid,
            start_size,
            start,
            stop,
            (Nx4d)quats,
            (Nx3d)avvs,
            rates);

   CHECK_CALL_FAILURE( SCALAR );

   }




/*
   void              ckw03_c  ( SpiceInt            handle,
                                SpiceDouble         begtim,
                                SpiceDouble         endtim,
                                SpiceInt            inst,
                                ConstSpiceChar    * ref,
                                SpiceBoolean        avflag,
                                ConstSpiceChar    * segid,
                                SpiceInt            nrec,
                                ConstSpiceDouble    sclkdp [],
                                ConstSpiceDouble    quats  [][4],
                                ConstSpiceDouble    avvs   [][3],
                                SpiceInt            nints,
                                ConstSpiceDouble    starts []     );
*/
void cspice_ckw03(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             handle;
   SpiceDouble          begtim;
   SpiceDouble          endtim;
   SpiceInt             inst;
   SpiceChar            ref   [DEFAULT_STR_LENGTH+1];
   SpiceBoolean         avflag;
   SpiceChar            segid [DEFAULT_STR_LENGTH+1];
   SpiceInt             sclkdp_size;
   SpiceInt             nints;

   ConstSpiceDouble   * sclkdp;
   ConstSpiceDouble   * quats;
   ConstSpiceDouble   * avvs;
   ConstSpiceDouble   * starts;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle",  MiceInt,     0, { 0 },    0},
      { "begtim",  MiceDouble,  0, { 0 },    0},
      { "endtim",  MiceDouble,  0, { 0 },    0},
      { "inst",    MiceInt,     0, { 0 },    0},
      { "ref",     MiceChar,    0, { 0 },    0},
      { "avflag",  MiceInt,     0, { 0 },    0},
      { "segid",   MiceChar,    0, { 0 },    0},
      { "sclkdp",  MiceDouble,  1, { 0 },    0},
      { "quats",   MiceDouble,  2, { 4, 0 }, 0},
      { "avvs",    MiceDouble,  2, { 3, 0 }, 0},
      { "starts",  MiceDouble,  1, { 0 },    0},
      };

   check_arg_num( nrhs, nlhs, 11, 0);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   sclkdp_size = mxGetNumberOfElements( prhs[8] );
   nints       = mxGetNumberOfElements( prhs[11]);

   if( 4*sclkdp_size !=  (SpiceInt)mxGetNumberOfElements( prhs[9] ) )
      {
      mexErrMsgTxt( "MICE(INVALIDSIZE): Matrix `quats` must have the same "
                            "measure of vectorization as `sclkdp`" );
      }

   if( 3*sclkdp_size != (SpiceInt)mxGetNumberOfElements( prhs[10] ) )
      {
      mexErrMsgTxt( "MICE(INVALIDSIZE): Matrix `avvs` must have the same "
                            "measure of vectorization as `sclkdp`" );
      }


   handle  = S_INT_ARGV(1);
   begtim  = S_DBL_ARGV(2);
   endtim  = S_DBL_ARGV(3);
   inst    = S_INT_ARGV(4);

   mxGetString(prhs[5], ref, DEFAULT_STR_LENGTH);

   avflag  = *(SpiceBoolean*)mxGetData(prhs[6]);

   mxGetString(prhs[7], segid, DEFAULT_STR_LENGTH);

   sclkdp  = (ConstSpiceDouble*)mxGetData(prhs[8]);
   quats   = (ConstSpiceDouble*)mxGetData(prhs[9]);
   avvs    = (ConstSpiceDouble*)mxGetData(prhs[10]);
   starts  = (ConstSpiceDouble*)mxGetData(prhs[11]);

   ckw03_c( handle,
            begtim,
            endtim,
            inst,
            ref,
            avflag,
            segid,
            sclkdp_size,
            sclkdp,
            (Nx4d)quats,
            (Nx3d)avvs,
            nints,
            starts);

   CHECK_CALL_FAILURE( SCALAR );

   }




/*
   SpiceDouble              clight_c( void )
*/
void cspice_clight(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   check_arg_num( nrhs, nlhs, 0, 1 );

   /*
   Directly return the scalar value. This simple case needs no
   error checks.
   */
   plhs[0] = mxCreateDoubleScalar( clight_c() );

   }




/*
   void              clpool_c( void )
*/
void cspice_clpool(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   check_arg_num( nrhs, nlhs, 0, 0 );

   /*
   Not much to do, make the call.
   */
   clpool_c();

   }




/*
   void              cnmfrm_c ( ConstSpiceChar    * cname,
                                SpiceInt            lenout,
                                SpiceInt          * frcode,
                                SpiceChar         * frname,
                                SpiceBoolean      * found   );
*/
void mice_cnmfrm(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            cname[DEFAULT_STR_LENGTH+1];
   SpiceChar            frname[DEFAULT_STR_LENGTH+1];
   mxChar             * mx_cname;
   SpiceInt             frcode;
   SpiceBoolean         found;

   mwIndex              i;
   SpiceInt             j;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "cname",  MiceChar,   0, {0}, 1},
      { "cnmfrm", MiceNameID, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 1, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);


   if (extra->count>1)
      {
      mx_cname = (mxChar *)mxGetChars(prhs[1]);

      for (i=0;i<extra->count;i++)
         {

         /*
         Extract the string data, character by character, into
         CSPICE strings. The mx_str array stores the data in a column
         major format, we need to extract the data by rows.
         */
         for ( j=0; j<extra->offset[0]; j++)
            {
            cname[j] = (SpiceChar)mx_cname[i + (extra->count*j)];
            }

         cname[extra->offset[0]] = '\0';

         cnmfrm_c ( cname,
                    DEFAULT_STR_LENGTH,
                    &frcode,
                    frname,
                    &found   );
         CHECK_CALL_FAILURE(i);

          mxDestroyArray( mxGetField( plhs[0], i, "frname" ) );
          if ( found )
             {
             mxSetField( plhs[0], i, "name", mxCreateString(frname) );
             }
          else
             {
             mxSetField( plhs[0], i, "name", mxCreateString("\0") );
             frcode = 0;
             }

          mxDestroyArray( mxGetField( plhs[0], i,"code" ) );
          mxSetField( plhs[0], i,"code", zzmice_CreateIntScalar(frcode) );

          mxDestroyArray( mxGetField( plhs[0], i, "found" ) );
          mxSetField( plhs[0], i, "found",
                          mxCreateLogicalScalar(found ? true: false));
         }

      }
   else
      {
      mxGetString(prhs[1], cname, DEFAULT_STR_LENGTH);

      cnmfrm_c ( cname,
                 DEFAULT_STR_LENGTH,
                 &frcode,
                 frname,
                 &found   );
      CHECK_CALL_FAILURE(SCALAR);

      mxDestroyArray( mxGetField( plhs[0], 0, "name" ) );
      if ( found )
         {
         mxSetField(plhs[0], 0, "name", mxCreateString(frname)   );
         }
      else
         {
         mxSetField( plhs[0], 0, "name",  mxCreateString("\0") );
         frcode = 0;
         }

      mxDestroyArray( mxGetField( plhs[0], 0,"code" ) );
      mxSetField( plhs[0], 0,"code", zzmice_CreateIntScalar(frcode));

      mxDestroyArray( mxGetField( plhs[0], 0, "found" ) );
      mxSetField( plhs[0], 0, "found",
                  mxCreateLogicalScalar(found ? true: false));
      }

   }




/*
   void              conics_c( ConstSpiceDouble  elts[8],
                                SpiceDouble       et,
                                SpiceDouble       state[6] )
*/
void cspice_conics(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_elts;
   SpiceDouble        * vec_et;
   SpiceDouble        * vec_state;
   SpiceDouble        * elts;
   SpiceDouble          et;
   SpiceDouble        * state;

   mwIndex              i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "elts",  MiceDouble, 1, {8}, 1},
      { "et",    MiceDouble, 0, {0}, 1},
      { "state", MiceDouble, 1, {6}, 1},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_elts  = A_DBL_ARGV(1);
   vec_et    = A_DBL_ARGV(2);
   vec_state = A_DBL_RET_ARGV(0);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         elts  =  (vec_elts  + i*extra->offset[0]);
         et    = *(vec_et    + i*extra->offset[1]);
         state =  (vec_state + i*extra->offset[2]);

         conics_c(elts, et, state);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {

      elts  =  vec_elts;
      et    = *vec_et;
      state =  vec_state;

      conics_c(elts, et, state);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void              convrt_c ( SpiceDouble         x,
                                ConstSpiceChar    * in,
                                ConstSpiceChar    * out,
                                SpiceDouble       * y    );
*/
void cspice_convrt(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar           in[DEFAULT_STR_LENGTH+1];
   SpiceChar           out[DEFAULT_STR_LENGTH+1];
   SpiceDouble         x;
   SpiceDouble       * vec_x;
   SpiceDouble       * y;
   SpiceDouble       * vec_y;

   mwIndex             i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "x",   MiceDouble, 0, {0}, 1},
      { "in",  MiceChar,   0, {0}, 0},
      { "out", MiceChar,   0, {0}, 0},
      { "y",   MiceDouble, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra  = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_x = A_DBL_ARGV(1);

   mxGetString(prhs[2], in,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[3], out, DEFAULT_STR_LENGTH);

   vec_y = A_DBL_RET_ARGV(0);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         x = *(vec_x + i*extra->offset[0]);
         y =  (vec_y + i*extra->offset[3]);

         convrt_c( x, in, out, y);
         CHECK_CALL_FAILURE(i);
         }


      }
   else
      {
      x = *vec_x;
      y =  vec_y;

      convrt_c( x, in, out, y);
      CHECK_CALL_FAILURE(SCALAR);

      }

   }




/*
   void              cyllat_c(  SpiceDouble    r,
                                SpiceDouble    clon,
                                SpiceDouble    z,
                                SpiceDouble *  radius,
                                SpiceDouble *  lon,
                                SpiceDouble *  lat )
*/
void cspice_cyllat(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_r;
   SpiceDouble        * vec_clon;
   SpiceDouble        * vec_z;
   SpiceDouble        * vec_radius;
   SpiceDouble        * vec_lon;
   SpiceDouble        * vec_lat;
   SpiceDouble          r;
   SpiceDouble          clon;
   SpiceDouble          z;
   SpiceDouble        * radius;
   SpiceDouble        * lon;
   SpiceDouble        * lat;

   mwIndex              i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "r",      MiceDouble, 0, {0}, 1},
      { "clon",   MiceDouble, 0, {0}, 1},
      { "z",      MiceDouble, 0, {0}, 1},
      { "radius", MiceDouble, 0, {0}, 1},
      { "lon",    MiceDouble, 0, {0}, 1},
      { "lat",    MiceDouble, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 3, 3 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_r      = A_DBL_ARGV(1);
   vec_clon   = A_DBL_ARGV(2);
   vec_z      = A_DBL_ARGV(3);
   vec_radius = A_DBL_RET_ARGV(0);
   vec_lon    = A_DBL_RET_ARGV(1);
   vec_lat    = A_DBL_RET_ARGV(2);
   r          = *vec_r;
   clon       = *vec_clon;
   z          = *vec_z;
   radius     =  vec_radius;
   lon        =  vec_lon;
   lat        =  vec_lat;

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         r      = *(vec_r      + i*extra->offset[0]);
         clon   = *(vec_clon   + i*extra->offset[1]);
         z      = *(vec_z      + i*extra->offset[2]);
         radius =  (vec_radius + i*extra->offset[3]);
         lon    =  (vec_lon    + i*extra->offset[4]);
         lat    =  (vec_lat    + i*extra->offset[5]);

         cyllat_c(r, clon, z, radius, lon, lat);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {

      cyllat_c(r, clon, z, radius, lon, lat);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void              cylrec_c( SpiceDouble r,
                               SpiceDouble clon,
                               SpiceDouble z,
                               SpiceDouble rectan[3] )
*/
void cspice_cylrec(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_r;
   SpiceDouble        * vec_lon;
   SpiceDouble        * vec_z;
   SpiceDouble        * vec_rectan;
   SpiceDouble          r;
   SpiceDouble          clon;
   SpiceDouble          z;
   SpiceDouble        * rectan;

   mwIndex              i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "r",      MiceDouble, 0, {0}, 1},
      { "clon",   MiceDouble, 0, {0}, 1},
      { "z",      MiceDouble, 0, {0}, 1},
      { "rectan", MiceDouble, 1, {3}, 1},
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_r      = A_DBL_ARGV(1);
   vec_lon    = A_DBL_ARGV(2);
   vec_z      = A_DBL_ARGV(3);
   vec_rectan = A_DBL_RET_ARGV(0);

   r          = *(vec_r);
   clon       = *(vec_lon);
   z          = *(vec_z);
   rectan     =  (vec_rectan);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         r      = *(vec_r      + i*extra->offset[0]);
         clon   = *(vec_lon    + i*extra->offset[1]);
         z      = *(vec_z      + i*extra->offset[2]);
         rectan =  (vec_rectan + i*extra->offset[3]);

         cylrec_c(r, clon, z, rectan);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {

      cylrec_c(r, clon, z, rectan);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void              cylsph_c( SpiceDouble    r,
                               SpiceDouble    clon,
                               SpiceDouble    z,
                               SpiceDouble *  radius,
                               SpiceDouble *  colat,
                               SpiceDouble *  slon )
*/
void cspice_cylsph(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_r;
   SpiceDouble        * vec_clon;
   SpiceDouble        * vec_z;
   SpiceDouble        * vec_radius;
   SpiceDouble        * vec_colat;
   SpiceDouble        * vec_slon;
   SpiceDouble          r;
   SpiceDouble          clon;
   SpiceDouble          z;
   SpiceDouble        * radius;
   SpiceDouble        * colat;
   SpiceDouble        * slon;

   mwIndex              i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "r",      MiceDouble, 0, {0}, 1},
      { "clon",   MiceDouble, 0, {0}, 1},
      { "z",      MiceDouble, 0, {0}, 1},
      { "radius", MiceDouble, 0, {0}, 1},
      { "colat",  MiceDouble, 0, {0}, 1},
      { "slon",   MiceDouble, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 3, 3 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_r      = A_DBL_ARGV(1);
   vec_clon   = A_DBL_ARGV(2);
   vec_z      = A_DBL_ARGV(3);
   vec_radius = A_DBL_RET_ARGV(0);
   vec_colat  = A_DBL_RET_ARGV(1);
   vec_slon   = A_DBL_RET_ARGV(2);
   r          = *vec_r;
   clon       = *vec_clon;
   z          = *vec_z;
   radius     = vec_radius;
   colat      = vec_colat;
   slon       = vec_slon;

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         r      = *(vec_r      + i*extra->offset[0]);
         clon   = *(vec_clon   + i*extra->offset[1]);
         z      = *(vec_z      + i*extra->offset[2]);
         radius =  (vec_radius + i*extra->offset[3]);
         colat  =  (vec_colat  + i*extra->offset[4]);
         slon   =  (vec_slon   + i*extra->offset[5]);

         cylsph_c(r, clon, z, radius, colat, slon);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {

      cylsph_c(r, clon, z, radius, colat, slon);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void              dafac_c  ( SpiceInt            handle,
                                SpiceInt            n,
                                SpiceInt            lenvals,
                                const void        * buffer  );
*/
void cspice_dafac(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             handle;
   SpiceChar          * str;
   SpiceChar         ** cvals = NULL;
   SpiceInt             cvals_len;
   SpiceInt             cvals_size;

   mxChar             * mx_str;

   mwIndex              i;
   SpiceInt             j;
   mwSize               count;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle", MiceInt,  0, {0}, 0},
      { "buffer", MiceChar, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 2, 0);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle = S_INT_ARGV(1);
   mx_str = (mxChar *)mxGetChars(prhs[2]);

   /*
   The following logic differs slightly from other string input arguments.
   A dafac_c input may consist of an array of strings, where the array
   defines either a single string or an array or strings.

   Recall, extra->count == 0 for scalar inputs. A scalar string requires
   count as 1 (Is this a bug or design failure? EDW)

   Equivalent to mxGetM(prhs[2]).
   */
   if (extra->count>1)
      {
      count = extra->count;
      }
   else
      {
      count = 1;
      }

   cvals_len  = extra->offset[1] + 1;
   cvals_size = count;
   cvals      = alloc_SpiceString_C_array( cvals_len, cvals_size );
   CHECK_CALL_FAILURE( SCALAR );

   str = mxCalloc(cvals_len, sizeof(char));

   for ( i=0; i<count; i++)
      {

      /*
      Extract the string data, character by character, into
      CSPICE strings. The mx_str array stores the data in a column
      major format, we need to extract the data by rows.
      */
      for ( j=0; j<cvals_len - 1; j++)
         {
         str[j] = (char)mx_str[i + (count*j)];
         }

      str[cvals_len - 1] = '\0';

      strncpy( *cvals + i*cvals_len,
               str,
               cvals_len);
      }

   dafac_c ( handle, cvals_size, cvals_len, * cvals );
   CHECK_CALL_FAILURE_MEM( 1, cvals );

   /* Clean up temporary variables */
   free_SpiceString_C_array ( 1, cvals );

   /*
   Confirm the code released all allocated memory.
   */
   MICE_ALLOC_CHECK;

   }





/*
   void              dafbbs_c ( SpiceInt            handle )
*/
void cspice_dafbbs(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             handle;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle", MiceInt, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 1, 0);

   extra  = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle = S_INT_ARGV(1);

   dafbbs_c( handle );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              dafbfs_c ( SpiceInt            handle )
*/
void cspice_dafbfs(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             handle;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle", MiceInt, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 1, 0);

   extra  = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle = S_INT_ARGV(1);

   dafbfs_c( handle );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              dafcls_c ( SpiceInt            handle )
*/
void cspice_dafcls(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             handle;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle", MiceInt, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 1, 0);

   extra  = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle = S_INT_ARGV(1);

   dafcls_c( handle );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              dafcs_c  ( SpiceInt            handle )
*/
void cspice_dafcs(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             handle;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle", MiceInt, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 1, 0);

   extra  = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle = S_INT_ARGV(1);

   dafcs_c( handle );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              dafdc_c  ( SpiceInt            handle )
*/
void cspice_dafdc(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             handle;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle", MiceInt, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 1, 0);

   extra  = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle = S_INT_ARGV(1);

   dafdc_c( handle );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              dafec_c  ( SpiceInt            handle,
                                SpiceInt            bufsiz,
                                SpiceInt            buflen,
                                SpiceInt          * n,
                                void              * buffer,
                                SpiceBoolean      * done    );
*/
void cspice_dafec(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             handle;
   SpiceInt             bufsiz;
   SpiceInt             buflen;
   SpiceInt             n = 0;
   SpiceChar         ** cvals;
   SpiceChar         ** array;
   SpiceBoolean         done = SPICETRUE;

   SpiceInt             i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle", MiceInt,    0, {0}, 0},
      { "bufsiz", MiceInt,    0, {0}, 0},
      { "buffln", MiceInt,    0, {0}, 0},
      { "buffer", MiceIgnore, 0, {0}, 0},
      { "done",   MiceIgnore, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 3, 2 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle = S_INT_ARGV(1);
   bufsiz = S_INT_ARGV(2);
   buflen = S_INT_ARGV(3);

   cvals  = (SpiceChar**)alloc_SpiceString_C_array( buflen, bufsiz );
   array  = (SpiceChar**)alloc_SpiceString_Pointer_array(bufsiz);

   CHECK_CALL_FAILURE_MEM1(SCALAR, 1, cvals, array);

   dafec_c ( handle, bufsiz, buflen, &n, * cvals, &done );
   CHECK_CALL_FAILURE_MEM1(SCALAR, 1, cvals, array);

   if ( n > 0 )
      {
      for (i=0;i<n;i++)
         {

         /*
         Copy the ith string pointer to the array of pointers for input
         to the mx call.
         */
         array[i] = *cvals + i*buflen;
         }

      /*
      I think this functions as a copy, creating needed memory to 'plhs'.
      */
      plhs[0] = mxCreateCharMatrixFromStrings( n, (const char **)array);
      }
   else
      {
      plhs[0] = mxCreateString( "\0" );
      }

   plhs[1] = zzmice_CreateIntScalar(done);

   free_SpiceString_C_array( 1, cvals );
   free_SpiceMemory( array );

   /*
   Confirm the code released all allocated memory.
   */
   MICE_ALLOC_CHECK;

   }




/*
   void              daffna_c ( SpiceBoolean      * found )
*/
void cspice_daffna(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceBoolean       found;

   check_arg_num( nrhs, nlhs, 0, 1 );

   /*
   Directly return the scalar value.
   */
   daffna_c ( &found );
   CHECK_CALL_FAILURE(SCALAR);

   plhs[0] = zzmice_CreateIntScalar( found );

   }




/*
   void              daffpa_c ( SpiceBoolean      * found )
*/
void cspice_daffpa(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceBoolean       found;

   check_arg_num( nrhs, nlhs, 0, 1 );

   /*
   Directly return the scalar value.
   */
   daffpa_c ( &found );
   CHECK_CALL_FAILURE(SCALAR);

   plhs[0] = zzmice_CreateIntScalar( found );

   }




/*
   void              dafgda_c ( SpiceInt            handle,
                                SpiceInt            begin,
                                SpiceInt            end,
                                SpiceDouble       * data );
*/
void cspice_dafgda(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             handle;
   SpiceInt             begin;
   SpiceInt             end;
   SpiceDouble        * data;

   SpiceInt             size;
   SpiceDouble        * dvals_ret;
   mwSize               sizearray[2];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle", MiceInt,     0, {0}, 0},
      { "begin",  MiceInt,     0, {0}, 0},
      { "end",    MiceInt,     0, {0}, 0},
      { "data",   MiceIgnore,  0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 3, 1);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle = S_INT_ARGV(1);
   begin  = S_INT_ARGV(2);
   end    = S_INT_ARGV(3);
   size   = end - begin + 1;

   data = (SpiceDouble*)mxMalloc(size * sizeof(SpiceDouble) );
   memset( data, 0, size * sizeof(SpiceDouble) );

   dafgda_c( handle, begin, end, data);

   /*
   Check for a failure signal. Free the memory assigned to 'data'
   before signaling a Matlab error.
   */
   if ( failed_c())
      {
      mxFree( data );

      /*
      The mice_fail call creates the error string then returns control
      to the MATLAB interpreter.
      */
      mice_fail(SCALAR);
      }

   /*
   Define the size and shape of the Matlab return argument.
   */
   sizearray[0] = 1;
   sizearray[1] = size;

   plhs[0]   = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
   dvals_ret = A_DBL_RET_ARGV(0);

   MOVED( data, size, dvals_ret );
   mxFree( data );

   }




/*
   void              dafgn_c  ( SpiceInt            lenout,
                                SpiceChar         * name   )
*/
void cspice_dafgn(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            name [DEFAULT_STR_LENGTH+1];

   /*
   Very simple interface. No need to allocate memory. Use
   the default string length as 'lenout'.
   */
   check_arg_num( nrhs, nlhs, 0, 1 );

   dafgn_c ( DEFAULT_STR_LENGTH, name);

   plhs[0] = mxCreateString( name );
   if ( plhs[0] == NULL )
      {
      mexErrMsgTxt( "MICE(BUG): mxCreateString failed in cspice_dafgn" );
      }

   }




/*
   void              dafgs_c  ( SpiceDouble         sum[] )

   void              dafus_c  ( ConstSpiceDouble    sum [],
                                SpiceInt            nd,
                                SpiceInt            ni,
                                SpiceDouble         dc  [],
                                SpiceInt            ic  []  )
*/
void cspice_dafgs(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble          sum [MAXSUM];
   SpiceInt             nd;
   SpiceInt             ni;
   SpiceDouble          dc  [MAXNDC];
   SpiceInt             ic  [MAXNIC];

   SpiceDouble        * dvals_ret;
   SpiceInt           * ivals_ret;
   mwSize               sizearray[2];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "nd", MiceInt,     0, {0}, 0},
      { "ni", MiceInt,     0, {0}, 0},
      { "dc", MiceIgnore,  0, {0}, 0},
      { "ic", MiceIgnore,  0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 2, 2);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   nd   = S_INT_ARGV(1);
   ni   = S_INT_ARGV(2);

   /*
   Let's not do anything fancy. Make the calls using explicitly
   sized args.
   */
   dafgs_c( sum );
   dafus_c( sum, nd, ni, dc, ic );

   CHECK_CALL_FAILURE(SCALAR);

   /*
   Define the size and shape of the Matlab return argument. The
   number of elements should not exceed MAXNDC. Enforce with the
   conditional operator.
   */
   sizearray[0] = 1;
   sizearray[1] = ( nd < MAXNDC ? nd: MAXNDC);

   plhs[0]   = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
   dvals_ret = A_DBL_RET_ARGV(0);

   MOVED( dc, nd, dvals_ret );

   /*
   Define the size and shape of the Matlab return argument. The
   number of elements should not exceed MAXNIC. Enforce with the
   conditional operator.
   */
   sizearray[0] = 1;
   sizearray[1] = ( ni < MAXNIC ? ni: MAXNIC);

   plhs[1]   = mxCreateNumericArray( 2, sizearray, mxINT32_CLASS, mxREAL);
   ivals_ret = A_INT_RET_ARGV(1);

   MOVEI( ic, ni, ivals_ret );

   }




/*
   void dafhsf_c ( SpiceInt            handle,
                   SpiceInt          * nd,
                   SpiceInt          * ni      )
*/
void cspice_dafhsf(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             handle;
   SpiceInt           * nd;
   SpiceInt           * ni;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle",  MiceInt,   0, {0},   0},
      { "nd",      MiceInt,   0, {0},   0},
      { "ni",      MiceInt,   0, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 1, 2 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle   = S_INT_ARGV(1);

   nd       = A_INT_RET_ARGV(0);
   ni       = A_INT_RET_ARGV(1);

   dafhsf_c ( handle, nd, ni );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              dafopr_c ( ConstSpiceChar    * fname,
                                SpiceInt          * handle  )
*/
void cspice_dafopr(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            fname [DEFAULT_STR_LENGTH+1];
   SpiceInt           * handle;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "fname",  MiceChar, 0, {0}, 0},
      { "handle", MiceInt,  0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 1, 1);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], fname,  DEFAULT_STR_LENGTH);

   handle = A_INT_RET_ARGV(0);

   dafopr_c( fname, handle );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              dafopw_c ( ConstSpiceChar    * fname,
                                SpiceInt          * handle  )
*/
void cspice_dafopw(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            fname [DEFAULT_STR_LENGTH+1];
   SpiceInt           * handle;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "fname",  MiceChar, 0, {0}, 0},
      { "handle", MiceInt,  0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 1, 1);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], fname,  DEFAULT_STR_LENGTH);

   handle = A_INT_RET_ARGV(0);

   dafopw_c( fname, handle );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void dafps_c ( SpiceInt             nd,
                  SpiceInt             ni,
                  ConstSpiceDouble   * dc,
                  ConstSpiceInt      * ic,
                  SpiceDouble        * sum )
*/
void cspice_dafps(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             nd;
   SpiceInt             ni;
   ConstSpiceDouble   * dc;
   ConstSpiceInt      * ic;
   SpiceInt             nsum;
   SpiceDouble        * sum;
   SpiceDouble        * ret_sum;

   /*
   Input arguments `dc' and `ic' must be 1xN arrays (row vectors)
   */
   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "dc",      MiceDouble,   2, {1,0},   0},
      { "ic",      MiceInt,      2, {1,0},   0},
      { "sum",     MiceIgnore,   0, {0},     0},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   nd       = mxGetNumberOfElements(prhs[1]);
   dc       = (ConstSpiceDouble*)mxGetData(prhs[1]);
   ni       = mxGetNumberOfElements(prhs[2]);
   ic       = (ConstSpiceInt*)mxGetData(prhs[2]);

   nsum = nd + (ni - 1)/2 + 1;

   ret_sum = (SpiceDouble*) mxMalloc( nsum * sizeof(SpiceDouble) );

   dafps_c ( nd, ni, dc, ic, ret_sum );

   /*
   Check for a failure signal. Free the memory assigned to `ret_sum'
   before signaling a Matlab error.
   */
   if ( failed_c())
      {
      mxFree( ret_sum );

      /*
      The mice_fail call creates the error string then returns control
      to the MATLAB interpreter.
      */
      mice_fail(SCALAR);
      }

   /*
   Allocate the needed memory to return a vector of size `nsum'
   to MATLAB.
   */
   plhs[0]  = mxCreateDoubleMatrix( nsum, 1, mxREAL );
   sum      = A_DBL_RET_ARGV(0);
   MOVED( ret_sum, nsum, sum );
   mxFree( ret_sum );

   }




/*
   void dafrs_c ( ConstSpiceDouble  * sum )
*/
void cspice_dafrs(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             nd;
   SpiceInt             ni;
   ConstSpiceDouble   * dc;
   ConstSpiceInt      * ic;
   SpiceInt             nsum;
   SpiceDouble        * sum;

   /*
   Input arguments `dc' and `ic' must be 1xN arrays (row vectors)
   */
   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "dc",      MiceDouble,   2, {1,0},   0},
      { "ic",      MiceInt,      2, {1,0},   0},
      };

   check_arg_num( nrhs, nlhs, 2, 0 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   nd       = mxGetNumberOfElements(prhs[1]);
   dc       = (ConstSpiceDouble*)mxGetData(prhs[1]);
   ni       = mxGetNumberOfElements(prhs[2]);
   ic       = (ConstSpiceInt*)mxGetData(prhs[2]);

   nsum = nd + (ni - 1)/2 + 1;

   sum = (SpiceDouble*) mxMalloc( nsum * sizeof(SpiceDouble) );

   dafps_c ( nd, ni, dc, ic, sum );

   /*
   Check for a failure signal. Free the memory assigned to `sum'
   before signaling a Matlab error.
   */
   if ( failed_c())
      {
      mxFree( sum );

      /*
      The mice_fail call creates the error string then returns control
      to the MATLAB interpreter.
      */
      mice_fail(SCALAR);
      }

   dafrs_c ( sum );
   CHECK_CALL_FAILURE(SCALAR);
   mxFree( sum );

   }




/*
   void              dafus_c  ( ConstSpiceDouble    sum [],
                                SpiceInt            nd,
                                SpiceInt            ni,
                                SpiceDouble         dc  [],
                                SpiceInt            ic  []  )
*/
void cspice_dafus(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * sum;
   SpiceInt             nd;
   SpiceInt             ni;
   SpiceDouble          dc  [MAXNDC];
   SpiceInt             ic  [MAXNIC];

   SpiceDouble        * dvals_ret;
   SpiceInt           * ivals_ret;
   SpiceInt             sum_size;
   mwSize               sizearray[2];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "sum", MiceDouble, 1, {0}, 0},
      { "nd",  MiceInt,    0, {0}, 0},
      { "ni",  MiceInt,    0, {0}, 0},
      { "dc",  MiceIgnore, 0, {0}, 0},
      { "ic",  MiceIgnore, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 3, 2);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   sum      = (SpiceDouble*)mxGetData(prhs[1]);
   sum_size = mxGetNumberOfElements( prhs[1] );

   /* Check dimensions of input arrays */
   if ( sum_size > MAXSUM )
      {
      mexErrMsgTxt( "MICE(INVALIDSIZE): Size of summary array "
                    "`sum` exceeds MAXSUM.");
      }

   nd   = S_INT_ARGV(2);
   ni   = S_INT_ARGV(3);

   /*
   Let's not do anything fancy. Make the calls using explicitly
   sized args.
   */
   dafus_c( sum, nd, ni, dc, ic );

   CHECK_CALL_FAILURE(SCALAR);

   /*
   Define the size and shape of the Matlab return argument. The
   number of elements should not exceed MAXNDC. Enforce with the
   conditional operator.
   */
   sizearray[0] = 1;
   sizearray[1] = ( nd < MAXNDC ? nd: MAXNDC);

   plhs[0]   = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
   dvals_ret = A_DBL_RET_ARGV(0);

   MOVED( dc, nd, dvals_ret );

   /*
   Define the size and shape of the Matlab return argument. The
   number of elements should not exceed MAXNIC. Enforce with the
   conditional operator.
   */
   sizearray[0] = 1;
   sizearray[1] = ( ni < MAXNIC ? ni: MAXNIC);

   plhs[1]   = mxCreateNumericArray( 2, sizearray, mxINT32_CLASS, mxREAL);
   ivals_ret = A_INT_RET_ARGV(1);

   MOVEI( ic, ni, ivals_ret );

   }



/*
   void dasadc_c ( SpiceInt            handle,
                   SpiceInt            n,
                   SpiceInt            bpos,
                   SpiceInt            epos,
                   SpiceInt            datlen,
                   const void        * data   )
*/
void cspice_dasadc(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             handle;
   SpiceInt             n;
   SpiceInt             bpos;
   SpiceInt             epos;
   SpiceChar          * data;
   SpiceInt             datLen;
   SpiceInt             irows;
   SpiceInt             xrows;

   /* The message buffer to write an error message */
   char                 msg[1024];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle",  MiceInt,      0, {0},   0},
      { "n",       MiceInt,      0, {0},   0},
      { "bpos",    MiceInt,      0, {0},   0},
      { "epos",    MiceInt,      0, {0},   0},
      { "data",    MiceByte,     2, {0,0}, 0},
      };

   check_arg_num( nrhs, nlhs, 5, 0 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle   = S_INT_ARGV(1);
   n        = S_INT_ARGV(2);
   bpos     = S_INT_ARGV(3) - 1;
   epos     = S_INT_ARGV(4) - 1;

   /*
   Note that the data has been transposed before passing it to the
   gateway in order to have each row in a contiguous block of memory as
   expected by CSPICE. MATLAB stores data in a column-major order: the
   length of each "line" is the number rows of the Matlab object, while
   the number of lines is the number of columns of the Matlab object.
   */
   datLen  = (SpiceInt)mxGetM(prhs[5]);
   irows = (SpiceInt)mxGetN(prhs[5]);

   /*
   Verify that `data' contains enough characters to add `n' to the DAS
   file. Make sure we can compute `xrows'. If not, the error will be
   detected and signaled by a routine in the call tree.
   */
   if ( epos - bpos + 1 )
   {
      xrows = (long)( ( n + epos - bpos) / ( epos - bpos + 1 ) );
      if ( irows < xrows )
      {
         sprintf( msg,"MICE(INSUFFICIENTDATA): `data` "
                  "does not contain enough data to add %ld characters to the "
                  "DAS file. It has %ld rows of %ld uint8, when it "
                  "requires %ld rows of at least %ld uint8.",
                  (long)n, (long)irows, (long)datLen, (long)xrows,
                  (long)epos+1 );
         mexErrMsgTxt( msg );
      }
   }

   data = A_CHAR_ARGV(5);

   dasadc_c ( handle, n, bpos, epos, datLen, data );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void dasadd_c ( SpiceInt            handle,
                   SpiceInt            n,
                   ConstSpiceDouble    data   [] )
*/
void cspice_dasadd(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             handle;
   SpiceInt             n;
   ConstSpiceDouble   * data;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle",  MiceInt,      0, {0},   0},
      { "data",    MiceDouble,   1, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 2, 0 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle   = S_INT_ARGV(1);
   n        = A_LEN_ARGV(2);
   data     = A_DBL_ARGV(2);

   dasadd_c ( handle, n, data );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void dasadi_c ( SpiceInt            handle,
                   SpiceInt            n,
                   ConstSpiceInt       data   [] )
*/
void cspice_dasadi(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             handle;
   SpiceInt             n;
   ConstSpiceInt      * data;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle",  MiceInt,      0, {0},   0},
      { "data",    MiceInt,      1, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 2, 0 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle   = S_INT_ARGV(1);
   n        = A_LEN_ARGV(2);
   data     = A_INT_ARGV(2);

   dasadi_c ( handle, n, data );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              dascls_c ( SpiceInt            handle )
*/
void cspice_dascls(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             handle;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle", MiceInt, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 1, 0);

   extra  = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle = S_INT_ARGV(1);

   dascls_c( handle );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              dasec_c  ( SpiceInt            handle,
                                SpiceInt            bufsiz,
                                SpiceInt            buflen,
                                SpiceInt          * n,
                                void              * buffer,
                                SpiceBoolean      * done    );
*/
void cspice_dasec(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             handle;
   SpiceInt             bufsiz;
   SpiceInt             buflen;
   SpiceInt             n = 0;
   SpiceChar         ** cvals;
   SpiceChar         ** array;
   SpiceBoolean         done = SPICETRUE;

   SpiceInt             i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle", MiceInt,    0, {0}, 0},
      { "bufsiz", MiceInt,    0, {0}, 0},
      { "buffln", MiceInt,    0, {0}, 0},
      { "buffer", MiceIgnore, 0, {0}, 0},
      { "done",   MiceIgnore, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 3, 2 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle = S_INT_ARGV(1);
   bufsiz = S_INT_ARGV(2);
   buflen = S_INT_ARGV(3);

   cvals  = (SpiceChar**)alloc_SpiceString_C_array( buflen, bufsiz );
   array  = (SpiceChar**)alloc_SpiceString_Pointer_array(bufsiz);

   CHECK_CALL_FAILURE_MEM1(SCALAR, 1, cvals, array);

   dasec_c ( handle, bufsiz, buflen, &n, * cvals, &done );
   CHECK_CALL_FAILURE_MEM1(SCALAR, 1, cvals, array);

   if ( n > 0 )
      {
      for (i=0;i<n;i++)
         {

         /*
         Copy the ith string pointer to the array of pointers for input
         to the mx call.
         */
         array[i] = *cvals + i*buflen;
         }

      /*
      I think this functions as a copy, creating needed memory to 'plhs'.
      */
      plhs[0] = mxCreateCharMatrixFromStrings( n, (const char **)array);
      }
   else
      {
      plhs[0] = mxCreateString( "\0" );
      }

   plhs[1] = zzmice_CreateIntScalar(done);

   free_SpiceString_C_array( 1, cvals );
   free_SpiceMemory( array );

   /*
   Confirm the code released all allocated memory.
   */
   MICE_ALLOC_CHECK;

   }




/*
   void dashfs_c ( SpiceInt            handle,
                   SpiceInt          * nresvr,
                   SpiceInt          * nresvc,
                   SpiceInt          * ncomr,
                   SpiceInt          * ncomc,
                   SpiceInt          * free,
                   SpiceInt            lastla [3],
                   SpiceInt            lastrc [3],
                   SpiceInt            lastwd [3] )
*/
void cspice_dashfs(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             handle;
   SpiceInt           * nresvr;
   SpiceInt           * nresvc;
   SpiceInt           * ncomr;
   SpiceInt           * ncomc;
   SpiceInt           * free;
   SpiceInt           * lastla;
   SpiceInt           * lastrc;
   SpiceInt           * lastwd;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle",  MiceInt,      0, {0},   0},
      { "nresvr",  MiceInt,      0, {0},   0},
      { "nresvc",  MiceInt,      0, {0},   0},
      { "ncomr",   MiceInt,      0, {0},   0},
      { "ncomc",   MiceInt,      0, {0},   0},
      { "free",    MiceInt,      0, {0},   0},
      { "lastla",  MiceInt,      1, {3},   0},
      { "lastrc",  MiceInt,      1, {3},   0},
      { "lastwd",  MiceInt,      1, {3},   0},
      };

   check_arg_num( nrhs, nlhs, 1, 8 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle   = S_INT_ARGV(1);

   nresvr   = A_INT_RET_ARGV(0);
   nresvc   = A_INT_RET_ARGV(1);
   ncomr    = A_INT_RET_ARGV(2);
   ncomc    = A_INT_RET_ARGV(3);
   free     = A_INT_RET_ARGV(4);
   lastla   = A_INT_RET_ARGV(5);
   lastrc   = A_INT_RET_ARGV(6);
   lastwd   = A_INT_RET_ARGV(7);

   dashfs_c ( handle, nresvr, nresvc, ncomr, ncomc,
              free,   lastla, lastrc, lastwd        );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void daslla_c ( SpiceInt            handle,
                   SpiceInt          * lastc,
                   SpiceInt          * lastd,
                   SpiceInt          * lasti  )
*/
void cspice_daslla(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             handle;
   SpiceInt           * lastc;
   SpiceInt           * lastd;
   SpiceInt           * lasti;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle",  MiceInt,      0, {0},   0},
      { "lastc",   MiceInt,      0, {0},   0},
      { "lastd",   MiceInt,      0, {0},   0},
      { "lasti",   MiceInt,      0, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 1, 3 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle   = S_INT_ARGV(1);

   lastc    = A_INT_RET_ARGV(0);
   lastd    = A_INT_RET_ARGV(1);
   lasti    = A_INT_RET_ARGV(2);

   daslla_c ( handle, lastc, lastd, lasti );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void dasllc_c ( SpiceInt            handle )
*/
void cspice_dasllc(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             handle;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle",  MiceInt,      0, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 1, 0 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle   = S_INT_ARGV(1);


   dasllc_c ( handle );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void dasonw_c ( ConstSpiceChar    * fname,
                   ConstSpiceChar    * ftype,
                   ConstSpiceChar    * ifname,
                   SpiceInt            ncomr,
                   SpiceInt          * handle )
*/
void cspice_dasonw(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            fname  [DEFAULT_STR_LENGTH+1];
   SpiceChar            ftype  [DEFAULT_STR_LENGTH+1];
   SpiceChar            ifname [DEFAULT_STR_LENGTH+1];
   SpiceInt             ncomr;
   SpiceInt           * handle;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "fname",   MiceChar,     0, {0},   0},
      { "ftype",   MiceChar,     0, {0},   0},
      { "ifname",  MiceChar,     0, {0},   0},
      { "ncomr",   MiceInt,      0, {0},   0},
      { "handle",  MiceInt,      0, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 4, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], fname, DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], ftype, DEFAULT_STR_LENGTH);
   mxGetString(prhs[3], ifname, DEFAULT_STR_LENGTH);

   ncomr    = S_INT_ARGV(4);

   handle   = A_INT_RET_ARGV(0);

   dasonw_c ( fname, ftype, ifname, ncomr, handle );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              dasopr_c ( ConstSpiceChar    * fname,
                                SpiceInt          * handle  )
*/
void cspice_dasopr(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            fname [DEFAULT_STR_LENGTH+1];
   SpiceInt           * handle;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "fname",  MiceChar, 0, {0}, 0},
      { "handle", MiceInt,  0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 1, 1);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], fname,  DEFAULT_STR_LENGTH);

   handle = A_INT_RET_ARGV(0);

   dasopr_c( fname, handle );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void dasops_c ( SpiceInt          * handle )
*/
void cspice_dasops(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt           * handle;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle",  MiceInt,      0, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 0, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle   = A_INT_RET_ARGV(0);

   dasops_c ( handle );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void dasopw_c ( ConstSpiceChar    * fname,
                   SpiceInt          * handle )
*/
void cspice_dasopw(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            fname  [DEFAULT_STR_LENGTH+1];
   SpiceInt           * handle;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "fname",   MiceChar,     0, {0},   0},
      { "handle",  MiceInt,      0, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 1, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], fname, DEFAULT_STR_LENGTH);

   handle   = A_INT_RET_ARGV(0);

   dasopw_c ( fname, handle );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void dasrdc_c ( SpiceInt            handle,
                   SpiceInt            first,
                   SpiceInt            last,
                   SpiceInt            bpos,
                   SpiceInt            epos,
                   SpiceInt            datlen,
                   void              * data   )
*/
void cspice_dasrdc(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             handle;
   SpiceInt             first;
   SpiceInt             last;
   SpiceInt             bpos;
   SpiceInt             epos;
   SpiceChar          * retData;
   SpiceChar          * data;
   SpiceInt             datLen;
   SpiceInt             irows;
   SpiceInt             xrows;

   /* The message buffer to write an error message */
   char                 msg[1024];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle",  MiceInt,      0, {0},   0},
      { "first",   MiceInt,      0, {0},   0},
      { "last",    MiceInt,      0, {0},   0},
      { "bpos",    MiceInt,      0, {0},   0},
      { "epos",    MiceInt,      0, {0},   0},
      { "data_i",  MiceByte,     2, {0,0}, 0},
      { "data",    MiceIgnore,   2, {0,0}, 0},
      };

   check_arg_num( nrhs, nlhs, 6, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle   = S_INT_ARGV(1);
   first    = S_INT_ARGV(2);
   last     = S_INT_ARGV(3);
   bpos     = S_INT_ARGV(4) - 1;
   epos     = S_INT_ARGV(5) - 1;

   /*
   Note that the data has been transposed before passing it to the
   gateway in order to have each row in a contiguous block of memory as
   expected by CSPICE. MATLAB stores data in a column-major order: the
   length of each "line" is the number rows of the Matlab object, while
   the number of lines is the number of columns of the Matlab object.
   */
   datLen   = (SpiceInt)mxGetM(prhs[6]);
   irows = (SpiceInt)mxGetN(prhs[6]);

   /*
   Verify that `data' contains enough space to hold

      last-first+1

   characters from the DAS file. Make sure we can compute `xrows'.
   If not, the error will be detected and signaled by a routine
   in the call tree.
   */
   if ( epos - bpos + 1 )
   {
      xrows = (long)(( last - first + epos - bpos + 1) / ( epos - bpos + 1 ));
      if ( irows < xrows )
      {
         sprintf( msg,"MICE(INSUFFICIENTDATA): `data` "
                  "does not have enough space to hold %ld characters from "
                  "DAS file addresses %ld to %ld. It has %ld rows of "
                  "%ld uint8, when it requires %ld rows of at least %ld "
                  "uint8.",
                  (long)(last-first+1), (long)first, (long)last,
                  (long)irows, (long)datLen, (long)xrows, (long)epos+1 );
         mexErrMsgTxt( msg );
      }
   }

   retData = A_CHAR_ARGV(6);

   dasrdc_c ( handle, first, last, bpos, epos, datLen, retData );
   CHECK_CALL_FAILURE(SCALAR);

   /*
   Allocate the needed memory to return an uint8 matrix of the transposed
   size as the input `data' to Matlab.

   CSPICE returns a two-dimensional array of characters, where each "line"
   is stored in contiguous memory space.

   MATLAB stores data in a column-major order: the length of each "line"
   is the number rows of the Matlab object, while the number of lines is
   the number of columns of the Matlab object.

   The 2-dimensional array returned by CSPICE will be transposed by the
   Mice interface before passing it to the user.
   */
   plhs[0] = mxCreateNumericMatrix( datLen, irows, mxUINT8_CLASS, mxREAL);
   data    = A_CHAR_RET_ARGV(0);

   memmove( (void*)data, (const void*)retData, irows*datLen);

   }




/*
   void dasrdd_c ( SpiceInt            handle,
                   SpiceInt            first,
                   SpiceInt            last,
                   SpiceDouble         data   [] )
*/
void cspice_dasrdd(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             handle;
   SpiceInt             first;
   SpiceInt             last;

   SpiceInt             dataLen;
   SpiceDouble        * data;
   SpiceDouble        * retData = NULL;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle",  MiceInt,      0, {0},   0},
      { "first",   MiceInt,      0, {0},   0},
      { "last",    MiceInt,      0, {0},   0},
      { "data",    MiceIgnore,   1, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle   = S_INT_ARGV(1);
   first    = S_INT_ARGV(2);
   last     = S_INT_ARGV(3);

   /*
   Allocate the necessary memory for `retData'.
   mxMalloc returns to top level in case of error.
   */
   dataLen = last - first + 1;
   if ( dataLen > 0 )
   {
      retData = (SpiceDouble*) mxMalloc( dataLen * sizeof(SpiceDouble) );
   }

   dasrdd_c ( handle, first, last, retData );

   /*
   Check for a failure signal. Free the memory assigned to `retData'
   before signaling a Matlab error.
   */
   if ( failed_c())
      {
      mxFree( retData );

      /*
      The mice_fail call creates the error string then returns control
      to the MATLAB interpreter.
      */
      mice_fail(SCALAR);
      }

   /*
   Allocate the needed memory to return a vector of size `dataLen'
   to MATLAB.
   */
   dataLen = MaxVal( dataLen, 0 );
   plhs[0] = mxCreateDoubleMatrix( dataLen, 1, mxREAL );
   data    = A_DBL_RET_ARGV(0);
   MOVED( retData, dataLen, data );
   mxFree( retData );

   }




/*
   void dasrdi_c ( SpiceInt            handle,
                   SpiceInt            first,
                   SpiceInt            last,
                   SpiceInt            data   [] )
*/
void cspice_dasrdi(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             handle;
   SpiceInt             first;
   SpiceInt             last;

   SpiceInt             dataLen;
   SpiceInt           * data;
   SpiceInt           * retData = NULL;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle",  MiceInt,      0, {0},   0},
      { "first",   MiceInt,      0, {0},   0},
      { "last",    MiceInt,      0, {0},   0},
      { "data",    MiceIgnore,   1, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle   = S_INT_ARGV(1);
   first    = S_INT_ARGV(2);
   last     = S_INT_ARGV(3);

   /*
   Allocate the necessary memory for `retData'.
   mxMalloc returns to top level in case of error.
   */
   dataLen = last - first + 1;
   if ( dataLen > 0 )
   {
      retData = (SpiceInt*) mxMalloc( dataLen * sizeof(SpiceInt) );
   }

   dasrdi_c ( handle, first, last, retData );

   /*
   Check for a failure signal. Free the memory assigned to `retData'
   before signaling a Matlab error.
   */
   if ( failed_c())
      {
      mxFree( retData );

      /*
      The mice_fail call creates the error string then returns control
      to the MATLAB interpreter.
      */
      mice_fail(SCALAR);
      }

   /*
   Allocate the needed memory to return a vector of size `dataLen'
   to MATLAB.
   */
   dataLen = MaxVal( dataLen, 0 );
   plhs[0] = mxCreateNumericMatrix( dataLen, 1, mxINT32_CLASS, mxREAL);
   data    = A_INT_RET_ARGV(0);
   MOVEI( retData, dataLen, data );
   mxFree( retData );

   }




/*
   void dasudc_c ( SpiceInt            handle,
                   SpiceInt            first,
                   SpiceInt            last,
                   SpiceInt            bpos,
                   SpiceInt            epos,
                   SpiceInt            datlen,
                   const void        * data   )
*/
void cspice_dasudc(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             handle;
   SpiceInt             first;
   SpiceInt             last;
   SpiceInt             bpos;
   SpiceInt             epos;
   SpiceChar          * data;
   SpiceInt             datLen;
   SpiceInt             irows;
   SpiceInt             xrows;

   /* The message buffer to write an error message */
   char                 msg[1024];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle",  MiceInt,      0, {0},   0},
      { "first",   MiceInt,      0, {0},   0},
      { "last",    MiceInt,      0, {0},   0},
      { "bpos",    MiceInt,      0, {0},   0},
      { "epos",    MiceInt,      0, {0},   0},
      { "data",    MiceByte,     2, {0,0}, 0},
      };

   check_arg_num( nrhs, nlhs, 6, 0 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle   = S_INT_ARGV(1);
   first    = S_INT_ARGV(2);
   last     = S_INT_ARGV(3);
   bpos     = S_INT_ARGV(4) - 1;
   epos     = S_INT_ARGV(5) - 1;

   /*
   Note that the data has been transposed before passing it to the
   gateway in order to have each row in a contiguous block of memory as
   expected by CSPICE. MATLAB stores data in a column-major order: the
   length of each "line" is the number rows of the Matlab object, while
   the number of lines is the number of columns of the Matlab object.
   */
   datLen   = (SpiceInt)mxGetM(prhs[6]);
   irows    = (SpiceInt)mxGetN(prhs[6]);

   /*
   Verify that `data' contains enough characters to update the

      last-first+1

   character addresses from the DAS file. Make sure we can compute
   `xrows'. If not, the error will be detected and signaled by a
   routine in the call tree.
   */
   if ( epos - bpos + 1 )
   {
      xrows = (long)(( last - first + epos - bpos + 1) / ( epos - bpos + 1 ));
      if ( irows < xrows )
      {
         sprintf( msg,"MICE(INSUFFICIENTDATA): `data` "
                  "does not have enough data to update %ld characters from "
                  "DAS file addresses %ld to %ld. It has %ld rows of "
                  "%ld characters, when it requires %ld rows of at least %ld "
                  "characters.",
                  (long)(last-first+1), (long)first, (long)last,
                  (long)irows, (long)datLen, (long)xrows, (long)epos+1 );
         mexErrMsgTxt( msg );
      }
   }

   data = A_CHAR_ARGV(6);

   dasudc_c ( handle, first, last, bpos, epos, datLen, data );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void dasudd_c ( SpiceInt            handle,
                   SpiceInt            first,
                   SpiceInt            last,
                   ConstSpiceDouble    data   [] )
*/
void cspice_dasudd(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             handle;
   SpiceInt             first;
   SpiceInt             last;
   ConstSpiceDouble   * data;
   SpiceInt             dataLen;

   /* The message buffer to write an error message */
   char                 msg[1024];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle",  MiceInt,      0, {0},   0},
      { "first",   MiceInt,      0, {0},   0},
      { "last",    MiceInt,      0, {0},   0},
      { "data",    MiceDouble,   1, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 4, 0 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle   = S_INT_ARGV(1);
   first    = S_INT_ARGV(2);
   last     = S_INT_ARGV(3);

   data     = A_DBL_ARGV(4);
   dataLen  = A_LEN_ARGV(4);

   if ( dataLen < (last-first+1) )
   {
      sprintf( msg, "MICE(INSUFFICIENTDATA): `data` does not have enough "
               "data to update the double precision addresses %ld to %ld "
               "from the DAS file. It has only %ld elements, when it "
               "requires %ld.", (long)first, (long)last,
               (long)dataLen, (long)(last-first+1) );
      mexErrMsgTxt( msg );
   }

   dasudd_c ( handle, first, last, data );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void dasudi_c ( SpiceInt            handle,
                   SpiceInt            first,
                   SpiceInt            last,
                   ConstSpiceInt       data   [] )
*/
void cspice_dasudi(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             handle;
   SpiceInt             first;
   SpiceInt             last;
   ConstSpiceInt      * data;
   SpiceInt             dataLen;

   /* The message buffer to write an error message */
   char                 msg[1024];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle",  MiceInt,      0, {0},   0},
      { "first",   MiceInt,      0, {0},   0},
      { "last",    MiceInt,      0, {0},   0},
      { "data",    MiceInt,      1, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 4, 0 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle   = S_INT_ARGV(1);
   first    = S_INT_ARGV(2);
   last     = S_INT_ARGV(3);

   data     = A_INT_ARGV(4);
   dataLen  = A_LEN_ARGV(4);

   if ( dataLen < (last-first+1) )
   {
      sprintf( msg, "MICE(INSUFFICIENTDATA): `data` does not have enough "
               "data to update the integer addresses %ld to %ld from the "
               "DAS file. It has only %ld elements, when it requires %ld.",
               (long)first, (long)last, (long)dataLen, (long)(last-first+1) );
      mexErrMsgTxt( msg );
   }

   dasudi_c ( handle, first, last, data );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void daswbr_c ( SpiceInt            handle )
*/
void cspice_daswbr(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             handle;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle",  MiceInt,      0, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 1, 0 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle   = S_INT_ARGV(1);


   daswbr_c ( handle );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void dazldr_c ( SpiceDouble         x,
                   SpiceDouble         y,
                   SpiceDouble         z,
                   SpiceBoolean        azccw,
                   SpiceBoolean        elplsz,
                   SpiceDouble         jacobi [3][3] )
*/
void cspice_dazldr(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble          x;
   SpiceDouble          y;
   SpiceDouble          z;
   SpiceBoolean         azccw;
   SpiceBoolean         elplsz;
   SpiceDouble        * jacobi;
   SpiceDouble          ret_jacobi[3][3];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "x",       MiceDouble,   0, {0},   0},
      { "y",       MiceDouble,   0, {0},   0},
      { "z",       MiceDouble,   0, {0},   0},
      { "azccw",   MiceInt,      0, {0},   0},
      { "elplsz",  MiceInt,      0, {0},   0},
      { "jacobi",  MiceDouble,   2, {3,3}, 0},
      };

   check_arg_num( nrhs, nlhs, 5, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   x        = S_DBL_ARGV(1);
   y        = S_DBL_ARGV(2);
   z        = S_DBL_ARGV(3);

   azccw    = *(SpiceBoolean*)mxGetData(prhs[4]);
   elplsz   = *(SpiceBoolean*)mxGetData(prhs[5]);

   jacobi   = A_DBL_RET_ARGV(0);

   dazldr_c ( x, y, z, azccw, elplsz, (SpiceDouble(*)[3])ret_jacobi );
   CHECK_CALL_FAILURE(SCALAR);

   xpose_c ( ret_jacobi, (SpiceDouble(*)[3])jacobi );

   }




/*
   void              dcyldr_c ( SpiceDouble         x,
                                SpiceDouble         y,
                                SpiceDouble         z,
                                SpiceDouble         jacobi[3][3] )
*/
void cspice_dcyldr(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_x;
   SpiceDouble        * vec_y;
   SpiceDouble        * vec_z;
   SpiceDouble        * vec_jacobi;
   SpiceDouble          x;
   SpiceDouble          y;
   SpiceDouble          z;
   SpiceDouble        * jacobi;
   SpiceDouble          xr[3][3];

   mwIndex              i;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "x",      MiceDouble, 0, {0},    1},
      { "y",      MiceDouble, 0, {0},    1},
      { "z",      MiceDouble, 0, {0},    1},
      { "jacobi", MiceDouble, 2, {3, 3}, 1},
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_x      = A_DBL_ARGV(1);
   vec_y      = A_DBL_ARGV(2);
   vec_z      = A_DBL_ARGV(3);
   x          = *vec_x;
   y          = *vec_y;
   z          = *vec_z;
   vec_jacobi = A_DBL_RET_ARGV(0);
   jacobi     = vec_jacobi;

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         x   = *(vec_x + i*extra->offset[0]);
         y   = *(vec_y + i*extra->offset[1]);
         z   = *(vec_z + i*extra->offset[2]);
         jacobi = (vec_jacobi + i*extra->offset[3]);

         dcyldr_c(x, y, z, (SpiceDouble(*)[3])xr);

         CHECK_CALL_FAILURE(i);

         xpose_c( xr, (SpiceDouble(*)[3])jacobi );
         }

      }
   else
      {
      dcyldr_c(x, y, z, (SpiceDouble(*)[3])xr);

      CHECK_CALL_FAILURE(SCALAR);

      xpose_c( xr, (SpiceDouble(*)[3])jacobi );
      }

   }




/*
   void              deltet_c( SpiceDouble      epoch,
                               ConstSpiceChar * eptype,
                               SpiceDouble    * delta )
*/
void cspice_deltet(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_epoch;
   SpiceDouble          epoch;
   SpiceChar            eptype[DEFAULT_STR_LENGTH+1];
   SpiceDouble        * vec_delta;
   SpiceDouble        * delta;

   mwIndex              i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "epoch",  MiceDouble, 0, {0}, 1},
      { "eptype", MiceChar,   0, {0}, 0},
      { "delta",  MiceDouble, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[2], eptype, DEFAULT_STR_LENGTH);

   vec_epoch = A_DBL_ARGV(1);
   vec_delta = A_DBL_RET_ARGV(0);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         epoch = *(vec_epoch+i*extra->offset[0]);
         delta = vec_delta + i*extra->offset[2];

         deltet_c( epoch, eptype, delta );
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {

      epoch = *vec_epoch;
      delta = vec_delta;

      deltet_c( epoch, eptype, delta );
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void              dgeodr_c ( SpiceDouble         x,
                                SpiceDouble         y,
                                SpiceDouble         z,
                                SpiceDouble         re,
                                SpiceDouble         f,
                                SpiceDouble         jacobi[3][3] )
*/
void cspice_dgeodr(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_x;
   SpiceDouble        * vec_y;
   SpiceDouble        * vec_z;
   SpiceDouble        * vec_jacobi;
   SpiceDouble          x;
   SpiceDouble          y;
   SpiceDouble          z;
   SpiceDouble          re;
   SpiceDouble          f;
   SpiceDouble        * jacobi;
   SpiceDouble          xr[3][3];

   mwIndex              i;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "x",      MiceDouble, 0, {0},    1},
      { "y",      MiceDouble, 0, {0},    1},
      { "z",      MiceDouble, 0, {0},    1},
      { "re",     MiceDouble, 0, {0},    0},
      { "f",      MiceDouble, 0, {0},    0},
      { "jacobi", MiceDouble, 2, {3, 3}, 1},
      };

   check_arg_num( nrhs, nlhs, 5, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_x    = A_DBL_ARGV(1);
   vec_y    = A_DBL_ARGV(2);
   vec_z    = A_DBL_ARGV(3);
   x        = *(vec_x);
   y        = *(vec_y);
   z        = *(vec_z);
   re         = S_DBL_ARGV(4);
   f          = S_DBL_ARGV(5);
   vec_jacobi = A_DBL_RET_ARGV(0);
   jacobi     = vec_jacobi;

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         x      = *(vec_x     + i*extra->offset[0]);
         y      = *(vec_y     + i*extra->offset[1]);
         z      = *(vec_z     + i*extra->offset[2]);
         jacobi = (vec_jacobi + i*extra->offset[5]);

         dgeodr_c(x, y, z, re, f, (SpiceDouble(*)[3])xr);
         CHECK_CALL_FAILURE(i);

         xpose_c( xr, (SpiceDouble(*)[3])jacobi );
         }

      }
   else
      {
      dgeodr_c(x, y, z, re, f, (SpiceDouble(*)[3])xr);
      CHECK_CALL_FAILURE(SCALAR);

      xpose_c( xr, (SpiceDouble(*)[3])jacobi );
      }

   }




/*
   void dlabbs_c ( SpiceInt         handle,
                   SpiceDLADescr  * dladsc,
                   SpiceBoolean   * found  )
*/
void cspice_dlabbs(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             handle;
   SpiceDLADescr        local_dladsc;
   SpiceInt           * dladsc;
   SpiceBoolean       * found;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle",  MiceInt,      0, {0},                0},
      { "dladsc",  MiceInt,      1, {SPICE_DLA_DSCSIZ}, 0},
      { "found",   MiceBoolean,  0, {0},                0},
      };

   check_arg_num( nrhs, nlhs, 1, 2 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle   = S_INT_ARGV(1);

   dladsc   = A_INT_RET_ARGV(0);
   found    = A_BOOL_RET_ARGV(1);

   dlabbs_c ( handle, &local_dladsc, found );
   CHECK_CALL_FAILURE(SCALAR);

   dladsc[SPICE_DLA_BWDIDX] = local_dladsc.bwdptr;
   dladsc[SPICE_DLA_FWDIDX] = local_dladsc.fwdptr;
   dladsc[SPICE_DLA_IBSIDX] = local_dladsc.ibase;
   dladsc[SPICE_DLA_ISZIDX] = local_dladsc.isize;
   dladsc[SPICE_DLA_DBSIDX] = local_dladsc.dbase;
   dladsc[SPICE_DLA_DSZIDX] = local_dladsc.dsize;
   dladsc[SPICE_DLA_CBSIDX] = local_dladsc.cbase;
   dladsc[SPICE_DLA_CSZIDX] = local_dladsc.csize;

   }




/*
   void        dlabfs_c( SpiceInt       handle,
                         SpiceInt       dladsc[8],
                         SpiceBoolean * found     )
*/
void cspice_dlabfs(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {
   SpiceInt             handle;
   SpiceDLADescr        local_descr;
   SpiceInt           * dladsc;
   SpiceBoolean         found;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle", MiceInt,     0, {0},                0},
      { "dladsc", MiceInt,     1, {SPICE_DLA_DSCSIZ}, 0},
      { "found",  MiceIgnore,  0, {0},                0}
      };

   check_arg_num( nrhs, nlhs, 1, 2 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle = S_INT_ARGV(1);

   dladsc = A_INT_RET_ARGV(0);

   dlabfs_c(handle, &local_descr, &found );
   CHECK_CALL_FAILURE(SCALAR);

   dladsc[SPICE_DLA_BWDIDX] = local_descr.bwdptr;
   dladsc[SPICE_DLA_FWDIDX] = local_descr.fwdptr;
   dladsc[SPICE_DLA_IBSIDX] = local_descr.ibase;
   dladsc[SPICE_DLA_ISZIDX] = local_descr.isize;
   dladsc[SPICE_DLA_DBSIDX] = local_descr.dbase;
   dladsc[SPICE_DLA_DSZIDX] = local_descr.dsize;
   dladsc[SPICE_DLA_CBSIDX] = local_descr.cbase;
   dladsc[SPICE_DLA_CSZIDX] = local_descr.csize;


   plhs[1] = zzmice_CreateIntScalar( found );

   }




/*
   void dlabns_c ( SpiceInt            handle )
*/
void cspice_dlabns(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             handle;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle",  MiceInt,      0, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 1, 0 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle   = S_INT_ARGV(1);


   dlabns_c ( handle );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void dlaens_c ( SpiceInt            handle )
*/
void cspice_dlaens(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             handle;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle",  MiceInt,      0, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 1, 0 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle   = S_INT_ARGV(1);


   dlaens_c ( handle );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void        dlafns_c( SpiceInt       handle,
                         SpiceInt       dladsc[8],
                         SpiceInt       nxtdsc[8],
                         SpiceBoolean * found     )
*/
void cspice_dlafns(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {
   SpiceInt             handle;
   SpiceDLADescr        local_dladsc;
   SpiceDLADescr        local_nxtdsc;
   SpiceInt           * dladsc;
   SpiceInt           * nxtdsc;
   SpiceBoolean         found;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle", MiceInt,     0, {0},                0},
      { "dladsc", MiceInt,     1, {SPICE_DLA_DSCSIZ}, 0},
      { "nxtdsc", MiceInt,     1, {SPICE_DLA_DSCSIZ}, 0},
      { "found",  MiceIgnore,  0, {0},                0}
      };

   check_arg_num( nrhs, nlhs, 2, 2 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle = S_INT_ARGV(1);
   dladsc = A_INT_ARGV(2);

   local_dladsc.bwdptr = dladsc[SPICE_DLA_BWDIDX];
   local_dladsc.fwdptr = dladsc[SPICE_DLA_FWDIDX];
   local_dladsc.ibase  = dladsc[SPICE_DLA_IBSIDX];
   local_dladsc.isize  = dladsc[SPICE_DLA_ISZIDX];
   local_dladsc.dbase  = dladsc[SPICE_DLA_DBSIDX];
   local_dladsc.dsize  = dladsc[SPICE_DLA_DSZIDX];
   local_dladsc.cbase  = dladsc[SPICE_DLA_CBSIDX];
   local_dladsc.csize  = dladsc[SPICE_DLA_CSZIDX];

   nxtdsc = A_INT_RET_ARGV(0);

   dlafns_c(handle, &local_dladsc, &local_nxtdsc, &found );
   CHECK_CALL_FAILURE(SCALAR);

   nxtdsc[SPICE_DLA_BWDIDX] = local_nxtdsc.bwdptr;
   nxtdsc[SPICE_DLA_FWDIDX] = local_nxtdsc.fwdptr;
   nxtdsc[SPICE_DLA_IBSIDX] = local_nxtdsc.ibase;
   nxtdsc[SPICE_DLA_ISZIDX] = local_nxtdsc.isize;
   nxtdsc[SPICE_DLA_DBSIDX] = local_nxtdsc.dbase;
   nxtdsc[SPICE_DLA_DSZIDX] = local_nxtdsc.dsize;
   nxtdsc[SPICE_DLA_CBSIDX] = local_nxtdsc.cbase;
   nxtdsc[SPICE_DLA_CSZIDX] = local_nxtdsc.csize;


   plhs[1] = zzmice_CreateIntScalar( found );

   }




/*
   void dlafps_c ( SpiceInt               handle,
                   ConstSpiceDLADescr   * dladsc,
                   SpiceDLADescr        * prvdsc,
                   SpiceBoolean         * found   )
*/
void cspice_dlafps(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             handle;
   SpiceDLADescr        local_dladsc;
   SpiceInt           * dladsc;
   SpiceDLADescr        local_prvdsc;
   SpiceInt           * prvdsc;
   SpiceBoolean       * found;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle",  MiceInt,      0, {0},                0},
      { "dladsc",  MiceInt,      1, {SPICE_DLA_DSCSIZ}, 0},
      { "prvdsc",  MiceInt,      1, {SPICE_DLA_DSCSIZ}, 0},
      { "found",   MiceBoolean,  0, {0},                0},
      };

   check_arg_num( nrhs, nlhs, 2, 2 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle   = S_INT_ARGV(1);
   dladsc   = A_INT_ARGV(2);

   local_dladsc.bwdptr = dladsc[SPICE_DLA_BWDIDX];
   local_dladsc.fwdptr = dladsc[SPICE_DLA_FWDIDX];
   local_dladsc.ibase  = dladsc[SPICE_DLA_IBSIDX];
   local_dladsc.isize  = dladsc[SPICE_DLA_ISZIDX];
   local_dladsc.dbase  = dladsc[SPICE_DLA_DBSIDX];
   local_dladsc.dsize  = dladsc[SPICE_DLA_DSZIDX];
   local_dladsc.cbase  = dladsc[SPICE_DLA_CBSIDX];
   local_dladsc.csize  = dladsc[SPICE_DLA_CSZIDX];

   prvdsc   = A_INT_RET_ARGV(0);
   found    = A_BOOL_RET_ARGV(1);

   dlafps_c ( handle, &local_dladsc, &local_prvdsc, found );
   CHECK_CALL_FAILURE(SCALAR);

   prvdsc[SPICE_DLA_BWDIDX] = local_prvdsc.bwdptr;
   prvdsc[SPICE_DLA_FWDIDX] = local_prvdsc.fwdptr;
   prvdsc[SPICE_DLA_IBSIDX] = local_prvdsc.ibase;
   prvdsc[SPICE_DLA_ISZIDX] = local_prvdsc.isize;
   prvdsc[SPICE_DLA_DBSIDX] = local_prvdsc.dbase;
   prvdsc[SPICE_DLA_DSZIDX] = local_prvdsc.dsize;
   prvdsc[SPICE_DLA_CBSIDX] = local_prvdsc.cbase;
   prvdsc[SPICE_DLA_CSZIDX] = local_prvdsc.csize;

   }




/*
   void dlaopn_c ( ConstSpiceChar    * fname,
                   ConstSpiceChar    * ftype,
                   ConstSpiceChar    * ifname,
                   SpiceInt            ncomch,
                   SpiceInt          * handle )
*/
void cspice_dlaopn(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            fname  [DEFAULT_STR_LENGTH+1];
   SpiceChar            ftype  [DEFAULT_STR_LENGTH+1];
   SpiceChar            ifname [DEFAULT_STR_LENGTH+1];
   SpiceInt             ncomch;
   SpiceInt           * handle;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "fname",   MiceChar,     0, {0},   0},
      { "ftype",   MiceChar,     0, {0},   0},
      { "ifname",  MiceChar,     0, {0},   0},
      { "ncomch",  MiceInt,      0, {0},   0},
      { "handle",  MiceInt,      0, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 4, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], fname, DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], ftype, DEFAULT_STR_LENGTH);
   mxGetString(prhs[3], ifname, DEFAULT_STR_LENGTH);

   ncomch   = S_INT_ARGV(4);

   handle   = A_INT_RET_ARGV(0);

   dlaopn_c ( fname, ftype, ifname, ncomch, handle );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              dlatdr_c ( SpiceDouble         x,
                                SpiceDouble         y,
                                SpiceDouble         z,
                                SpiceDouble         jacobi[3][3] );
*/
void cspice_dlatdr(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_x;
   SpiceDouble        * vec_y;
   SpiceDouble        * vec_z;
   SpiceDouble        * vec_jacobi;
   SpiceDouble          x;
   SpiceDouble          y;
   SpiceDouble          z;
   SpiceDouble        * jacobi;
   SpiceDouble          xr[3][3];

   mwIndex              i;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "x",      MiceDouble, 0, {0},    1},
      { "y",      MiceDouble, 0, {0},    1},
      { "z",      MiceDouble, 0, {0},    1},
      { "jacobi", MiceDouble, 2, {3, 3}, 1},
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_x      = A_DBL_ARGV(1);
   vec_y      = A_DBL_ARGV(2);
   vec_z      = A_DBL_ARGV(3);
   x          = *vec_x;
   y          = *vec_y;
   z          = *vec_z;
   vec_jacobi = A_DBL_RET_ARGV(0);
   jacobi     = vec_jacobi;

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         x      = *(vec_x + i*extra->offset[0]);
         y      = *(vec_y + i*extra->offset[1]);
         z      = *(vec_z + i*extra->offset[2]);
         jacobi = (vec_jacobi + i*extra->offset[3]);

         dlatdr_c(x, y, z, (SpiceDouble(*)[3])xr);

         CHECK_CALL_FAILURE(i);

         xpose_c( xr, (SpiceDouble(*)[3])jacobi );
         }

      }
   else
      {
      dlatdr_c(x, y, z, (SpiceDouble(*)[3])xr);

      CHECK_CALL_FAILURE(SCALAR);

      xpose_c( xr, (SpiceDouble(*)[3])jacobi );
      }

   }




/*
   void dnearp_c ( ConstSpiceDouble    state  [6],
                   SpiceDouble         a,
                   SpiceDouble         b,
                   SpiceDouble         c,
                   SpiceDouble         dnear  [6],
                   SpiceDouble         dalt   [2],
                   SpiceBoolean      * found      )
*/
void cspice_dnearp(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * state;
   SpiceDouble          a;
   SpiceDouble          b;
   SpiceDouble          c;
   SpiceDouble        * dnear;
   SpiceDouble        * dalt;
   SpiceBoolean       * found;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "state",   MiceDouble,   1, {6},   0},
      { "a",       MiceDouble,   0, {0},   0},
      { "b",       MiceDouble,   0, {0},   0},
      { "c",       MiceDouble,   0, {0},   0},
      { "dnear",   MiceDouble,   1, {6},   0},
      { "dalt",    MiceDouble,   1, {2},   0},
      { "found",   MiceBoolean,  0, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 4, 3 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   state    = A_DBL_ARGV(1);
   a        = S_DBL_ARGV(2);
   b        = S_DBL_ARGV(3);
   c        = S_DBL_ARGV(4);

   dnear    = A_DBL_RET_ARGV(0);
   dalt     = A_DBL_RET_ARGV(1);
   found    = A_BOOL_RET_ARGV(2);

   dnearp_c ( state, a, b, c, dnear, dalt, found );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              dpgrdr_c ( ConstSpiceChar    * body,
                                SpiceDouble         x,
                                SpiceDouble         y,
                                SpiceDouble         z,
                                SpiceDouble         re,
                                SpiceDouble         f,
                                SpiceDouble         jacobi[3][3] )
*/
void cspice_dpgrdr(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            body       [DEFAULT_STR_LENGTH+1];
   SpiceDouble        * vec_x;
   SpiceDouble        * vec_y;
   SpiceDouble        * vec_z;
   SpiceDouble        * vec_jacobi;
   SpiceDouble          x;
   SpiceDouble          y;
   SpiceDouble          z;
   SpiceDouble          re;
   SpiceDouble          f;
   SpiceDouble        * jacobi;
   SpiceDouble          xr[3][3];

   mwIndex              i;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "body",   MiceChar,   0, {0},    0},
      { "x",      MiceDouble, 0, {0},    1},
      { "y",      MiceDouble, 0, {0},    1},
      { "z",      MiceDouble, 0, {0},    1},
      { "re",     MiceDouble, 0, {0},    0},
      { "f",      MiceDouble, 0, {0},    0},
      { "jacobi", MiceDouble, 2, {3, 3}, 1},
      };

   check_arg_num( nrhs, nlhs, 6, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString( prhs[1], body, DEFAULT_STR_LENGTH );

   vec_x      = A_DBL_ARGV(2);
   vec_y      = A_DBL_ARGV(3);
   vec_z      = A_DBL_ARGV(4);
   re         = S_DBL_ARGV(5);
   f          = S_DBL_ARGV(6);
   vec_jacobi = A_DBL_RET_ARGV(0);

   x          = *(vec_x);
   y          = *(vec_y);
   z          = *(vec_z);
   jacobi     = vec_jacobi;

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         x    = *(vec_x     + i*extra->offset[1]);
         y    = *(vec_y     + i*extra->offset[2]);
         z    = *(vec_z     + i*extra->offset[3]);
         jacobi = (vec_jacobi + i*extra->offset[6]);

         dpgrdr_c( body, x, y, z, re, f, (SpiceDouble (*)[3])xr);
         CHECK_CALL_FAILURE(i);

         xpose_c( xr, (SpiceDouble(*)[3])jacobi );
         }

      }
   else
      {
      dpgrdr_c( body, x, y, z, re, f, (SpiceDouble (*)[3])xr);
      CHECK_CALL_FAILURE(SCALAR);

      xpose_c( xr, (SpiceDouble(*)[3])jacobi );
      }

   }




/*
   SpiceDouble dpmax_c ()
*/
void cspice_dpmax(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   check_arg_num( nrhs, nlhs, 0, 1 );

   /*
   Directly return the scalar value. This simple case needs no
   error checks.
   */
   plhs[0] = mxCreateDoubleScalar( dpmax_c() );

   }




/*
   SpiceDouble dpmin_c ()
*/
void cspice_dpmin(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   check_arg_num( nrhs, nlhs, 0, 1 );

   /*
   Directly return the scalar value. This simple case needs no
   error checks.
   */
   plhs[0] = mxCreateDoubleScalar( dpmin_c() );

   }




/*
   SpiceDouble              dpr_c( void )
*/
void cspice_dpr(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   check_arg_num( nrhs, nlhs, 0, 1 );

   /*
   Directly return the scalar value. This simple case needs no
   error checks.
   */
   plhs[0] = mxCreateDoubleScalar( dpr_c() );

   }




/*
   void drdazl_c ( SpiceDouble         range,
                   SpiceDouble         az,
                   SpiceDouble         el,
                   SpiceBoolean        azccw,
                   SpiceBoolean        elplsz,
                   SpiceDouble         jacobi [3][3] )
*/
void cspice_drdazl(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble          range;
   SpiceDouble          az;
   SpiceDouble          el;
   SpiceBoolean         azccw;
   SpiceBoolean         elplsz;
   SpiceDouble        * jacobi;
   SpiceDouble          ret_jacobi[3][3];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "range",   MiceDouble,   0, {0},   0},
      { "az",      MiceDouble,   0, {0},   0},
      { "el",      MiceDouble,   0, {0},   0},
      { "azccw",   MiceInt,      0, {0},   0},
      { "elplsz",  MiceInt,      0, {0},   0},
      { "jacobi",  MiceDouble,   2, {3,3}, 0},
      };

   check_arg_num( nrhs, nlhs, 5, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   range    = S_DBL_ARGV(1);
   az       = S_DBL_ARGV(2);
   el       = S_DBL_ARGV(3);

   azccw    = *(SpiceBoolean*)mxGetData(prhs[4]);
   elplsz   = *(SpiceBoolean*)mxGetData(prhs[5]);

   jacobi   = A_DBL_RET_ARGV(0);

   drdazl_c ( range, az, el, azccw, elplsz, (SpiceDouble(*)[3])ret_jacobi );
   CHECK_CALL_FAILURE(SCALAR);

   xpose_c ( ret_jacobi, (SpiceDouble(*)[3])jacobi );

   }




/*
   void              drdcyl_c ( SpiceDouble    r,
                                SpiceDouble    clon,
                                SpiceDouble    z,
                                SpiceDouble    jacobi[3][3] )
*/
void cspice_drdcyl(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_r;
   SpiceDouble        * vec_clon;
   SpiceDouble        * vec_z;
   SpiceDouble        * vec_jacobi;
   SpiceDouble          r;
   SpiceDouble          clon;
   SpiceDouble          z;
   SpiceDouble        * jacobi;
   SpiceDouble          xr[3][3];

   mwIndex              i;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "r",      MiceDouble, 0, {0},    1},
      { "clon",   MiceDouble, 0, {0},    1},
      { "z",      MiceDouble, 0, {0},    1},
      { "jacobi", MiceDouble, 2, {3, 3}, 1},
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_r      = A_DBL_ARGV(1);
   vec_clon   = A_DBL_ARGV(2);
   vec_z      = A_DBL_ARGV(3);
   r          = *vec_r;
   clon       = *vec_clon;
   z          = *vec_z;
   vec_jacobi = A_DBL_RET_ARGV(0);
   jacobi     = vec_jacobi;

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         r      = *(vec_r     + i*extra->offset[0]);
         clon   = *(vec_clon  + i*extra->offset[1]);
         z      = *(vec_z     + i*extra->offset[2]);
         jacobi = (vec_jacobi + i*extra->offset[3]);

         drdcyl_c(r, clon, z, (SpiceDouble(*)[3])xr);
         CHECK_CALL_FAILURE(i);

         xpose_c( xr, (SpiceDouble(*)[3])jacobi );
         }

      }
   else
      {
      drdcyl_c(r, clon, z, (SpiceDouble(*)[3])xr);
      CHECK_CALL_FAILURE(SCALAR);

      xpose_c( xr, (SpiceDouble(*)[3])jacobi );
      }

   }




/*
   void              drdgeo_c ( SpiceDouble         lon,
                                SpiceDouble         lat,
                                SpiceDouble         alt,
                                SpiceDouble         re,
                                SpiceDouble         f,
                                SpiceDouble         jacobi[3][3] )
*/
void cspice_drdgeo(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_lon;
   SpiceDouble        * vec_lat;
   SpiceDouble        * vec_alt;
   SpiceDouble        * vec_jacobi;
   SpiceDouble          lon;
   SpiceDouble          lat;
   SpiceDouble          alt;
   SpiceDouble          re;
   SpiceDouble          f;
   SpiceDouble        * jacobi;
   SpiceDouble          xr[3][3];

   mwIndex              i;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "lon",    MiceDouble, 0, {0},    1},
      { "lat",    MiceDouble, 0, {0},    1},
      { "alt",    MiceDouble, 0, {0},    1},
      { "re",     MiceDouble, 0, {0},    0},
      { "f",      MiceDouble, 0, {0},    0},
      { "jacobi", MiceDouble, 2, {3, 3}, 1},
      };

   check_arg_num( nrhs, nlhs, 5, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_lon    = A_DBL_ARGV(1);
   vec_lat    = A_DBL_ARGV(2);
   vec_alt    = A_DBL_ARGV(3);
   lon        = *(vec_lon);
   lat        = *(vec_lat);
   alt        = *(vec_alt);
   re         = S_DBL_ARGV(4);
   f          = S_DBL_ARGV(5);
   vec_jacobi = A_DBL_RET_ARGV(0);
   jacobi     = vec_jacobi;

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         lon    = *(vec_lon     + i*extra->offset[0]);
         lat    = *(vec_lat     + i*extra->offset[1]);
         alt    = *(vec_alt     + i*extra->offset[2]);
         jacobi = (vec_jacobi + i*extra->offset[5]);

         drdgeo_c(lon, lat, alt, re, f, (SpiceDouble(*)[3])xr);
         CHECK_CALL_FAILURE(i);

         xpose_c( xr, (SpiceDouble(*)[3])jacobi );
         }

      }
   else
      {
      drdgeo_c(lon, lat, alt, re, f, (SpiceDouble(*)[3])xr);
      CHECK_CALL_FAILURE(SCALAR);

      xpose_c( xr, (SpiceDouble(*)[3])jacobi );
      }

   }




/*
   void              drdlat_c ( SpiceDouble    r,
                                SpiceDouble    lon,
                                SpiceDouble    lat,
                                SpiceDouble    jacobi[3][3] )
*/
void cspice_drdlat(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_r;
   SpiceDouble        * vec_lon;
   SpiceDouble        * vec_lat;
   SpiceDouble        * vec_jacobi;
   SpiceDouble          r;
   SpiceDouble          lon;
   SpiceDouble          lat;
   SpiceDouble        * jacobi;
   SpiceDouble          xr[3][3];

   mwIndex              i;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "r",      MiceDouble, 0, {0},    1},
      { "lon",    MiceDouble, 0, {0},    1},
      { "lat",    MiceDouble, 0, {0},    1},
      { "jacobi", MiceDouble, 2, {3, 3}, 1},
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_r      = A_DBL_ARGV(1);
   vec_lon    = A_DBL_ARGV(2);
   vec_lat    = A_DBL_ARGV(3);
   r          = *vec_r;
   lon        = *vec_lon;
   lat        = *vec_lat;
   vec_jacobi = A_DBL_RET_ARGV(0);
   jacobi     = vec_jacobi;

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         r     = *(vec_r      + i*extra->offset[0]);
         lon   = *(vec_lon    + i*extra->offset[1]);
         lat   = *(vec_lat    + i*extra->offset[2]);
         jacobi = (vec_jacobi + i*extra->offset[3]);

         drdlat_c(r, lon, lat, (SpiceDouble(*)[3])xr);
         CHECK_CALL_FAILURE(i);

         xpose_c( xr, (SpiceDouble(*)[3])jacobi );
         }

      }
   else
      {
      drdlat_c(r, lon, lat, (SpiceDouble(*)[3])xr);
      CHECK_CALL_FAILURE(SCALAR);

      xpose_c( xr, (SpiceDouble(*)[3])jacobi );
      }

   }




/*
   void              drdpgr_c ( ConstSpiceChar    * body,
                                SpiceDouble         lon,
                                SpiceDouble         lat,
                                SpiceDouble         alt,
                                SpiceDouble         re,
                                SpiceDouble         f,
                                SpiceDouble         jacobi[3][3] )
*/
void cspice_drdpgr(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            body       [DEFAULT_STR_LENGTH+1];
   SpiceDouble        * vec_lon;
   SpiceDouble        * vec_lat;
   SpiceDouble        * vec_alt;
   SpiceDouble        * vec_jacobi;
   SpiceDouble          lon;
   SpiceDouble          lat;
   SpiceDouble          alt;
   SpiceDouble          re;
   SpiceDouble          f;
   SpiceDouble        * jacobi;
   SpiceDouble          xr[3][3];

   mwIndex              i;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "body",   MiceChar,   0, {0},    0},
      { "lon",    MiceDouble, 0, {0},    1},
      { "lat",    MiceDouble, 0, {0},    1},
      { "alt",    MiceDouble, 0, {0},    1},
      { "re",     MiceDouble, 0, {0},    0},
      { "f",      MiceDouble, 0, {0},    0},
      { "jacobi", MiceDouble, 2, {3, 3}, 1},
      };

   check_arg_num( nrhs, nlhs, 6, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString( prhs[1], body, DEFAULT_STR_LENGTH );

   vec_lon    = A_DBL_ARGV(2);
   vec_lat    = A_DBL_ARGV(3);
   vec_alt    = A_DBL_ARGV(4);
   lon        = *(vec_lon);
   lat        = *(vec_lat);
   alt        = *(vec_alt);
   re         = S_DBL_ARGV(5);
   f          = S_DBL_ARGV(6);
   vec_jacobi = A_DBL_RET_ARGV(0);
   jacobi     = vec_jacobi;

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         lon    = *(vec_lon     + i*extra->offset[1]);
         lat    = *(vec_lat     + i*extra->offset[2]);
         alt    = *(vec_alt     + i*extra->offset[3]);
         jacobi = (vec_jacobi + i*extra->offset[6]);

         drdpgr_c( body, lon, lat, alt, re, f, (SpiceDouble (*)[3])xr);
         CHECK_CALL_FAILURE(i);

         xpose_c( xr, (SpiceDouble(*)[3])jacobi );
         }

      }
   else
      {
      drdpgr_c( body, lon, lat, alt, re, f, (SpiceDouble (*)[3])xr);
      CHECK_CALL_FAILURE(SCALAR);

      xpose_c( xr, (SpiceDouble(*)[3])jacobi );
      }

   }




/*
   void              drdsph_c ( SpiceDouble    r,
                                SpiceDouble    colat,
                                SpiceDouble    slon,
                                SpiceDouble    jacobi[3][3] )
*/
void cspice_drdsph(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_r;
   SpiceDouble        * vec_colat;
   SpiceDouble        * vec_slon;
   SpiceDouble        * vec_jacobi;
   SpiceDouble          r;
   SpiceDouble          colat;
   SpiceDouble          slon;
   SpiceDouble        * jacobi;
   SpiceDouble          xr[3][3];

   mwIndex              i;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "r",      MiceDouble, 0, {0},    1},
      { "colat",  MiceDouble, 0, {0},    1},
      { "slon",   MiceDouble, 0, {0},    1},
      { "jacobi", MiceDouble, 2, {3, 3}, 1},
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_r      = A_DBL_ARGV(1);
   vec_colat  = A_DBL_ARGV(2);
   vec_slon   = A_DBL_ARGV(3);
   r          = *vec_r;
   colat      = *vec_colat;
   slon       = *vec_slon;
   vec_jacobi = A_DBL_RET_ARGV(0);
   jacobi     = vec_jacobi;

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         r      = *(vec_r     + i*extra->offset[0]);
         colat  = *(vec_colat + i*extra->offset[1]);
         slon   = *(vec_slon  + i*extra->offset[2]);
         jacobi = (vec_jacobi + i*extra->offset[3]);

         drdsph_c(r, colat, slon, (SpiceDouble(*)[3])xr);
         CHECK_CALL_FAILURE(i);

         xpose_c( xr, (SpiceDouble(*)[3])jacobi );
         }

      }
   else
      {
      drdsph_c(r, colat, slon, (SpiceDouble(*)[3])xr);
      CHECK_CALL_FAILURE(SCALAR);

      xpose_c( xr, (SpiceDouble(*)[3])jacobi );
      }

   }




/*
   void              dskb02_c ( SpiceInt               handle,
                                ConstSpiceDLADescr   * dladsc,
                                SpiceInt             * nv,
                                SpiceInt             * np,
                                SpiceInt             * nvxtot,
                                SpiceDouble            vtxbds  [3][2],
                                SpiceDouble          * voxsiz,
                                SpiceDouble            voxori  [3],
                                SpiceInt               vgrext  [3],
                                SpiceInt             * cgscal,
                                SpiceInt             * vtxnpl,
                                SpiceInt             * voxnpt,
                                SpiceInt             * voxnpl          );
*/
void cspice_dskb02(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             handle;
   SpiceDLADescr        local_dladsc;
   SpiceInt           * dladsc;
   SpiceInt           * nv;
   SpiceInt           * np;
   SpiceInt           * nvxtot;
   SpiceDouble        * vtxbds;
   SpiceDouble        * voxsiz;
   SpiceDouble        * voxori;
   SpiceInt           * vgrext;
   SpiceInt           * cgscal;
   SpiceInt           * vtxnpl;
   SpiceInt           * voxnpt;
   SpiceInt           * voxnpl;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle", MiceInt,     0, {0},                0},
      { "dladsc", MiceInt,     1, {SPICE_DLA_DSCSIZ}, 0},
      { "nv",     MiceInt,     0, { 0    },           0},
      { "np",     MiceInt,     0, { 0    },           0},
      { "nvxtot", MiceInt,     0, { 0    },           0},
      { "vtxbds", MiceDouble,  2, { 2, 3 },           0},
      { "voxsiz", MiceDouble,  0, { 0    },           0},
      { "voxori", MiceDouble,  1, { 3    },           0},
      { "vgrext", MiceInt,     1, { 3    },           0},
      { "cgscal", MiceInt,     0, { 0    },           0},
      { "vtxnpl", MiceInt,     0, { 0    },           0},
      { "voxnpt", MiceInt,     0, { 0    },           0},
      { "voxnpl", MiceInt,     0, { 0    },           0}
      };

   check_arg_num( nrhs, nlhs, 2, 11 );

   extra  = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle = S_INT_ARGV(ONE_IN);
   dladsc = A_INT_ARGV(TWO_IN);

   nv     = A_INT_RET_ARGV(ONE_OUT);
   np     = A_INT_RET_ARGV(TWO_OUT);
   nvxtot = A_INT_RET_ARGV(THREE_OUT);
   vtxbds = A_DBL_RET_ARGV(FOUR_OUT);
   voxsiz = A_DBL_RET_ARGV(FIVE_OUT);
   voxori = A_DBL_RET_ARGV(SIX_OUT);
   vgrext = A_INT_RET_ARGV(SEVEN_OUT);
   cgscal = A_INT_RET_ARGV(EIGHT_OUT);
   vtxnpl = A_INT_RET_ARGV(NINE_OUT);
   voxnpt = A_INT_RET_ARGV(TEN_OUT);
   voxnpl = A_INT_RET_ARGV(ELEVEN_OUT);

   local_dladsc.bwdptr = dladsc[SPICE_DLA_BWDIDX];
   local_dladsc.fwdptr = dladsc[SPICE_DLA_FWDIDX];
   local_dladsc.ibase  = dladsc[SPICE_DLA_IBSIDX];
   local_dladsc.isize  = dladsc[SPICE_DLA_ISZIDX];
   local_dladsc.dbase  = dladsc[SPICE_DLA_DBSIDX];
   local_dladsc.dsize  = dladsc[SPICE_DLA_DSZIDX];
   local_dladsc.cbase  = dladsc[SPICE_DLA_CBSIDX];
   local_dladsc.csize  = dladsc[SPICE_DLA_CSZIDX];

   dskb02_c(   handle,
               &local_dladsc,
               nv,
               np,
               nvxtot,
               ( SpiceDouble (*) [2] ) vtxbds,
               voxsiz,
               voxori,
               vgrext,
               cgscal,
               vtxnpl,
               voxnpt,
               voxnpl                         );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              dskcls_c ( SpiceInt               handle,
                                SpiceBoolean           optmiz );
*/
void cspice_dskcls(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             handle;
   SpiceBoolean         optmiz;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle", MiceInt, 0, {0}, 0},
      { "optmiz", MiceInt, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 2, 0);

   extra  = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle = S_INT_ARGV(1);
   optmiz = *(SpiceBoolean*)mxGetData(prhs[2]);

   dskcls_c ( handle, optmiz );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              dskd02_c ( SpiceInt               handle,
                                ConstSpiceDLADescr   * dladsc,
                                SpiceInt               item,
                                SpiceInt               start,
                                SpiceInt               room,
                                SpiceInt             * n,
                                SpiceDouble          * values );
*/
void cspice_dskd02(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             handle;
   SpiceDLADescr        local_dladsc;
   SpiceInt           * dladsc;
   SpiceInt             item;
   SpiceInt             start;
   SpiceInt             room;
   SpiceInt             n;
   SpiceDouble        * values = 0;
   SpiceDouble        * dvals_ret;

   mwSize               sizearray[2];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle", MiceInt,     0, {0},                0},
      { "dladsc", MiceInt,     1, {SPICE_DLA_DSCSIZ}, 0},
      { "item",   MiceInt,     0, {0},                0},
      { "start",  MiceInt,     0, {0},                0},
      { "room",   MiceInt,     0, {0},                0},
      { "values", MiceIgnore,  0, {0},                0}
      };

   check_arg_num( nrhs, nlhs, 5, 1 );

   extra  = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle = S_INT_ARGV(1);
   dladsc = A_INT_ARGV(2);

   local_dladsc.bwdptr = dladsc[SPICE_DLA_BWDIDX];
   local_dladsc.fwdptr = dladsc[SPICE_DLA_FWDIDX];
   local_dladsc.ibase  = dladsc[SPICE_DLA_IBSIDX];
   local_dladsc.isize  = dladsc[SPICE_DLA_ISZIDX];
   local_dladsc.dbase  = dladsc[SPICE_DLA_DBSIDX];
   local_dladsc.dsize  = dladsc[SPICE_DLA_DSZIDX];
   local_dladsc.cbase  = dladsc[SPICE_DLA_CBSIDX];
   local_dladsc.csize  = dladsc[SPICE_DLA_CSZIDX];

   item   = S_INT_ARGV(3);

   /*
   Here we DO subtract one off the start index,
   since "start" is an arbitrary array index, as
   opposed to an ID (e.g. of a plate or vertex).
   */
   start  = S_INT_ARGV(4) - 1;
   room   = S_INT_ARGV(5);


   sizearray[0] = 1;
   sizearray[1] = room;

   if ( room > 0 )
      {
      values  = (SpiceDouble *)mxMalloc(room * sizeof(SpiceDouble) );

      dskd02_c ( handle, &local_dladsc, item, start, room, &n, values );

      if ( failed_c() )
         {
         mxFree( values );
         /*
         The mice_fail call creates the error string then returns control
         to the MATLAB interpreter.
         */
         mice_fail(SCALAR);
         }
      }
   else
      {
         n = 0;
      }

   if( n > 0 )
      {
      sizearray[0] = 1;
      sizearray[1] = n;
      }
   else
      {
      sizearray[0] = 0;
      sizearray[1] = 0;
      }

   plhs[0]   = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
   dvals_ret = A_DBL_RET_ARGV(0);

   if ( n > 0 )
      {
      /*
      Note that n > 0 is possible only if room > 0, so vrtces is non-null here.
      */
      MOVED( (SpiceDouble *)values, n, dvals_ret );
      }

   if ( room > 0 )
      {
      /*
      We allocated space for `room' vertices; deallocate this space now.
      */
      mxFree( values );
      }

   }




/*

   void              dski02_c ( SpiceInt              handle,
                                ConstSpiceDLADescr  * dladsc,
                                SpiceInt              item,
                                SpiceInt              start,
                                SpiceInt              room,
                                SpiceInt            * n,
                                SpiceInt            * values   );


*/
void cspice_dski02(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {
   SpiceInt             handle;
   SpiceDLADescr        local_dladsc;
   SpiceInt           * dladsc;
   SpiceInt             item;
   SpiceInt             start;
   SpiceInt             room;
   SpiceInt             n;
   SpiceInt           * values = 0;
   SpiceInt           * ivals_ret;

   mwSize               sizearray[2];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle", MiceInt,     0, {0},                0},
      { "dladsc", MiceInt,     1, {SPICE_DLA_DSCSIZ}, 0},
      { "item",   MiceInt,     0, {0},                0},
      { "start",  MiceInt,     0, {0},                0},
      { "room",   MiceInt,     0, {0},                0},
      { "values", MiceIgnore,  0, {0},                0}
      };

   check_arg_num( nrhs, nlhs, 5, 1 );

   extra  = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle = S_INT_ARGV(1);
   dladsc = A_INT_ARGV(2);

   local_dladsc.bwdptr = dladsc[SPICE_DLA_BWDIDX];
   local_dladsc.fwdptr = dladsc[SPICE_DLA_FWDIDX];
   local_dladsc.ibase  = dladsc[SPICE_DLA_IBSIDX];
   local_dladsc.isize  = dladsc[SPICE_DLA_ISZIDX];
   local_dladsc.dbase  = dladsc[SPICE_DLA_DBSIDX];
   local_dladsc.dsize  = dladsc[SPICE_DLA_DSZIDX];
   local_dladsc.cbase  = dladsc[SPICE_DLA_CBSIDX];
   local_dladsc.csize  = dladsc[SPICE_DLA_CSZIDX];

   item   = S_INT_ARGV(3);

   /*
   Here we DO subtract one off the start index,
   since "start" is an arbitrary array index, as
   opposed to an ID (e.g. of a plate or vertex).
   */
   start  = S_INT_ARGV(4) - 1;
   room   = S_INT_ARGV(5);


   sizearray[0] = 1;
   sizearray[1] = room;

   if ( room > 0 )
      {
      values  = (SpiceInt *)mxMalloc(room * sizeof(SpiceInt) );

      dski02_c ( handle, &local_dladsc, item, start, room, &n, values );

      if ( failed_c() )
         {
         mxFree( values );
         /*
         The mice_fail call creates the error string then returns control
         to the MATLAB interpreter.
         */
         mice_fail(SCALAR);
         }
      }
   else
      {
         n = 0;
      }

   if( n > 0 )
      {
      sizearray[0] = 1;
      sizearray[1] = n;
      }
   else
      {
      sizearray[0] = 0;
      sizearray[1] = 0;
      }

   plhs[0]   = mxCreateNumericArray( 2, sizearray, mxINT32_CLASS, mxREAL);
   ivals_ret = A_INT_RET_ARGV(0);

   if ( n > 0 )
      {
      /*
      Note that n > 0 is possible only if room > 0, so vrtces is non-null here.
      */
      MOVEI( (SpiceInt *)values, n, ivals_ret );
      }

   if ( room > 0 )
      {
      /*
      We allocated space for `room' vertices; deallocate this space now.
      */
      mxFree( values );
      }

   }




/*
   void        dskgd_  ( SpiceInt       handle,
                         SpiceInt       dladsc[SPICE_DLA_DSCSIZ],
                         SpiceDouble    dskdsc[SPICE_DSK_DSCSIZ]  )
*/
void cspice_dskgd(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {
   SpiceInt             handle;
   SpiceInt           * dladsc;
   SpiceDouble        * dskdsc;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle", MiceInt,     0, {0},                0},
      { "dladsc", MiceInt,     1, {SPICE_DLA_DSCSIZ}, 0},
      { "dskdsc", MiceDouble,  1, {SPICE_DSK_DSCSIZ}, 0}
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle = S_INT_ARGV(1);
   dladsc = A_INT_ARGV(2);
   dskdsc = A_DBL_RET_ARGV(0);

   /* For convenience, use the f2c'd call. */

   dskgd_(  (integer    *) &handle,
            (integer    *) dladsc,
            (doublereal *) dskdsc  );

   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              dskgtl_c ( SpiceInt        keywrd,
                                SpiceDouble   * dpval  )
*/
void cspice_dskgtl(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             keywrd;
   SpiceDouble        * dpval;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "keywrd", MiceInt,    0, {0}, 0},
      { "dpval",  MiceDouble, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 1, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   keywrd = S_INT_ARGV(1);
   dpval  = A_DBL_RET_ARGV(0);

   (void)dskgtl_c( keywrd, dpval);
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              dskmi2_c ( SpiceInt              nv,
                                ConstSpiceDouble      vrtces[][3],
                                SpiceInt              np,
                                ConstSpiceInt         plates[][3],
                                SpiceDouble           finscl,
                                SpiceInt              corscl,
                                SpiceInt              worksz,
                                SpiceInt              voxpsz,
                                SpiceInt              voxlsz,
                                SpiceBoolean          makvtl,
                                SpiceInt              spxisz,
                                SpiceInt              work   [][2],
                                SpiceDouble           spaixd [],
                                SpiceInt              spaixi []    );
*/
void cspice_dskmi2(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vrtces;
   SpiceInt           * plates;
   SpiceDouble          finscl;
   SpiceInt             corscl;
   SpiceInt             worksz;
   SpiceInt             voxpsz;
   SpiceInt             voxlsz;
   SpiceBoolean         makvtl;
   SpiceInt             spxisz;

   SpiceInt           * work;
   SpiceDouble        * spaixd;
   SpiceInt           * spaixi;

   SpiceDouble        * spaixd_ret;
   SpiceInt           * spaixi_ret;
   SpiceInt             nv = 0;
   SpiceInt             np = 0;

   mwSize               sizearray[2];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "vrtces", MiceDouble, 2, {3,0}, 0},
      { "plates", MiceInt,    2, {3,0}, 0},
      { "finscl", MiceDouble, 1, {0},   0},
      { "corscl", MiceInt,    0, {0},   0},
      { "worksz", MiceInt,    0, {0},   0},
      { "voxpsz", MiceInt,    0, {0},   0},
      { "voxlsz", MiceInt,    0, {0},   0},
      { "makvtl", MiceInt,    0, {0},   0},
      { "spxisz", MiceInt,    0, {0},   0},
      { "spaixd", MiceIgnore, 0, {0},   0},
      { "spaixi", MiceIgnore, 0, {0},   0}
      };

   check_arg_num( nrhs, nlhs, 9, 2 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vrtces  = (SpiceDouble   *)mxGetData(prhs[1]);
   plates  = (SpiceInt      *)mxGetData(prhs[2]);
   finscl  = S_DBL_ARGV(3);
   corscl  = S_INT_ARGV(4);
   worksz  = S_INT_ARGV(5);
   voxpsz  = S_INT_ARGV(6);
   voxlsz  = S_INT_ARGV(7);
   makvtl  = *(SpiceBoolean*)mxGetData(prhs[8]);
   spxisz  = S_INT_ARGV(9);

   nv = mxGetNumberOfElements( prhs[1] )/3;
   np = mxGetNumberOfElements( prhs[2] )/3;

   work   = (SpiceInt*   )mxMalloc(worksz  * 2        * sizeof(SpiceInt)    );
   spaixd = (SpiceDouble*)mxMalloc(SPICE_DSK02_SPADSZ * sizeof(SpiceDouble) );
   spaixi = (SpiceInt*   )mxMalloc(spxisz             * sizeof(SpiceInt)    );

   dskmi2_c ( nv,
              (Nx3d)vrtces,
              np,
              (Nx3i)plates,
              finscl,
              corscl,
              worksz,
              voxpsz,
              voxlsz,
              makvtl,
              spxisz,
              (SpiceInt(*)[2])work,
              spaixd,
              spaixi );

   /*
   Check for a failure signal. Free the memory assigned to 'work', 'spaixd',
   'spaixi' before signaling a Matlab error.
   */
   if ( failed_c())
      {
      mxFree( work   );
      mxFree( spaixd );
      mxFree( spaixi );

      /*
      The mice_fail call creates the error string then returns control
      to the MATLAB interpreter.
      */
      mice_fail(SCALAR);
      }

   sizearray[0] = SPICE_DSK02_SPADSZ;
   sizearray[1] = 1;
   plhs[0]    = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
   spaixd_ret = A_DBL_RET_ARGV(0);

   MOVED( spaixd, SPICE_DSK02_SPADSZ, spaixd_ret );

   sizearray[0] = spxisz;
   sizearray[1] = 1;
   plhs[1]    = mxCreateNumericArray( 2, sizearray, mxINT32_CLASS, mxREAL);
   spaixi_ret = A_INT_RET_ARGV(1);

   MOVEI( spaixi, spxisz, spaixi_ret );

   mxFree( work   );
   mxFree( spaixd );
   mxFree( spaixi );

   }




/*
   void dskn02_c ( SpiceInt               handle,
                   ConstSpiceDLADescr   * dladsc,
                   SpiceInt               plid,
                   SpiceDouble            normal[3] )
/*/
void cspice_dskn02(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {
   SpiceInt             handle;
   SpiceInt           * dladsc;
   SpiceDLADescr        local_dladsc;
   SpiceInt             plid;
   SpiceDouble        * normal;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle", MiceInt,     0, {0},                0},
      { "dladsc", MiceInt,     1, {SPICE_DLA_DSCSIZ}, 0},
      { "plid",   MiceInt,     0, {0},                0},
      { "normal", MiceDouble,  1, {3},                0}
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle = S_INT_ARGV(1);
   dladsc = A_INT_ARGV(2);

   local_dladsc.bwdptr = dladsc[SPICE_DLA_BWDIDX];
   local_dladsc.fwdptr = dladsc[SPICE_DLA_FWDIDX];
   local_dladsc.ibase  = dladsc[SPICE_DLA_IBSIDX];
   local_dladsc.isize  = dladsc[SPICE_DLA_ISZIDX];
   local_dladsc.dbase  = dladsc[SPICE_DLA_DBSIDX];
   local_dladsc.dsize  = dladsc[SPICE_DLA_DSZIDX];
   local_dladsc.cbase  = dladsc[SPICE_DLA_CBSIDX];
   local_dladsc.csize  = dladsc[SPICE_DLA_CSZIDX];

   plid   = S_INT_ARGV(3);
   normal = A_DBL_RET_ARGV(0);

   dskn02_c ( handle, &local_dladsc, plid, normal );

   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              dskobj_c ( ConstSpiceChar    * dsk,
                                SpiceCell         * bodids );
*/
void cspice_dskobj(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {
   SpiceChar           dsk[DEFAULT_STR_LENGTH+1];
   mxChar            * mx_dsk;

   mwIndex             i;
   SpiceInt            j;
   mwSize              sizearray[2];

   SpiceInt            card = 0;
   SpiceInt            size;
   SpiceInt          * ids_f;
   SpiceInt          * ids;

   struct extra_dims * extra;
   struct argcheck ArgCheck[] =
      {
      { "dskfnm",    MiceChar,   0, {0}, 1},
      { "room",      MiceInt,    0, {0}, 0},
      { "bodids_f",  MiceIgnore, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   size = S_INT_ARGV(2);
   ids  = (SpiceInt*)mxMalloc( (size + SPICE_CELL_CTRLSZ)*sizeof(SpiceInt)  );

   ssizei_( ( integer * ) &size, ( integer * ) ids   );
   scardi_( ( integer * ) &card, ( integer * ) ids   );

   if (extra->count>1)
      {

      mx_dsk = (mxChar *)mxGetChars(prhs[1]);

      for ( i=0; i<extra->count; i++)
         {

         /*
         Extract the string data, character by character, into
         CSPICE strings. The mx_str array stores the data in a column
         major format, we need to extract the data by rows.
         */
         for ( j=0; j<extra->offset[0]; j++)
            {
            dsk[j] = (char)mx_dsk[i + (extra->count*j)];
            }

         dsk[extra->offset[0]] = '\0';

         dskobj_(  ( char       * ) dsk,
                   ( integer    * ) (ids),
                   ( ftnlen       ) strlen(dsk)   );

         /*
         Check for a failure signal. Free the memory assigned to 'ids'
         before signaling a Matlab error.
         */
         if ( failed_c())
            {
            mxFree( ids );

            /*
            The mice_fail call creates the error string then returns control
            to the MATLAB interpreter.
            */
            mice_fail(i);
            }

         }

      }
   else
      {
      mxGetString(prhs[1], dsk, DEFAULT_STR_LENGTH);

      dskobj_(  ( char       * ) dsk,
                ( integer    * ) (ids),
                ( ftnlen       ) strlen(dsk)   );

      /*
      Check for a failure signal. Free the memory assigned to 'ids'
      before signaling a Matlab error.
      */
      if ( failed_c())
         {
         mxFree( ids );

         /*
         The mice_fail call creates the error string then returns control
         to the MATLAB interpreter.
         */
         mice_fail(SCALAR);
         }

      }

   /*
   Array element 6, index 5, contains the cell cardinality. Create an output
   array CARDx1.
   */
   sizearray[0] = ids[5];
   sizearray[1] = 1;

   plhs[0] = mxCreateNumericArray( 2, sizearray, mxINT32_CLASS, mxREAL);
   ids_f   = A_INT_RET_ARGV(0);

   MOVEI( ids + SPICE_CELL_CTRLSZ, ids[5], ids_f );
   mxFree( ids );

   }




/*
   void              dskopn_c ( ConstSpiceChar    * name,
                                ConstSpiceChar    * ifname,
                                SpiceInt            ncomch,
                                SpiceInt          * handle  );
*/
void cspice_dskopn(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            fname [DEFAULT_STR_LENGTH+1];
   SpiceChar            ifname[DEFAULT_STR_LENGTH+1];
   SpiceInt             ncomch;
   SpiceInt           * handle;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "fname",  MiceChar, 0, {0}, 0},
      { "ifname", MiceChar, 0, {0}, 0},
      { "ncomch", MiceInt,  0, {0}, 0},
      { "handle", MiceInt,  0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 3, 1);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], fname,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], ifname, DEFAULT_STR_LENGTH);

   ncomch = S_INT_ARGV(3);
   handle = A_INT_RET_ARGV(0);

   dskopn_c( fname, ifname, ncomch, handle );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void dskp02_c ( SpiceInt               handle,
                   ConstSpiceDLADescr   * dladsc,
                   SpiceInt               start,
                   SpiceInt               room,
                   SpiceInt             * n,
                   SpiceInt               plates[][3] )
*/
void cspice_dskp02(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {
   SpiceInt             handle;
   SpiceDLADescr        local_dladsc;
   SpiceInt           * dladsc;
   SpiceInt             start;
   SpiceInt             room;
   SpiceInt             n;
   SpiceInt          (* plates)[3] = 0;
   SpiceInt           * ivals_ret;

   mwSize               sizearray[2];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle", MiceInt,     0, {0},                0},
      { "dladsc", MiceInt,     1, {SPICE_DLA_DSCSIZ}, 0},
      { "start",  MiceInt,     0, {0},                0},
      { "room",   MiceInt,     0, {0},                0},
      { "plates", MiceIgnore,  0, {0},                0}
      };

   check_arg_num( nrhs, nlhs, 4, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle = S_INT_ARGV(1);
   dladsc = A_INT_ARGV(2);
   /*
   Note that we do NOT subtract one off the start index,
   since "start" is a plate number, and these are
   invariant across all DSK language versions.
   */
   start  = S_INT_ARGV(3);
   room   = S_INT_ARGV(4);

   local_dladsc.bwdptr = dladsc[SPICE_DLA_BWDIDX];
   local_dladsc.fwdptr = dladsc[SPICE_DLA_FWDIDX];
   local_dladsc.ibase  = dladsc[SPICE_DLA_IBSIDX];
   local_dladsc.isize  = dladsc[SPICE_DLA_ISZIDX];
   local_dladsc.dbase  = dladsc[SPICE_DLA_DBSIDX];
   local_dladsc.dsize  = dladsc[SPICE_DLA_DSZIDX];
   local_dladsc.cbase  = dladsc[SPICE_DLA_CBSIDX];
   local_dladsc.csize  = dladsc[SPICE_DLA_CSZIDX];

   sizearray[0] = 3;
   sizearray[1] = room;


   if ( room > 0 )
      {
      plates  = (SpiceInt (*)[3] )mxMalloc(3 * room * sizeof(SpiceInt) );

      dskp02_c ( handle, &local_dladsc, start, room, &n, plates );

      if ( failed_c() )
         {
         mxFree( plates );
         /*
         The mice_fail call creates the error string then returns control
         to the MATLAB interpreter.
         */
         mice_fail(SCALAR);
         }
      }
   else
      {
         n = 0;
      }

   if( n > 0 )
      {
      sizearray[0] = 3;
      sizearray[1] = n;
      }
   else
      {
      sizearray[0] = 0;
      sizearray[1] = 0;
      }

   plhs[0]   = mxCreateNumericArray( 2, sizearray, mxINT32_CLASS, mxREAL);
   ivals_ret = A_INT_RET_ARGV(0);

   if ( n > 0 )
      {
      /*
      Note that n > 0 is possible only if room > 0, so `plates'
      is non-null here.
      */
      MOVEI( (SpiceInt *)plates, 3*n, ivals_ret );
      }

   if ( room > 0 )
      {
      /*
      We allocated space for `room' plates; deallocate this space now.
      */
      mxFree( plates );
      }

   }




/*
 void              dskrb2_c ( SpiceInt              nv,
                              ConstSpiceDouble      vrtces[][3],
                              SpiceInt              np,
                              ConstSpiceInt         plates[][3],
                              SpiceInt              corsys,
                              ConstSpiceDouble      corpar[],
                              SpiceDouble         * mncor3,
                              SpiceDouble         * mxcor3       );
*/
void cspice_dskrb2(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vrtces;
   SpiceInt           * plates;
   SpiceInt             corsys;
   SpiceDouble        * corpar;
   SpiceDouble        * mncor3;
   SpiceDouble        * mxcor3;

   SpiceInt             nv = 0;
   SpiceInt             np = 0;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "vrtces", MiceDouble, 2, {3,0}, 0},
      { "plates", MiceInt,    2, {3,0}, 0},
      { "corsys", MiceInt,    0, {0},   0},
      { "corpar", MiceDouble, 1, {0},   0},
      { "mncor3", MiceDouble, 0, {0},   0},
      { "mxcor3", MiceDouble, 0, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 4, 2 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vrtces  = (SpiceDouble   *)mxGetData(prhs[1]);
   plates  = (SpiceInt      *)mxGetData(prhs[2]);
   corsys  = S_INT_ARGV(3);
   corpar  = (SpiceDouble   *)mxGetData(prhs[4]);

   mncor3 = A_DBL_RET_ARGV(0);
   mxcor3 = A_DBL_RET_ARGV(1);

   nv = mxGetNumberOfElements( prhs[1] )/3;
   np = mxGetNumberOfElements( prhs[2] )/3;

   dskrb2_c ( nv,
              (Nx3d)vrtces,
              np,
              (Nx3i)plates,
              corsys,
              corpar,
              mncor3,
              mxcor3 );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
void              dsksrf_c ( ConstSpiceChar      * dsk,
                             SpiceInt              bodyid,
                             SpiceCell           * srfids );
*/
void cspice_dsksrf(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {
   SpiceChar           dsk[DEFAULT_STR_LENGTH+1];
   mxChar            * mx_dsk;

   mwIndex             i;
   SpiceInt            j;
   mwSize              sizearray[2];

   SpiceInt            card = 0;
   SpiceInt            size;
   SpiceInt            bodyid;
   SpiceInt          * srfids_f;
   SpiceInt          * srfids;

   struct extra_dims * extra;
   struct argcheck ArgCheck[] =
      {
      { "dskfnm", MiceChar,   0, {0}, 1},
      { "bodyid", MiceInt,    0, {0}, 0},
      { "room",   MiceInt,    0, {0}, 0},
      { "srfids", MiceIgnore, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   bodyid = S_INT_ARGV(2);
   size   = S_INT_ARGV(3);

   srfids = (SpiceInt*)
            mxMalloc( (size + SPICE_CELL_CTRLSZ)*sizeof(SpiceInt) );

   ssizei_( ( integer * ) &size, ( integer * ) srfids );
   scardi_( ( integer * ) &card, ( integer * ) srfids );


   if (extra->count>1)
      {

      mx_dsk = (mxChar *)mxGetChars(prhs[1]);

      for ( i=0; i<extra->count; i++)
         {

         /*
         Extract the string data, character by character, into
         CSPICE strings. The mx_str array stores the data in a column
         major format, we need to extract the data by rows.
         */
         for ( j=0; j<extra->offset[0]; j++)
            {
            dsk[j] = (char)mx_dsk[i + (extra->count*j)];
            }

         dsk[extra->offset[0]] = '\0';

         dsksrf_( ( char       * ) dsk,
                  ( integer    * ) &bodyid,
                  ( integer    * ) (srfids),
                  ( ftnlen       ) strlen(dsk)   );

         /*
         Check for a failure signal. Free the memory assigned to 'srfids'
         before signaling a Matlab error.
         */
         if ( failed_c())
            {
            mxFree( srfids );

            /*
            The mice_fail call creates the error string then returns control
            to the MATLAB interpreter.
            */
            mice_fail(i);
            }

         }

      }
   else
      {
      mxGetString(prhs[1], dsk, DEFAULT_STR_LENGTH);

      dsksrf_(  ( char       * ) dsk,
                ( integer    * ) &bodyid,
                ( integer    * ) (srfids),
                ( ftnlen       ) strlen(dsk)   );

      /*
      Check for a failure signal. Free the memory assigned to 'srfids'
      before signaling a Matlab error.
      */
      if ( failed_c())
         {
         mxFree( srfids );

         /*
         The mice_fail call creates the error string then returns control
         to the MATLAB interpreter.
         */
         mice_fail(SCALAR);
         }

      }

   /*
   Array element 6, index 5, contains the cell cardinality. Create an output
   array CARDx1.
   */
   sizearray[0] = srfids[5];
   sizearray[1] = 1;

   plhs[0] = mxCreateNumericArray( 2, sizearray, mxINT32_CLASS, mxREAL);
   srfids_f = A_INT_RET_ARGV(0);

   MOVEI( srfids + SPICE_CELL_CTRLSZ, srfids[5], srfids_f );
   mxFree( srfids );

   }




/*
   void              dskstl_c ( SpiceInt        keywrd,
                                SpiceDouble     dpval  )
*/
void cspice_dskstl(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             keywrd;
   SpiceDouble          dpval;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "keywrd", MiceInt,    0, {0}, 0},
      { "dpval",  MiceDouble, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 2, 0 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   keywrd = S_INT_ARGV(1);
   dpval  = S_DBL_ARGV(2);

   (void) dskstl_c ( keywrd, dpval );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*

   void dskv02_c ( SpiceInt               handle,
                   ConstSpiceDLADescr   * dladsc,
                   SpiceInt               start,
                   SpiceInt               room,
                   SpiceInt             * n,
                   SpiceDouble            vrtces[][3] )

*/
void cspice_dskv02(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {
   SpiceInt             handle;
   SpiceDLADescr        local_dladsc;
   SpiceInt           * dladsc;
   SpiceInt             start;
   SpiceInt             room;
   SpiceInt             n;
   SpiceDouble       (* vrtces)[3] = 0;
   SpiceDouble        * dvals_ret;

   mwSize               sizearray[2];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle", MiceInt,     0, {0},                0},
      { "dladsc", MiceInt,     1, {SPICE_DLA_DSCSIZ}, 0},
      { "start",  MiceInt,     0, {0},                0},
      { "room",   MiceInt,     0, {0},                0},
      { "vrtces", MiceIgnore,  0, {0},                0}
      };

   check_arg_num( nrhs, nlhs, 4, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle = S_INT_ARGV(1);
   dladsc = A_INT_ARGV(2);
   /*
   Note that we do NOT subtract one off the start index,
   since "start" is a vertex number, and these are
   invariant across all DSK language versions.
   */
   start  = S_INT_ARGV(3);
   room   = S_INT_ARGV(4);

   local_dladsc.bwdptr = dladsc[SPICE_DLA_BWDIDX];
   local_dladsc.fwdptr = dladsc[SPICE_DLA_FWDIDX];
   local_dladsc.ibase  = dladsc[SPICE_DLA_IBSIDX];
   local_dladsc.isize  = dladsc[SPICE_DLA_ISZIDX];
   local_dladsc.dbase  = dladsc[SPICE_DLA_DBSIDX];
   local_dladsc.dsize  = dladsc[SPICE_DLA_DSZIDX];
   local_dladsc.cbase  = dladsc[SPICE_DLA_CBSIDX];
   local_dladsc.csize  = dladsc[SPICE_DLA_CSZIDX];

   sizearray[0] = 3;
   sizearray[1] = room;

   if ( room > 0 )
      {
      vrtces  = (SpiceDouble (*)[3] )mxMalloc(3 * room * sizeof(SpiceDouble) );

      dskv02_c ( handle, &local_dladsc, start, room, &n, vrtces );

      if ( failed_c() )
         {
         mxFree( vrtces );
         /*
         The mice_fail call creates the error string then returns control
         to the MATLAB interpreter.
         */
         mice_fail(SCALAR);
         }
      }
   else
      {
         n = 0;
      }

   if( n > 0 )
      {
      sizearray[0] = 3;
      sizearray[1] = n;
      }
   else
      {
      sizearray[0] = 0;
      sizearray[1] = 0;
      }

   plhs[0]   = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
   dvals_ret = A_DBL_RET_ARGV(0);

   if ( n > 0 )
      {
      /*
      Note that n > 0 is possible only if room > 0, so vrtces is non-null here.
      */
      MOVED( (SpiceDouble *)vrtces, 3*n, dvals_ret );
      }

   if ( room > 0 )
      {
      /*
      We allocated space for `room' vertices; deallocate this space now.
      */
      mxFree( vrtces );
      }

   }




/*
   void              dskw02_c ( SpiceInt             handle,
                                SpiceInt             center,
                                SpiceInt             surfid,
                                SpiceInt             dclass,
                                ConstSpiceChar     * frame,
                                SpiceInt             corsys,
                                ConstSpiceDouble     corpar[],
                                SpiceDouble          mncor1,
                                SpiceDouble          mxcor1,
                                SpiceDouble          mncor2,
                                SpiceDouble          mxcor2,
                                SpiceDouble          mncor3,
                                SpiceDouble          mxcor3,
                                SpiceDouble          first,
                                SpiceDouble          last,
                                SpiceInt             nv,
                                ConstSpiceDouble     vrtces[][3],
                                SpiceInt             np,
                                ConstSpiceInt        plates[][3],
                                ConstSpiceDouble     spaixd[],
                                ConstSpiceInt        spaixi[]      )
*/
void cspice_dskw02(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             handle;
   SpiceInt             center;
   SpiceInt             surfid;
   SpiceInt             dclass;
   SpiceChar            frame   [DEFAULT_STR_LENGTH+1];
   SpiceInt             corsys;
   SpiceDouble          mncor1;
   SpiceDouble          mxcor1;
   SpiceDouble          mncor2;
   SpiceDouble          mxcor2;
   SpiceDouble          mncor3;
   SpiceDouble          mxcor3;
   SpiceDouble          first;
   SpiceDouble          last;

   ConstSpiceDouble   * corpar;
   ConstSpiceDouble   * vrtces;
   ConstSpiceInt      * plates;
   ConstSpiceDouble   * spaixd;
   ConstSpiceInt      * spaixi;

   SpiceInt             nv = 0;
   SpiceInt             np = 0;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle",  MiceInt,     0, { 0 },    0},
      { "center",  MiceInt,     0, { 0 },    0},
      { "surfid",  MiceInt,     0, { 0 },    0},
      { "dclass",  MiceInt,     0, { 0 },    0},
      { "frame",   MiceChar,    0, { 0 },    0},
      { "corsys",  MiceInt,     0, { 0 },    0},
      { "corpar",  MiceDouble,  1, { 0 },    0},
      { "mncor1",  MiceDouble,  0, { 0 },    0},
      { "mxcor1",  MiceDouble,  0, { 0 },    0},
      { "mncor2",  MiceDouble,  0, { 0 },    0},
      { "mxcor2",  MiceDouble,  0, { 0 },    0},
      { "mncor3",  MiceDouble,  0, { 0 },    0},
      { "mxcor3",  MiceDouble,  0, { 0 },    0},
      { "first",   MiceDouble,  0, { 0 },    0},
      { "last",    MiceDouble,  0, { 0 },    0},
      { "vrtces",  MiceDouble,  2, { 3, 0 }, 0},
      { "plates",  MiceInt,     2, { 3, 0 }, 0},
      { "spaixd",  MiceDouble,  1, { 0 },    0},
      { "spaixi",  MiceInt,     1, { 0 },    0},
      };

   check_arg_num( nrhs, nlhs, 19, 0 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle = S_INT_ARGV(1);
   center = S_INT_ARGV(2);
   surfid = S_INT_ARGV(3);
   dclass = S_INT_ARGV(4);
   corsys = S_INT_ARGV(6);

   mncor1 = S_DBL_ARGV(8);
   mxcor1 = S_DBL_ARGV(9);
   mncor2 = S_DBL_ARGV(10);
   mxcor2 = S_DBL_ARGV(11);
   mncor3 = S_DBL_ARGV(12);
   mxcor3 = S_DBL_ARGV(13);
   first  = S_DBL_ARGV(14);
   last   = S_DBL_ARGV(15);

   corpar  = (ConstSpiceDouble   *)mxGetData(prhs[7]);
   vrtces  = (ConstSpiceDouble   *)mxGetData(prhs[16]);
   plates  = (ConstSpiceInt      *)mxGetData(prhs[17]);
   spaixd  = (ConstSpiceDouble   *)mxGetData(prhs[18]);
   spaixi  = (ConstSpiceInt      *)mxGetData(prhs[19]);

   mxGetString(prhs[5], frame, DEFAULT_STR_LENGTH);

   nv = mxGetNumberOfElements( prhs[16] )/3;
   np = mxGetNumberOfElements( prhs[17] )/3;


   dskw02_c ( handle,
              center,
              surfid,
              dclass,
              frame,
              corsys,
              corpar,
              mncor1,
              mxcor1,
              mncor2,
              mxcor2,
              mncor3,
              mxcor3,
              first,
              last,
              nv,
              (Nx3d)vrtces,
              np,
              (Nx3i)plates,
              spaixd,
              spaixi );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              dskx02_c ( SpiceInt               handle,
                                ConstSpiceDLADescr   * dladsc,
                                ConstSpiceDouble       vertex  [3],
                                ConstSpiceDouble       raydir  [3],
                                SpiceInt             * plid,
                                SpiceDouble            xpt     [3],
                                SpiceBoolean         * found        );
*/
void cspice_dskx02(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             handle;
   SpiceDLADescr        local_dladsc;
   SpiceInt           * dladsc;
   SpiceDouble        * vertex;
   SpiceDouble        * raydir;
   SpiceInt           * plid;
   SpiceDouble        * xpt;
   SpiceBoolean       * found;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle", MiceInt,     0, {0},                0},
      { "dladsc", MiceInt,     1, {SPICE_DLA_DSCSIZ}, 0},
      { "vertex", MiceDouble,  1, {3},                0},
      { "raydir", MiceDouble,  1, {3},                0},
      { "plid",   MiceInt,     0, {0},                0},
      { "xpt",    MiceDouble,  1, {3},                0},
      { "found",  MiceBoolean, 0, {0},                0},
      };

   check_arg_num( nrhs, nlhs, 4, 3 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle = S_INT_ARGV(1);
   dladsc = A_INT_ARGV(2);
   vertex = A_DBL_ARGV(3);
   raydir = A_DBL_ARGV(4);

   plid   = A_INT_RET_ARGV(0);
   xpt    = A_DBL_RET_ARGV(1);
   found  = A_BOOL_RET_ARGV(2);

   local_dladsc.bwdptr = dladsc[SPICE_DLA_BWDIDX];
   local_dladsc.fwdptr = dladsc[SPICE_DLA_FWDIDX];
   local_dladsc.ibase  = dladsc[SPICE_DLA_IBSIDX];
   local_dladsc.isize  = dladsc[SPICE_DLA_ISZIDX];
   local_dladsc.dbase  = dladsc[SPICE_DLA_DBSIDX];
   local_dladsc.dsize  = dladsc[SPICE_DLA_DSZIDX];
   local_dladsc.cbase  = dladsc[SPICE_DLA_CBSIDX];
   local_dladsc.csize  = dladsc[SPICE_DLA_CSZIDX];

   dskx02_c ( handle, &local_dladsc, vertex, raydir,
              plid, xpt, found );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              dskxsi_c ( SpiceBoolean           pri,
                                ConstSpiceChar       * target,
                                SpiceInt               nsurf,
                                ConstSpiceInt          srflst [],
                                SpiceDouble            et,
                                ConstSpiceChar       * fixref,
                                ConstSpiceDouble       vertex [3],
                                ConstSpiceDouble       raydir [3],
                                SpiceInt               maxd,
                                SpiceInt               maxi,
                                SpiceDouble            xpt    [3],
                                SpiceInt             * handle,
                                SpiceDLADescr        * dladsc,
                                SpiceDSKDescr        * dskdsc,
                                SpiceDouble            dc     [],
                                SpiceInt               ic     [],
                                SpiceBoolean         * found      );
*/
void cspice_dskxsi(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceBoolean           pri;
   SpiceChar              target [DEFAULT_STR_LENGTH+1];
   SpiceInt               nsurf;
   SpiceInt             * srflst;
   SpiceDouble            et;
   SpiceChar              fixref [DEFAULT_STR_LENGTH+1];
   SpiceDouble          * vertex;
   SpiceDouble          * raydir;
   SpiceInt               maxd;
   SpiceInt               maxi;
   SpiceDouble          * xpt;
   SpiceInt             * handle;
   SpiceInt             * dladsc;
   SpiceDouble          * dskdsc;
   SpiceDouble            dc     [SPICE_DSKXSI_DCSIZE];
   SpiceInt               ic     [SPICE_DSKXSI_ICSIZE];
   SpiceBoolean           found;

   SpiceDouble          * dvals_ret;
   SpiceInt             * ivals_ret;

   mwSize                 sizearray[2];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "pri",     MiceInt,     0, {0},                0},
      { "target",  MiceChar,    0, {0},                0},
      { "nsurf",   MiceInt,     0, {0},                0},
      { "srflst",  MiceInt,     1, {0},                0},
      { "et",      MiceDouble,  0, {0},                0},
      { "fixref",  MiceChar,    0, {0},                0},
      { "vertex",  MiceDouble,  1, {3},                0},
      { "raydir",  MiceDouble,  1, {3},                0},
      { "xpt",     MiceDouble,  1, {3},                0},
      { "handle",  MiceInt,     0, {0},                0},
      { "dladsc",  MiceInt,     1, {SPICE_DLA_DSCSIZ}, 0},
      { "dskdsc",  MiceDouble,  1, {SPICE_DSK_DSCSIZ}, 0},
      { "dc",      MiceIgnore,  1, {0},                0},
      { "ic",      MiceIgnore,  1, {0},                0},
      { "found",   MiceIgnore,  0, {0},                0},
      };

   check_arg_num( nrhs, nlhs, 8, 7 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   maxd = SPICE_DSKXSI_DCSIZE;
   maxi = SPICE_DSKXSI_ICSIZE;

   pri = *(SpiceBoolean*)mxGetData(prhs[1]);

   mxGetString(prhs[2], target, DEFAULT_STR_LENGTH);

   nsurf  = S_INT_ARGV(3);
   srflst = (SpiceInt*)mxGetData(prhs[4]);
   et     = S_DBL_ARGV(5);

   mxGetString(prhs[6], fixref, DEFAULT_STR_LENGTH);

   vertex = A_DBL_ARGV(7);
   raydir = A_DBL_ARGV(8);

   xpt    = A_DBL_RET_ARGV(0);
   handle = A_INT_RET_ARGV(1);
   dladsc = A_INT_RET_ARGV(2);
   dskdsc = A_DBL_RET_ARGV(3);

   dskxsi_ ( (logical     *) &pri,
             (char        *) target,
             (integer     *) &nsurf,
             (integer     *) srflst,
             (doublereal  *) &et,
             (char        *) fixref,
             (doublereal  *) vertex,
             (doublereal  *) raydir,
             (integer     *) &maxd,
             (integer     *) &maxi,
             (doublereal  *) xpt,
             (integer     *) handle,
             (integer     *) dladsc,
             (doublereal  *) dskdsc,
             (doublereal  *) dc,
             (integer     *) ic,
             (logical     *) &found,
             (ftnlen       ) strlen(target),
             (ftnlen       ) strlen(fixref)  );
   CHECK_CALL_FAILURE(SCALAR);

   /*
   Define the size and shape of the Matlab return argument. The
   number of elements should not exceed MAXNDC. Enforce with the
   conditional operator.
   */
   sizearray[0] = 1;
   sizearray[1] = SPICE_DSKXSI_DCSIZE;

   plhs[4]   = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
   dvals_ret = A_DBL_RET_ARGV(4);

   MOVED( dc, SPICE_DSKXSI_DCSIZE, dvals_ret );

   /*
   Define the size and shape of the Matlab return argument. The
   number of elements should not exceed MAXNIC. Enforce with the
   conditional operator.
   */
   sizearray[0] = 1;
   sizearray[1] = SPICE_DSKXSI_ICSIZE;

   plhs[5]   = mxCreateNumericArray( 2, sizearray, mxINT32_CLASS, mxREAL);
   ivals_ret = A_INT_RET_ARGV(5);

   MOVEI( ic, SPICE_DSKXSI_ICSIZE, ivals_ret );

   plhs[6] = zzmice_CreateIntScalar( found );

   }




/*
   void               dskxv_c ( SpiceBoolean           pri,
                                ConstSpiceChar       * target,
                                SpiceInt               nsurf,
                                ConstSpiceInt          srflst[],
                                SpiceDouble            et,
                                ConstSpiceChar       * fixref,
                                SpiceInt               nrays,
                                ConstSpiceDouble       vtxarr[][3],
                                ConstSpiceDouble       dirarr[][3],
                                SpiceDouble            xptarr[][3],
                                SpiceBoolean           fndarr[]     );
*/
void cspice_dskxv(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceBoolean           pri;
   SpiceChar              target [DEFAULT_STR_LENGTH+1];
   SpiceInt               nsurf;
   SpiceInt             * srflst;
   SpiceDouble            et;
   SpiceChar              fixref [DEFAULT_STR_LENGTH+1];
   ConstSpiceDouble     * vtxarr;
   ConstSpiceDouble     * dirarr;
   SpiceDouble         (* xptarr)[3] = 0;
   SpiceBoolean         * fndarr;

   SpiceDouble          * dvals_ret;
   SpiceBoolean         * bools_ret;

   SpiceInt               nrays;
   SpiceInt               nd;
   SpiceInt               nv;
   mwSize                 sizearray[2];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "pri",     MiceInt,     0, {0},   0},
      { "target",  MiceChar,    0, {0},   0},
      { "nsurf",   MiceInt,     0, {0},   0},
      { "srflst",  MiceInt,     1, {0},   0},
      { "et",      MiceDouble,  0, {0},   0},
      { "fixref",  MiceChar,    0, {0},   0},
      { "vtxarr",  MiceDouble,  2, {3,0}, 0},
      { "dirarr",  MiceDouble,  2, {3,0}, 0},
      { "xptarr",  MiceIgnore,  0, {0},   0},
      { "fndarr",  MiceIgnore,  0, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 8, 2 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   pri    = *(SpiceBoolean*)mxGetData(prhs[1]);

   mxGetString(prhs[2], target, DEFAULT_STR_LENGTH);

   nsurf  = S_INT_ARGV(3);
   srflst = (SpiceInt*)mxGetData(prhs[4]);
   et     = S_DBL_ARGV(5);

   mxGetString(prhs[6], fixref, DEFAULT_STR_LENGTH);

   vtxarr = (ConstSpiceDouble   *)mxGetData(prhs[7]);
   dirarr = (ConstSpiceDouble   *)mxGetData(prhs[8]);

   nv = (SpiceInt)mxGetNumberOfElements( prhs[7] )/3;
   nd = (SpiceInt)mxGetNumberOfElements( prhs[8] )/3;

   if( nv != nd )
      {
      mexErrMsgTxt( "MICE(INVALIDSIZE): Matrix `dirarr` must have the same "
                            "size and shape as `vtxarr`." );
      }

   nrays = nv;

   xptarr  = (SpiceDouble (*)[3] )mxMalloc(3 * nrays * sizeof(SpiceDouble)  );
   fndarr  = (SpiceBoolean*)      mxMalloc(    nrays * sizeof(SpiceBoolean) );

    dskxv_c ( pri,    target,  nsurf,  srflst,
              et,     fixref,  nrays,  vtxarr,
              dirarr, xptarr,  fndarr         );

   if ( failed_c() )
      {
      mxFree( xptarr );
      mxFree( fndarr );

      /*
      The mice_fail call creates the error string then returns control
      to the MATLAB interpreter.
      */
      mice_fail(SCALAR);
      }

   sizearray[0] = 3;
   sizearray[1] = nrays;

   plhs[0]   = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
   dvals_ret = A_DBL_RET_ARGV(0);

   MOVED( xptarr, 3*nrays, dvals_ret );

   sizearray[0] = 1;
   sizearray[1] = nrays;

   plhs[1]   = mxCreateNumericArray( 2, sizearray, mxINT32_CLASS, mxREAL);
   bools_ret = A_BOOL_RET_ARGV(1);

   MOVEI( fndarr, nrays, bools_ret );

   mxFree( xptarr );
   mxFree( fndarr );

   CHECK_CALL_FAILURE(SCALAR);
   }




/*

   void dskz02_c ( SpiceInt               handle,
                   ConstSpiceDLADescr   * dladsc,
                   SpiceInt             * nv,
                   SpiceInt             * np     )

*/
void cspice_dskz02(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {
   SpiceInt             handle;
   SpiceDLADescr        local_dladsc;
   SpiceInt           * dladsc;
   SpiceInt           * nv;
   SpiceInt           * np;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle", MiceInt,     0, {0},                0},
      { "dladsc", MiceInt,     1, {SPICE_DLA_DSCSIZ}, 0},
      { "nv",     MiceInt,     0, {0},                0},
      { "np",     MiceInt,     0, {0},                0},
      };

   check_arg_num( nrhs, nlhs, 2, 2 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle = S_INT_ARGV(1);
   dladsc = A_INT_ARGV(2);

   local_dladsc.bwdptr = dladsc[SPICE_DLA_BWDIDX];
   local_dladsc.fwdptr = dladsc[SPICE_DLA_FWDIDX];
   local_dladsc.ibase  = dladsc[SPICE_DLA_IBSIDX];
   local_dladsc.isize  = dladsc[SPICE_DLA_ISZIDX];
   local_dladsc.dbase  = dladsc[SPICE_DLA_DBSIDX];
   local_dladsc.dsize  = dladsc[SPICE_DLA_DSZIDX];
   local_dladsc.cbase  = dladsc[SPICE_DLA_CBSIDX];
   local_dladsc.csize  = dladsc[SPICE_DLA_CSZIDX];

   nv     = A_INT_RET_ARGV(0);
   np     = A_INT_RET_ARGV(1);

   dskz02_c ( handle, &local_dladsc, nv, np );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              dsphdr_c ( SpiceDouble         x,
                                SpiceDouble         y,
                                SpiceDouble         z,
                                SpiceDouble         jacobi[3][3] );
*/
void cspice_dsphdr(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_x;
   SpiceDouble        * vec_y;
   SpiceDouble        * vec_z;
   SpiceDouble        * vec_jacobi;
   SpiceDouble          x;
   SpiceDouble          y;
   SpiceDouble          z;
   SpiceDouble        * jacobi;
   SpiceDouble          xr[3][3];

   mwIndex              i;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "x",      MiceDouble, 0, {0},    1},
      { "y",      MiceDouble, 0, {0},    1},
      { "z",      MiceDouble, 0, {0},    1},
      { "jacobi", MiceDouble, 2, {3, 3}, 1},
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_x      = A_DBL_ARGV(1);
   vec_y      = A_DBL_ARGV(2);
   vec_z      = A_DBL_ARGV(3);
   x          = *vec_x;
   y          = *vec_y;
   z          = *vec_z;
   vec_jacobi = A_DBL_RET_ARGV(0);
   jacobi     = vec_jacobi;

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         x   = *(vec_x + i*extra->offset[0]);
         y   = *(vec_y + i*extra->offset[1]);
         z   = *(vec_z + i*extra->offset[2]);
         jacobi = (vec_jacobi + i*extra->offset[3]);

         dsphdr_c(x, y, z, (SpiceDouble(*)[3])xr);
         CHECK_CALL_FAILURE(i);

         xpose_c( xr, (SpiceDouble(*)[3])jacobi );
         }

      }
   else
      {
      dsphdr_c(x, y, z, (SpiceDouble(*)[3])xr);
      CHECK_CALL_FAILURE(SCALAR);

      xpose_c( xr, (SpiceDouble(*)[3])jacobi );
      }

   }




/*
   void              dtpool_c ( ConstSpiceChar      * name,
                                SpiceBoolean        * found,
                                SpiceInt            * n,
                                SpiceChar             type [1] )
*/
void mice_dtpool(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar               name[DEFAULT_STR_LENGTH+1];
   mxChar                * mx_name;
   SpiceBoolean            found;
   SpiceInt                n;
   SpiceDouble             xn;
   SpiceChar               type;
   SpiceChar               type_buf[2];

   mwIndex              i;
   SpiceInt             j;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "name",  MiceChar, 0, { 0 }, 1},
      { "value", MicePool, 0, { 0 }, 1},
      };

   /* Check the input contains the correct number of arguments. */
   check_arg_num( nrhs, nlhs, 1, 1 );

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   if (extra->count>1)
      {
      mx_name = (mxChar *)mxGetChars(prhs[1]);

      for (i=0;i<extra->count;i++)
         {

         /*
         Extract the string data, character by character, into
         CSPICE strings. The mx_name array stores the data in a column
         major format, we need to extract the data by rows.
         */
         for ( j=0; j<extra->offset[0]; j++)
            {
            name[j] = (SpiceChar)mx_name[i + (extra->count*j)];
            }

         name[extra->offset[0]] = '\0';

         dtpool_c( name, &found, &n, &type);
         CHECK_CALL_FAILURE(i);

         /* We return a string to MATLAB, so copy the char to a string. */
         type_buf[0] = type;
         type_buf[1] = '\0';

         /*
         Cast the number of found items to a double value.
         */
         xn = (SpiceDouble) n;

         mxDestroyArray( mxGetField( plhs[0], i, "type" ) );
         mxSetField( plhs[0], i, "type", mxCreateString(type_buf)  );

         mxDestroyArray( mxGetField( plhs[0], i, "n" ) );
         mxSetField( plhs[0], i, "n", mxCreateDoubleScalar(xn) );

         mxDestroyArray( mxGetField( plhs[0], i, "found" ) );
         mxSetField( plhs[0], i, "found",
                     mxCreateLogicalScalar(found ? true: false));
         }

      }
   else
      {
      mxGetString(prhs[1], name, DEFAULT_STR_LENGTH);

      dtpool_c( name, &found, &n, &type);
      CHECK_CALL_FAILURE( SCALAR );

      /* We return a string to MATLAB, so copy the char to a string. */
      type_buf[0] = type;
      type_buf[1] = '\0';

      /*
      Cast the number of found items to a double value.
      */
      xn = (SpiceDouble) n;

      mxDestroyArray( mxGetField( plhs[0], 0, "type" ) );
      mxSetField( plhs[0], 0, "type", mxCreateString(type_buf) );

      mxDestroyArray( mxGetField( plhs[0], 0, "n" ) );
      mxSetField( plhs[0], 0, "n", mxCreateDoubleScalar(xn) );

      mxDestroyArray( mxGetField( plhs[0], 0, "found" ) );
      mxSetField( plhs[0], 0, "found",
                  mxCreateLogicalScalar(found ? true: false));
      }

   }




/*
   void              ducrss_c ( ConstSpiceDouble s1  [6],
                                ConstSpiceDouble s2  [6],
                                SpiceDouble      sout[6] )
*/
void cspice_ducrss(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_s1;
   SpiceDouble        * vec_s2;
   SpiceDouble        * vec_vout;
   SpiceDouble        * s1;
   SpiceDouble        * s2;
   SpiceDouble        * vout;

   mwIndex              i;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "s1",   MiceDouble, 1, {6}, 1},
      { "s2",   MiceDouble, 1, {6}, 1},
      { "sout", MiceDouble, 1, {6}, 1},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_s1   = A_DBL_ARGV(1);
   vec_s2   = A_DBL_ARGV(2);
   vec_vout = A_DBL_RET_ARGV(0);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         s1   = (vec_s1   + i*extra->offset[0]);
         s2   = (vec_s2   + i*extra->offset[1]);
         vout = (vec_vout + i*extra->offset[2]);

         ducrss_c(s1, s2, vout);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {
      s1   = vec_s1;
      s2   = vec_s2;
      vout = vec_vout;

      ducrss_c(s1, s2, vout);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void              dvcrss_c ( ConstSpiceDouble s1  [6],
                                ConstSpiceDouble s2  [6],
                                SpiceDouble      sout[6] )
*/
void cspice_dvcrss(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_s1;
   SpiceDouble        * vec_s2;
   SpiceDouble        * vec_vout;
   SpiceDouble        * s1;
   SpiceDouble        * s2;
   SpiceDouble        * vout;

   mwIndex              i;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "s1",   MiceDouble, 1, {6}, 1},
      { "s2",   MiceDouble, 1, {6}, 1},
      { "sout", MiceDouble, 1, {6}, 1},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_s1   = A_DBL_ARGV(1);
   vec_s2   = A_DBL_ARGV(2);
   vec_vout = A_DBL_RET_ARGV(0);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         s1   = (vec_s1   + i*extra->offset[0]);
         s2   = (vec_s2   + i*extra->offset[1]);
         vout = (vec_vout + i*extra->offset[2]);

         dvcrss_c(s1, s2, vout);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {
      s1   = vec_s1;
      s2   = vec_s2;
      vout = vec_vout;

      dvcrss_c(s1, s2, vout);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   SpiceDouble       dvdot_c  ( ConstSpiceDouble      s1[6],
                                ConstSpiceDouble      s2[6] )
*/
void cspice_dvdot(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_s1;
   SpiceDouble        * vec_s2;
   SpiceDouble        * s1;
   SpiceDouble        * s2;
   SpiceDouble        * retval;
   SpiceDouble        * vec_retval;

   mwIndex              i;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "s1",    MiceDouble, 1, {6}, 1},
      { "s2",    MiceDouble, 1, {6}, 1},
      { "dvdot", MiceDouble, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_s1     = A_DBL_ARGV(1);
   vec_s2     = A_DBL_ARGV(2);
   vec_retval = A_DBL_RET_ARGV(0);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         s1     = (vec_s1     + i*extra->offset[0]);
         s2     = (vec_s2     + i*extra->offset[1]);
         retval = (vec_retval + i*extra->offset[2]);

         *retval = dvdot_c(s1, s2);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {
      s1     = vec_s1;
      s2     = vec_s2;
      retval = vec_retval;

      *retval = dvdot_c(s1, s2);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void              dvhat_c  ( ConstSpiceDouble      s1  [6],
                                SpiceDouble           sout[6] )
*/
void cspice_dvhat(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_s1;
   SpiceDouble        * vec_vout;
   SpiceDouble        * s1;
   SpiceDouble        * vout;

   mwIndex              i;

   struct extra_dims  * extra;

   struct argcheck ArgCheck[] =
      {
      { "s1",   MiceDouble, 1, {6}, 1},
      { "sout", MiceDouble, 1, {6}, 1},
      };

   check_arg_num( nrhs, nlhs, 1, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_s1   = A_DBL_ARGV(1);
   vec_vout = A_DBL_RET_ARGV(0);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         s1   =  (vec_s1   + i*extra->offset[0]);
         vout =  (vec_vout + i*extra->offset[1]);

         dvhat_c(s1, vout);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {

      s1   =  vec_s1;
      vout =  vec_vout;

      dvhat_c( s1, vout);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   SpiceDouble       dvnorm_c ( ConstSpiceDouble     state[6] )
*/
void cspice_dvnorm(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_s1;
   SpiceDouble        * s1;
   SpiceDouble        * vec_retval;
   SpiceDouble        * retval;

   mwIndex              i;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "state",  MiceDouble, 1, {6}, 1},
      { "dvnorm", MiceDouble, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 1, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_s1     = A_DBL_ARGV(1);
   vec_retval = A_DBL_RET_ARGV(0);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         s1     = (vec_s1     + i*extra->offset[0]);
         retval = (vec_retval + i*extra->offset[1]);

         *retval = dvnorm_c( s1 );
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {
      s1     = vec_s1;
      retval = vec_retval;

      *retval = dvnorm_c( s1 );
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void              dvpool_c ( ConstSpiceChar      * name );
*/
void cspice_dvpool(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar           name[DEFAULT_STR_LENGTH+1];
   mxChar            * mx_name;

   mwIndex             i;
   SpiceInt            j;

   struct extra_dims * extra;
   struct argcheck ArgCheck[] =
      {
      { "name", MiceChar, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 1, 0 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   if (extra->count>1)
      {

      mx_name = (mxChar *)mxGetChars(prhs[1]);

      for ( i=0; i<extra->count; i++)
         {

         /*
         Extract the string data, character by character, into
         CSPICE strings. The 'mx_name' array stores the data in a column
         major format, we need to extract the data by rows.
         */
         for ( j=0; j<extra->offset[0]; j++)
            {
            name[j] = (char)mx_name[i + (extra->count*j)];
            }

         name[extra->offset[0]] = '\0';

         dvpool_c(name);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {
      mxGetString(prhs[1], name, DEFAULT_STR_LENGTH);

      dvpool_c(name);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   SpiceDouble      dvsep_c   ( ConstSpiceDouble    s1[6],
                                ConstSpiceDouble    s2[6] )
*/
void cspice_dvsep(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_s1;
   SpiceDouble        * vec_s2;
   SpiceDouble        * s1;
   SpiceDouble        * s2;
   SpiceDouble        * retval;
   SpiceDouble        * vec_retval;

   mwIndex              i;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "s1",    MiceDouble, 1, {6}, 1},
      { "s2",    MiceDouble, 1, {6}, 1},
      { "dvsep", MiceDouble, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_s1     = A_DBL_ARGV(1);
   vec_s2     = A_DBL_ARGV(2);
   vec_retval = A_DBL_RET_ARGV(0);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         s1     = (vec_s1     + i*extra->offset[0]);
         s2     = (vec_s2     + i*extra->offset[1]);
         retval = (vec_retval + i*extra->offset[2]);

         *retval = dvsep_c(s1, s2);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {
      s1     = vec_s1;
      s2     = vec_s2;
      retval = vec_retval;

      *retval = dvsep_c(s1, s2);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void              edlimb_c ( SpiceDouble           a,
                                SpiceDouble           b,
                                SpiceDouble           c,
                                ConstSpiceDouble      viewpt[3],
                                SpiceEllipse        * limb      );
*/
void mice_edlimb(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble          a;
   SpiceDouble          b;
   SpiceDouble          c;
   SpiceDouble        * viewpt;
   SpiceEllipse         limb;


   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "a",      MiceDouble,  0, {0}, 0},
      { "b",      MiceDouble,  0, {0}, 0},
      { "c",      MiceDouble,  0, {0}, 0},
      { "viewpt", MiceDouble,  1, {3}, 0},
      { "limb",   MiceEllipse, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 4, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   a      = S_DBL_ARGV(1);
   b      = S_DBL_ARGV(2);
   c      = S_DBL_ARGV(3);
   viewpt = A_DBL_ARGV(4);

   edlimb_c ( a, b, c, viewpt, &limb );
   CHECK_CALL_FAILURE(SCALAR);

   memcpy( mxGetPr( mxGetField( plhs[0], 0,"center") ),
           limb.center,
           3*sizeof(SpiceDouble)
         );

   memcpy( mxGetPr( mxGetField( plhs[0], 0,"semiMajor") ),
           limb.semiMajor,
           3*sizeof(SpiceDouble)
         );

   memcpy( mxGetPr( mxGetField( plhs[0], 0,"semiMinor") ),
           limb.semiMinor,
           3*sizeof(SpiceDouble)
         );

   }




/*
   void ednmpt_c ( SpiceDouble         a,
                   SpiceDouble         b,
                   SpiceDouble         c,
                   ConstSpiceDouble    normal [3],
                   SpiceDouble         point  [3] )
*/
void cspice_ednmpt(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble          a;
   SpiceDouble          b;
   SpiceDouble          c;
   SpiceDouble        * normal;
   SpiceDouble        * point;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "a",       MiceDouble,   0, {0},   0},
      { "b",       MiceDouble,   0, {0},   0},
      { "c",       MiceDouble,   0, {0},   0},
      { "normal",  MiceDouble,   1, {3},   0},
      { "point",   MiceDouble,   1, {3},   0},
      };

   check_arg_num( nrhs, nlhs, 4, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   a        = S_DBL_ARGV(1);
   b        = S_DBL_ARGV(2);
   c        = S_DBL_ARGV(3);
   normal   = A_DBL_ARGV(4);

   point    = A_DBL_RET_ARGV(0);

   ednmpt_c ( a, b, c, normal, point );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void edpnt_c  ( ConstSpiceDouble    p      [3],
                   SpiceDouble         a,
                   SpiceDouble         b,
                   SpiceDouble         c,
                   SpiceDouble         ep     [3] )
*/
void cspice_edpnt(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * p;
   SpiceDouble          a;
   SpiceDouble          b;
   SpiceDouble          c;
   SpiceDouble        * ep;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "p",       MiceDouble,   1, {3},   0},
      { "a",       MiceDouble,   0, {0},   0},
      { "b",       MiceDouble,   0, {0},   0},
      { "c",       MiceDouble,   0, {0},   0},
      { "ep",      MiceDouble,   1, {3},   0},
      };

   check_arg_num( nrhs, nlhs, 4, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   p        = A_DBL_ARGV(1);
   a        = S_DBL_ARGV(2);
   b        = S_DBL_ARGV(3);
   c        = S_DBL_ARGV(4);

   ep       = A_DBL_RET_ARGV(0);

   edpnt_c ( p, a, b, c, ep );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              edterm_c ( ConstSpiceChar      * trmtyp,
                                ConstSpiceChar      * source,
                                ConstSpiceChar      * target,
                                SpiceDouble           et,
                                ConstSpiceChar      * fixref,
                                ConstSpiceChar      * abcorr,
                                ConstSpiceChar      * obsrvr,
                                SpiceInt              npts,
                                SpiceDouble         * trgepc,
                                SpiceDouble           obspos [3],
                                SpiceDouble           trmpts [][3] );
*/
void cspice_edterm(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar             trmtyp[DEFAULT_STR_LENGTH+1];
   SpiceChar             source[DEFAULT_STR_LENGTH+1];
   SpiceChar             target[DEFAULT_STR_LENGTH+1];
   SpiceDouble           et;
   SpiceChar             fixref[DEFAULT_STR_LENGTH+1];
   SpiceChar             abcorr[DEFAULT_STR_LENGTH+1];
   SpiceChar             obsrvr[DEFAULT_STR_LENGTH+1];
   SpiceInt              npts;
   SpiceDouble           trgepc;
   SpiceDouble         * obspos;
   SpiceDouble        (* trmpts)[3] = 0;

   SpiceDouble         * dvals_ret;

   mwSize                sizearray[2];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "trmtyp",  MiceChar,   0, {0}, 0},
      { "source",  MiceChar,   0, {0}, 0},
      { "target",  MiceChar,   0, {0}, 0},
      { "et",      MiceDouble, 0, {0}, 0},
      { "fixref",  MiceChar,   0, {0}, 0},
      { "abcorr",  MiceChar,   0, {0}, 0},
      { "obsrvr",  MiceChar,   0, {0}, 0},
      { "npts",    MiceInt,    0, {0}, 0},
      { "trgepc",  MiceIgnore, 0, {0}, 0},
      { "obspos",  MiceDouble, 1, {3}, 0},
      { "trmpts",  MiceIgnore, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 8, 3 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], trmtyp,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], source,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[3], target,  DEFAULT_STR_LENGTH);

   et = S_DBL_ARGV(4);

   mxGetString(prhs[5], fixref,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[6], abcorr,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[7], obsrvr,  DEFAULT_STR_LENGTH);

   npts    = S_INT_ARGV(8);
   obspos  = A_DBL_RET_ARGV(1);

   if ( npts > 0 )
      {

      /*
      Allocate the memory for the output argument 'trmpts'. Zero-out
      'trmpts'.
      */

      trmpts  = (SpiceDouble (*)[3] )mxMalloc(3 * npts * sizeof(SpiceDouble) );
      memset( trmpts,  0, npts * 3 * sizeof(SpiceDouble) );

      /*
      Call the C wrapper.
      */
      edterm_c ( trmtyp,
              source,
              target,
              et,
              fixref,
              abcorr,
              obsrvr,
              npts,
              &trgepc,
              obspos,
              trmpts);

      if ( failed_c() )
         {
         mxFree( trmpts );
         /*
         The mice_fail call creates the error string then returns control
         to the MATLAB interpreter.
         */
         mice_fail(SCALAR);
         }

      sizearray[0] = 3;
      sizearray[1] = npts;

      }
   else
      {
      trgepc = 0;

      sizearray[0] = 0;
      sizearray[1] = 0;
      }

   plhs[2] = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
   dvals_ret = A_DBL_RET_ARGV(2);

   plhs[0] = mxCreateDoubleScalar( trgepc );

   if ( npts > 0 )
      {
      MOVED( (SpiceDouble *)trmpts, 3*npts, dvals_ret );

      /*
      We allocated space for `npt' trmpts; deallocate this space now.
      */
      mxFree( trmpts );
      }

   }





/*
   void              ekfind_c ( ConstSpiceChar    * query,
                                SpiceInt            lenout,
                                SpiceInt          * nmrows,
                                SpiceBoolean      * error,
                                SpiceChar         * errmsg )
*/
void cspice_ekfind(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar           query  [DEFAULT_STR_LENGTH+1];
   SpiceInt            nmrows;
   SpiceBoolean        error;
   SpiceChar           errmsg [DEFAULT_STR_LENGTH+1];

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "query",  MiceChar,    0, {0}, 0},
      { "nmrows", MiceInt,     0, {0}, 0},
      { "error",  MiceBoolean, 0, {0}, 0},
      { "errmsg", MiceChar,    0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 1, 3 );

   memset( errmsg, 0, default_str_size );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], query, DEFAULT_STR_LENGTH);

   ekfind_c( query,
             DEFAULT_STR_LENGTH,
             &nmrows,
             &error,
             errmsg);

   CHECK_CALL_FAILURE(SCALAR);

   plhs[1] = zzmice_CreateIntScalar(error);

   if ( error )
      {
      plhs[0] = zzmice_CreateIntScalar(0);
      plhs[2] = mxCreateString( errmsg );
      }
   else
      {
      plhs[0] = zzmice_CreateIntScalar(nmrows);
      plhs[2] = mxCreateString( "\0" );
      }

   if ( plhs[2] == NULL )
      {
      mexErrMsgTxt( "MICE(BUG): mxCreateString failed in cspice_ekfind" );
      }

   }




/*
   void              ekgc_c   ( SpiceInt            selidx,
                                SpiceInt            row,
                                SpiceInt            elment,
                                SpiceInt            lenout,
                                SpiceChar         * cdata,
                                SpiceBoolean      * null,
                                SpiceBoolean      * found  )
*/
void cspice_ekgc(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt              selidx;
   SpiceInt              row;
   SpiceInt              elment;
   SpiceInt              lenout;
   SpiceChar             cdata [DEFAULT_STR_LENGTH+1];
   SpiceBoolean          null;
   SpiceBoolean          found;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "selidx", MiceInt,    0, { 0 },    0},
      { "row",    MiceInt,    0, { 0 },    0},
      { "elment", MiceInt,    0, { 0 },    0},
      { "cdatln", MiceInt,    0, { 0 },    0},
      { "cdata",  MiceIgnore, 0, { 0 },    0},
      { "null",   MiceIgnore, 0, { 0 },    0},
      { "found",  MiceIgnore, 0, { 0 },    0},
      };

   check_arg_num( nrhs, nlhs, 4, 3 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   /*
   Retrieve the values of the input arguments. MATLAB uses a base 1 array
   index convention, as is proper, C does not, which is weird. Subtract one
   off the 'selidx', 'row', and 'elment' indices.
   */
   selidx = S_INT_ARGV(1) - 1;
   row    = S_INT_ARGV(2) - 1;
   elment = S_INT_ARGV(3) - 1;
   lenout = S_INT_ARGV(4);

   ekgc_c( selidx, row, elment, lenout, cdata, &null, &found);
   CHECK_CALL_FAILURE(SCALAR);

   /*
   Return 'cdata' if 'found' returns as SPICETRUE, otherwise return
   a null string.
   */
   if ( found )
      {
      plhs[0] = mxCreateString( cdata );
      }
   else
      {
      plhs[0] = mxCreateString( "\0" );
      }

   if ( plhs[0] == NULL )
      {
      mexErrMsgTxt( "MICE(BUG): mxCreateString failed in cspice_ekgc" );
      }

   plhs[1] = zzmice_CreateIntScalar(null);
   plhs[2] = zzmice_CreateIntScalar(found);

   }




/*
   void              ekgd_c   ( SpiceInt            selidx,
                                SpiceInt            row,
                                SpiceInt            elment,
                                SpiceDouble       * ddata,
                                SpiceBoolean      * null,
                                SpiceBoolean      * found  )
*/
void cspice_ekgd(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt              selidx;
   SpiceInt              row;
   SpiceInt              elment;
   SpiceDouble           ddata;
   SpiceBoolean          null;
   SpiceBoolean          found;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "selidx", MiceInt,    0, { 0 },    0},
      { "row",    MiceInt,    0, { 0 },    0},
      { "elment", MiceInt,    0, { 0 },    0},
      { "ddata",  MiceIgnore, 0, { 0 },    0},
      { "null",   MiceIgnore, 0, { 0 },    0},
      { "found",  MiceIgnore, 0, { 0 },    0},
      };

   check_arg_num( nrhs, nlhs, 3, 3 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   /*
   Retrieve the values of the input arguments. MATLAB uses a base 1 array
   index convention, as is proper, C does not, which is weird. Subtract one
   off the 'selidx', 'row', and 'elment' indices.
   */
   selidx = S_INT_ARGV(1) - 1;
   row    = S_INT_ARGV(2) - 1;
   elment = S_INT_ARGV(3) - 1;

   ekgd_c( selidx, row, elment, &ddata, &null, &found);
   CHECK_CALL_FAILURE(SCALAR);

   plhs[0] = mxCreateDoubleScalar(ddata);
   plhs[1] = zzmice_CreateIntScalar(null);
   plhs[2] = zzmice_CreateIntScalar(found);

   }




/*
   void              ekgi_c   ( SpiceInt            selidx,
                                SpiceInt            row,
                                SpiceInt            elment,
                                SpiceInt          * idata,
                                SpiceBoolean      * null,
                                SpiceBoolean      * found  )
*/
void cspice_ekgi(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt              selidx;
   SpiceInt              row;
   SpiceInt              elment;
   SpiceInt              idata;
   SpiceBoolean          null;
   SpiceBoolean          found;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "selidx", MiceInt,    0, { 0 },    0},
      { "row",    MiceInt,    0, { 0 },    0},
      { "elment", MiceInt,    0, { 0 },    0},
      { "idata",  MiceIgnore, 0, { 0 },    0},
      { "null",   MiceIgnore, 0, { 0 },    0},
      { "found",  MiceIgnore, 0, { 0 },    0},
      };

   check_arg_num( nrhs, nlhs, 3, 3 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   /*
   Retrieve the values of the input arguments. MATLAB uses a base 1 array
   index convention, as is proper, C does not, which is weird. Subtract one
   off the 'selidx', 'row', and 'elment' indices.
   */
   selidx = S_INT_ARGV(1) - 1;
   row    = S_INT_ARGV(2) - 1;
   elment = S_INT_ARGV(3) - 1;

   ekgi_c( selidx, row, elment, &idata, &null, &found);
   CHECK_CALL_FAILURE(SCALAR);

   plhs[0] = zzmice_CreateIntScalar(idata);
   plhs[1] = zzmice_CreateIntScalar(null);
   plhs[2] = zzmice_CreateIntScalar(found);

   }




/*
   SpiceInt          eknelt_c ( SpiceInt            selidx,
                                SpiceInt            row     );
*/
void cspice_eknelt(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt            selidx;
   SpiceInt            row;
   SpiceInt            nelt;

   struct extra_dims  * extra;

   struct argcheck ArgCheck[] =
      {
      { "selidx", MiceInt,    0, {0}, 0},
      { "row",    MiceInt,    0, {0}, 0},
      { "nelt",   MiceIgnore, 0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   /*
   MATLAB uses a base 1 array index convention, as is proper,
   C does not, which is weird. Subtract one off 'selidx' and 'row'.
   */
   selidx = S_INT_ARGV(1) - 1;
   row    = S_INT_ARGV(2) - 1;

   nelt = eknelt_c ( selidx, row );
   CHECK_CALL_FAILURE(SCALAR);

   plhs[0] = zzmice_CreateIntScalar(nelt);

   }




/*
   void              el2cgv_c ( ConstSpiceEllipse * ellips,
                                SpiceDouble         center[3],
                                SpiceDouble         smajor[3],
                                SpiceDouble         sminor[3]  );
*/
void cspice_el2cgv(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceEllipse         ellips;
   SpiceDouble        * center;
   SpiceDouble        * smajor;
   SpiceDouble        * sminor;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "ellips", MiceEllipse, 0, {0}, 0},
      { "center", MiceDouble,  1, {3}, 0},
      { "smajor", MiceDouble,  1, {3}, 0},
      { "sminor", MiceDouble,  1, {3}, 0},
      };

   check_arg_num( nrhs, nlhs, 1, 3 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   center = A_DBL_RET_ARGV(0);
   smajor = A_DBL_RET_ARGV(1);
   sminor = A_DBL_RET_ARGV(2);

   memcpy( ellips.center,
           mxGetPr( mxGetField( prhs[1], 0,"center") ),
           3*sizeof(SpiceDouble)
         );

   memcpy( ellips.semiMajor,
           mxGetPr( mxGetField( prhs[1], 0,"semiMajor") ),
           3*sizeof(SpiceDouble)
         );

   memcpy( ellips.semiMinor,
           mxGetPr( mxGetField( prhs[1], 0,"semiMinor") ),
           3*sizeof(SpiceDouble)
         );

   el2cgv_c ( &ellips, center, smajor, sminor );
   CHECK_CALL_FAILURE( SCALAR );

   }




/*
   void              etcal_c  ( SpiceDouble         et,
                                SpiceInt            lenout,
                                SpiceChar         * string  );
*/
void cspice_etcal(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar           string[DEFAULT_STR_LENGTH+1];
   SpiceChar        ** cval;
   SpiceChar        ** array;
   SpiceDouble         et;
   SpiceDouble       * vec_et;

   mwIndex             i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "et",     MiceDouble, 0, {0}, 1},
      { "calstr", MiceChar,   0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 1, 1 );

   memset( string, 0, default_str_size );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_et = A_DBL_ARGV(1);

   if (extra->count>1)
      {

      /*
      Allocate needed memory for intermediate operations.
      */
      cval  = (SpiceChar**)alloc_SpiceString_C_array(DEFAULT_STR_LENGTH,
                                                     extra->count );
      array = (SpiceChar**)alloc_SpiceString_Pointer_array(extra->count);

      /*
      Test for a SPICE error signal, if found, display an error message to
      the user then return to the MATLAB application.
      */
      CHECK_CALL_FAILURE_MEM1(SCALAR, 1, cval, array);

      for (i=0;i<extra->count;i++)
         {

         et = *(vec_et+i*extra->offset[0]);

         /*
         Copy the ith string pointer to the array of pointers,
         use this pointer for the call output.
         */
         array[i] = *cval + i*default_str_size;

         etcal_c( et, DEFAULT_STR_LENGTH, array[i] );
         CHECK_CALL_FAILURE_MEM1(i, 1, cval, array);
         }

      /*
      I think this functions as a copy, creating needed memory to plhs.
      */
      plhs[0] = mxCreateCharMatrixFromStrings( extra->count,
                                               (const char **)array);

      free_SpiceString_C_array ( 1, cval );
      free_SpiceMemory( array );
      }
   else
      {
      et = *(vec_et);

      etcal_c( et, DEFAULT_STR_LENGTH, string  );
      CHECK_CALL_FAILURE(SCALAR);

      plhs[0] = mxCreateString( string );
      if ( plhs[0] == NULL )
         {
         mexErrMsgTxt( "MICE(BUG): mxCreateString failed in cspice_etcal" );
         }

      }

   /*
   Confirm the code released all allocated memory.
   */
   MICE_ALLOC_CHECK;

   }





/*
   void              et2lst_c ( SpiceDouble         et,
                                SpiceInt            body,
                                SpiceDouble         lon,
                                ConstSpiceChar    * type,
                                SpiceInt            timlen,
                                SpiceInt            ampmlen,
                                SpiceInt          * hr,
                                SpiceInt          * mn,
                                SpiceInt          * sc,
                                SpiceChar         * time,
                                SpiceChar         * ampm    );

*/
void cspice_et2lst(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble          et;
   SpiceDouble        * vec_et;
   SpiceInt             body;
   SpiceDouble          lon;
   SpiceChar            type [DEFAULT_STR_LENGTH+1];
   SpiceInt           * hr;
   SpiceInt           * vec_hr;
   SpiceInt           * mn;
   SpiceInt           * vec_mn;
   SpiceInt           * sc;
   SpiceInt           * vec_sc;
   SpiceChar            time [DEFAULT_STR_LENGTH+1];
   SpiceChar            ampm [DEFAULT_STR_LENGTH+1];
   SpiceChar         ** time_cval;
   SpiceChar         ** time_array;
   SpiceChar         ** ampm_cval;
   SpiceChar         ** ampm_array;

   mwIndex              i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "et",   MiceDouble, 0, {0}, 1},
      { "body", MiceInt,    0, {0}, 0},
      { "lon",  MiceDouble, 0, {0}, 0},
      { "type", MiceChar,   0, {0}, 0},
      { "hr",   MiceInt,    0, {0}, 1},
      { "mn",   MiceInt,    0, {0}, 1},
      { "sc",   MiceInt,    0, {0}, 1},
      { "time", MiceChar,   0, {0}, 1},
      { "ampm", MiceChar,   0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 4, 5 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_et = A_DBL_ARGV(1);
   body   = S_INT_ARGV(2);
   lon    = S_DBL_ARGV(3);

   vec_hr = A_INT_RET_ARGV(0);
   vec_mn = A_INT_RET_ARGV(1);
   vec_sc = A_INT_RET_ARGV(2);


   mxGetString(prhs[4], type, DEFAULT_STR_LENGTH);

   if (extra->count>1)
      {

      /*
      Allocate needed memory for intermediate operations.
      */
      time_cval  = (SpiceChar**)alloc_SpiceString_C_array(DEFAULT_STR_LENGTH,
                                                          extra->count );
      time_array = (SpiceChar**)alloc_SpiceString_Pointer_array(extra->count);

      CHECK_CALL_FAILURE_MEM1(SCALAR, 1, time_cval, time_array);

      ampm_cval  = (SpiceChar**)alloc_SpiceString_C_array(DEFAULT_STR_LENGTH,
                                                          extra->count );
      ampm_array = (SpiceChar**)alloc_SpiceString_Pointer_array(extra->count);

      CHECK_CALL_FAILURE_MEM1(SCALAR, 1, ampm_cval, ampm_array);

      for ( i=0; i<extra->count; i++)
         {
         et = *(vec_et + i*extra->offset[0]);

         hr =  (vec_hr + i*extra->offset[4]);
         mn =  (vec_mn + i*extra->offset[5]);
         sc =  (vec_sc + i*extra->offset[6]);

         /*
         Copy the ith string pointer to the array of pointers,
         use this pointer for the call output.
         */
         time_array[i] = *time_cval + i*default_str_size;
         ampm_array[i] = *ampm_cval + i*default_str_size;

         et2lst_c( et,
                   body,
                   lon,
                   type,
                   DEFAULT_STR_LENGTH,
                   DEFAULT_STR_LENGTH,
                   hr,
                   mn,
                   sc,
                   time_array[i],
                   ampm_array[i] );


         /*
         Check for a failure signal. Free the memory assigned to 'time_cval',
         'ampm_cval', 'time_array', and 'ampm_array'.
         before signaling a Matlab error.
         */
         if ( failed_c())
            {
            free_SpiceString_C_array( 1, time_cval );
            free_SpiceString_C_array( 1, ampm_cval );

            free_SpiceMemory( time_array );
            free_SpiceMemory( ampm_array );

            /*
            The mice_fail call creates the error string then returns control
            to the MATLAB interpreter.
            */
            mice_fail(i);
            }

         }

      /*
      I think this functions as a copy, creating needed memory to plhs.
      */
      plhs[3] = mxCreateCharMatrixFromStrings( extra->count,
                                               (const char **)time_array);
      plhs[4] = mxCreateCharMatrixFromStrings( extra->count,
                                               (const char **)ampm_array);

      free_SpiceString_C_array ( 1, time_cval );
      free_SpiceString_C_array ( 1, ampm_cval );
      free_SpiceMemory( time_array );
      free_SpiceMemory( ampm_array );
      }
   else
      {
      et = *vec_et;
      hr = vec_hr;
      mn = vec_mn;
      sc = vec_sc;

      et2lst_c( et,
                body,
                lon,
                type,
                DEFAULT_STR_LENGTH,
                DEFAULT_STR_LENGTH,
                hr,
                mn,
                sc,
                time,
                ampm );
      CHECK_CALL_FAILURE(SCALAR);

      plhs[3] = mxCreateString( time);
      if ( plhs[3] == NULL )
         {
         mexErrMsgTxt(
            "MICE(BUG): mxCreateString 'time' failed in cspice_et2lst" );
         }

      plhs[4] = mxCreateString( ampm );
      if ( plhs[4] == NULL )
         {
         mexErrMsgTxt(
            "MICE(BUG): mxCreateString 'ampm' failed in cspice_et2lst" );
         }

      }

   /*
   Confirm the code released all allocated memory.
   */
   MICE_ALLOC_CHECK;

   }




/*
   void              et2utc_c(  SpiceDouble       et,
                                ConstSpiceChar  * format,
                                SpiceInt          prec,
                                SpiceInt          lenout,
                                SpiceChar       * utcstr   )
*/
void cspice_et2utc(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar           format[DEFAULT_STR_LENGTH+1];
   SpiceChar           utcstr[DEFAULT_STR_LENGTH+1];
   SpiceChar        ** cval;
   SpiceChar        ** array;
   SpiceDouble         et;
   SpiceDouble       * vec_et;
   SpiceInt            prec;

   mwIndex             i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "et",     MiceDouble, 0, {0}, 1},
      { "format", MiceChar,   0, {0}, 0},
      { "prec",   MiceInt,    0, {0}, 0},
      { "utcstr", MiceChar,   0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   memset( utcstr, 0, default_str_size );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_et = A_DBL_ARGV(1);

   mxGetString(prhs[2], format, DEFAULT_STR_LENGTH);

   prec = S_INT_ARGV(3);

   if (extra->count>1)
      {

      /*
      Allocate needed memory for intermediate operations.
      */
      cval  = (SpiceChar**)alloc_SpiceString_C_array(DEFAULT_STR_LENGTH,
                                                     extra->count );
      array = (SpiceChar**)alloc_SpiceString_Pointer_array(extra->count);

      /*
      Test for a SPICE error signal, if found, display an error message to
      the user then return to the MATLAB application.
      */
      CHECK_CALL_FAILURE_MEM1(SCALAR, 1, cval, array);

      for (i=0;i<extra->count;i++)
         {

         et = *(vec_et+i*extra->offset[0]);

         /*
         Copy the ith string pointer to the array of pointers,
         use this pointer for the call output.
         */
         array[i] = *cval + i*default_str_size;

         et2utc_c(et, format, prec, DEFAULT_STR_LENGTH, array[i]);
         CHECK_CALL_FAILURE_MEM1(i, 1, cval, array);

         }

      /*
      I think this functions as a copy, creating needed memory to plhs.
      */
      plhs[0] = mxCreateCharMatrixFromStrings( extra->count,
                                               (const char **)array);

      free_SpiceString_C_array ( 1, cval );
      free_SpiceMemory( array );
      }
   else
      {
      et = *(vec_et);

      et2utc_c(et, format, prec, DEFAULT_STR_LENGTH, utcstr);
      CHECK_CALL_FAILURE(SCALAR);

      plhs[0] = mxCreateString( utcstr );
      if ( plhs[0] == NULL )
         {
         mexErrMsgTxt( "MICE(BUG): mxCreateString failed in cspice_et2utc" );
         }

      }

   /*
   Confirm the code released all allocated memory.
   */
   MICE_ALLOC_CHECK;

   }




/*
   void              eul2m_c( SpiceDouble  angle3,
                              SpiceDouble  angle2,
                              SpiceDouble  angle1,
                              SpiceInt     axis3,
                              SpiceInt     axis2,
                              SpiceInt     axis1,
                              SpiceDouble  r [3][3] )
*/
void cspice_eul2m(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_angle3;
   SpiceDouble        * vec_angle2;
   SpiceDouble        * vec_angle1;
   SpiceDouble        * vec_r;
   SpiceDouble          angle3;
   SpiceDouble          angle2;
   SpiceDouble          angle1;
   SpiceInt             axis3;
   SpiceInt             axis2;
   SpiceInt             axis1;
   SpiceDouble        * r;
   SpiceDouble          xr[3][3];

   mwIndex              i;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "angle3", MiceDouble, 0, {0},    1},
      { "angle2", MiceDouble, 0, {0},    1},
      { "angle1", MiceDouble, 0, {0},    1},
      { "axis3",  MiceInt,    0, {0},    0},
      { "axis2",  MiceInt,    0, {0},    0},
      { "axis1",  MiceInt,    0, {0},    0},
      { "r",      MiceDouble, 2, {3, 3}, 1},
      };

   check_arg_num( nrhs, nlhs, 6, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_angle3 = A_DBL_ARGV(1);
   vec_angle2 = A_DBL_ARGV(2);
   vec_angle1 = A_DBL_ARGV(3);
   angle3     = *vec_angle3;
   angle2     = *vec_angle2;
   angle1     = *vec_angle1;
   axis3      = S_INT_ARGV(4);
   axis2      = S_INT_ARGV(5);
   axis1      = S_INT_ARGV(6);
   vec_r      = A_DBL_RET_ARGV(0);
   r          = vec_r;

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         angle3 = *(vec_angle3 + i*extra->offset[0]);
         angle2 = *(vec_angle2 + i*extra->offset[1]);
         angle1 = *(vec_angle1 + i*extra->offset[2]);
         r      =  (vec_r      + i*extra->offset[6]);

         eul2m_c( angle3,
                  angle2,
                  angle1,
                  axis3,
                  axis2,
                  axis1,
                  (SpiceDouble(*)[3])xr);

         CHECK_CALL_FAILURE(i);

         xpose_c( xr, (SpiceDouble(*)[3])r );
         }

      }
   else
      {
      eul2m_c( angle3,
               angle2,
               angle1,
               axis3,
               axis2,
               axis1,
               (SpiceDouble(*)[3])xr);

      CHECK_CALL_FAILURE(SCALAR);

      xpose_c( xr, (SpiceDouble(*)[3])r );
      }

   }




/*
   void              eul2xf_c ( ConstSpiceDouble    eulang[6],
                                SpiceInt            axisa,
                                SpiceInt            axisb,
                                SpiceInt            axisc,
                                SpiceDouble         xform [6][6] );

*/
void cspice_eul2xf(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_eulang;
   SpiceDouble        * vec_xform;
   SpiceInt             axisa;
   SpiceInt             axisb;
   SpiceInt             axisc;
   SpiceDouble        * eulang;
   SpiceDouble        * xform;
   SpiceDouble          xr[6][6];

   mwIndex              i;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "eulang", MiceDouble, 1, {6},    1},
      { "axisa",  MiceInt,    0, {0},    0},
      { "axisb",  MiceInt,    0, {0},    0},
      { "axisc",  MiceInt,    0, {0},    0},
      { "xform",  MiceDouble, 2, {6, 6}, 1},
      };

   check_arg_num( nrhs, nlhs, 4, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_eulang = A_DBL_ARGV(1);
   axisa      = S_INT_ARGV(2);
   axisb      = S_INT_ARGV(3);
   axisc      = S_INT_ARGV(4);
   vec_xform  = A_DBL_RET_ARGV(0);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         eulang = (vec_eulang + i*extra->offset[0]);
         xform  = (vec_xform  + i*extra->offset[4]);

         eul2xf_c ( eulang, axisa, axisb, axisc, (SpiceDouble(*)[6])xr);
         CHECK_CALL_FAILURE(i);

         xpose6_c( xr, (SpiceDouble(*)[6])xform  );
         }

      }
   else
      {

      eulang = vec_eulang;
      xform  = vec_xform;

      eul2xf_c( eulang, axisa, axisb, axisc, (SpiceDouble(*)[6])xr);
      CHECK_CALL_FAILURE(SCALAR);

      xpose6_c( xr, (SpiceDouble(*)[6])xform  );
      }

   }




/*
   void evsgp4_c ( SpiceDouble         et,
                   ConstSpiceDouble    geophs [8],
                   ConstSpiceDouble    elems  [10],
                   SpiceDouble         state  [6]  )
*/
void cspice_evsgp4(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble          et;
   SpiceDouble        * geophs;
   SpiceDouble        * elems;
   SpiceDouble        * state;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "et",      MiceDouble,   0, {0},   0},
      { "geophs",  MiceDouble,   1, {8},   0},
      { "elems",   MiceDouble,   1, {10},  0},
      { "state",   MiceDouble,   1, {6},   0},
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   et       = S_DBL_ARGV(1);
   geophs   = A_DBL_ARGV(2);
   elems    = A_DBL_ARGV(3);

   state    = A_DBL_RET_ARGV(0);

   evsgp4_c ( et, geophs, elems, state );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void expool_c ( ConstSpiceChar  * name,
                   SpiceBoolean    * found )
*/
void cspice_expool(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            name   [DEFAULT_STR_LENGTH+1];
   SpiceBoolean       * found;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "name",    MiceChar,     0, {0},   0},
      { "found",   MiceBoolean,  0, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 1, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], name, DEFAULT_STR_LENGTH);

   found    = A_BOOL_RET_ARGV(0);

   expool_c ( name, found );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void fovray_c ( ConstSpiceChar   * inst,
                   ConstSpiceDouble   raydir [3],
                   ConstSpiceChar   * rframe,
                   ConstSpiceChar   * abcorr,
                   ConstSpiceChar   * observer,
                   SpiceDouble      * et,
                   SpiceBoolean     * visible  )
*/
void cspice_fovray(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {


   SpiceChar        instrument   [DEFAULT_STR_LENGTH+1];
   SpiceChar        ray_frame    [DEFAULT_STR_LENGTH+1];
   SpiceChar        abcorr       [DEFAULT_STR_LENGTH+1];
   SpiceChar        observer     [DEFAULT_STR_LENGTH+1];

   SpiceDouble    * raydir;
   SpiceDouble    * et;
   SpiceDouble    * vec_et;
   SpiceBoolean   * visible;
   SpiceBoolean   * vec_visible;

   mwIndex          i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "inst",   MiceChar,    0, {0}, 0},
      { "raydir", MiceDouble,  1, {3}, 0},
      { "rframe", MiceChar,    0, {0}, 0},
      { "abcorr", MiceChar,    0, {0}, 0},
      { "obsrvr", MiceChar,    0, {0}, 0},
      { "et",     MiceDouble,  0, {0}, 1},
      { "visibl", MiceBoolean, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 6, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], instrument, DEFAULT_STR_LENGTH);
   mxGetString(prhs[3], ray_frame,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[4], abcorr,     DEFAULT_STR_LENGTH);
   mxGetString(prhs[5], observer,   DEFAULT_STR_LENGTH);

   raydir      = A_DBL_ARGV(2);
   vec_et      = A_DBL_ARGV(6);
   vec_visible = A_BOOL_RET_ARGV(0);

   et      = (vec_et);
   visible = (vec_visible);

   /*
   Check for vectorized arguments.
   */

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         et      = (vec_et      + i*extra->offset[5]);
         visible = (vec_visible + i*extra->offset[6]);

         fovray_c ( instrument, raydir, ray_frame,
                    abcorr, observer, et, visible );

         CHECK_CALL_FAILURE(i);

         }

      }
   else
      {

      fovray_c ( instrument, raydir, ray_frame,
                 abcorr, observer, et, visible );

      CHECK_CALL_FAILURE(SCALAR);

      }

   }




/*
   void fovtrg_c ( ConstSpiceChar   * inst,
                   ConstSpiceChar   * target,
                   ConstSpiceChar   * tshape,
                   ConstSpiceChar   * tframe,
                   ConstSpiceChar   * abcorr,
                   ConstSpiceChar   * obsrvr,
                   SpiceDouble      * et,
                   SpiceBoolean     * visible  )
*/
void cspice_fovtrg(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {


   SpiceChar        instrument   [DEFAULT_STR_LENGTH+1];
   SpiceChar        target       [DEFAULT_STR_LENGTH+1];
   SpiceChar        target_shape [DEFAULT_STR_LENGTH+1];
   SpiceChar        target_frame [DEFAULT_STR_LENGTH+1];
   SpiceChar        abcorr       [DEFAULT_STR_LENGTH+1];
   SpiceChar        observer     [DEFAULT_STR_LENGTH+1];
   SpiceDouble    * et;
   SpiceDouble    * vec_et;
   SpiceBoolean   * visible;
   SpiceBoolean   * vec_visible;

   mwIndex              i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "inst",    MiceChar,    0, {0}, 0},
      { "target",  MiceChar,    0, {0}, 0},
      { "tshape",  MiceChar,    0, {0}, 0},
      { "tframe",  MiceChar,    0, {0}, 0},
      { "abcorr",  MiceChar,    0, {0}, 0},
      { "obsrvr",  MiceChar,    0, {0}, 0},
      { "et",      MiceDouble,  0, {0}, 1},
      { "visibl",  MiceBoolean, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 7, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], instrument,   DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], target,       DEFAULT_STR_LENGTH);
   mxGetString(prhs[3], target_shape, DEFAULT_STR_LENGTH);
   mxGetString(prhs[4], target_frame, DEFAULT_STR_LENGTH);
   mxGetString(prhs[5], abcorr,       DEFAULT_STR_LENGTH);
   mxGetString(prhs[6], observer,     DEFAULT_STR_LENGTH);

   vec_et      = A_DBL_ARGV(7);
   vec_visible = A_BOOL_RET_ARGV(0);

   et      = (vec_et);
   visible = (vec_visible);

   /*
   Check for vectorized arguments.
   */
   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         et      = (vec_et      + i*extra->offset[6]);
         visible = (vec_visible + i*extra->offset[7]);

         fovtrg_c ( instrument, target, target_shape, target_frame,
                    abcorr, observer, et, visible );

         CHECK_CALL_FAILURE(i);

         }

      }
   else
      {

      fovtrg_c ( instrument, target, target_shape, target_frame,
                 abcorr, observer, et, visible );

      CHECK_CALL_FAILURE(SCALAR);

      }

   }




/*
   void              frame_c  ( SpiceDouble         x[3],
                                SpiceDouble         y[3],
                                SpiceDouble         z[3] );
*/
void cspice_frame(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

    /*
    Note, the 'x' argument is a mutator. Mutators are a pain.
    */

   SpiceDouble        * vec;
   SpiceDouble        * x;
   SpiceDouble        * y;
   SpiceDouble        * z;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "x",    MiceDouble, 1, {3}, 0},
      { "x_f",  MiceDouble, 1, {3}, 0},
      { "y",    MiceDouble, 1, {3}, 0},
      { "z",    MiceDouble, 1, {3}, 0},
      };

   check_arg_num( nrhs, nlhs, 1, 3 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec  = A_DBL_ARGV(1);
   x    = A_DBL_RET_ARGV(0);
   y    = A_DBL_RET_ARGV(1);
   z    = A_DBL_RET_ARGV(2);

   /*
   Copy the input 'x' (vec) to the mutable 'x'.
   */
   MOVED( vec, 3, x );

   frame_c  ( x, y, z );
   CHECK_CALL_FAILURE( SCALAR );

   }




/*
   void              frinfo_c ( SpiceInt        frcode,
                                SpiceInt      * cent,
                                SpiceInt      * frclss,
                                SpiceInt      * clssid,
                                SpiceBoolean  * found   )
*/
void mice_frinfo(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             frcode;
   SpiceInt           * vec_frcode;
   SpiceInt             cent;
   SpiceInt             frclss;
   SpiceInt             clssid;
   SpiceBoolean         found;

   mwIndex              i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "frcode", MiceInt,    0, {0}, 1},
      { "frinfo", MiceFrinfo, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 1, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_frcode = A_INT_ARGV(1);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         frcode = *(vec_frcode  + i*extra->offset[0]);

         frinfo_c ( frcode,
                    &cent,
                    &frclss,
                    &clssid,
                    &found );
         CHECK_CALL_FAILURE(i);

         if ( !found )
            {
            cent    = 0;
            frclss  = 0;
            clssid  = 0;
            }

         mxDestroyArray( mxGetField( plhs[0], i, "center" ) );
         mxSetField(plhs[0], i, "center",   zzmice_CreateIntScalar(cent) );

         mxDestroyArray( mxGetField( plhs[0], i, "class" ) );
         mxSetField(plhs[0], i, "class",    zzmice_CreateIntScalar(frclss) );

         mxDestroyArray( mxGetField( plhs[0], i, "class_ID" ) );
         mxSetField(plhs[0], i, "class_ID", zzmice_CreateIntScalar(clssid) );

         mxDestroyArray( mxGetField( plhs[0], i, "found" ) );
         mxSetField( plhs[0], i, "found",
                     mxCreateLogicalScalar(found ? true: false));
         }

      }
   else
      {

      frcode     = *vec_frcode;

      frinfo_c ( frcode,
                 &cent,
                 &frclss,
                 &clssid,
                 &found );
      CHECK_CALL_FAILURE(SCALAR);

      if ( !found )
         {
         cent    = 0;
         frclss  = 0;
         clssid  = 0;
         }

      mxDestroyArray( mxGetField( plhs[0], 0, "center" ) );
      mxSetField(plhs[0], 0, "center",   zzmice_CreateIntScalar(cent) );

      mxDestroyArray( mxGetField( plhs[0], 0, "class" ) );
      mxSetField(plhs[0], 0, "class",    zzmice_CreateIntScalar(frclss) );

      mxDestroyArray( mxGetField( plhs[0], 0, "class_ID" ) );
      mxSetField(plhs[0], 0, "class_ID", zzmice_CreateIntScalar(clssid) );

      mxDestroyArray( mxGetField( plhs[0], 0, "found" ) );
      mxSetField( plhs[0], 0, "found",
                  mxCreateLogicalScalar(found ? true: false));
      }

   }




/*
   void              frmnam_c ( SpiceInt            frcode,
                                SpiceInt            lenout,
                                SpiceChar         * frname  )
*/
void cspice_frmnam(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            frname [DEFAULT_STR_LENGTH+1];
   SpiceInt             frcode;
   SpiceInt           * vec_code;
   mwIndex              i;

   SpiceChar        ** cval;
   SpiceChar        ** array;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "frcode", MiceInt,  0, {0}, 1},
      { "frname", MiceChar, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 1, 1 );

   memset( frname, 0, default_str_size );

   extra    = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_code = A_INT_ARGV(1);

   if (extra->count>1)
      {

      /*
      Allocate needed memory for intermediate operations.
      */
      cval  = (SpiceChar**)alloc_SpiceString_C_array(DEFAULT_STR_LENGTH,
                                                           extra->count);
      array = (SpiceChar**)alloc_SpiceString_Pointer_array(extra->count);

      CHECK_CALL_FAILURE_MEM1(SCALAR, 1, cval, array);

      for (i=0;i<extra->count;i++)
         {

         frcode = *(vec_code  + i*extra->offset[0]);

         /*
         Copy the ith string pointer to the array of pointers,
         use this pointer for the call output.
         */
         array[i] = *cval + i*default_str_size;

         frmnam_c(frcode, DEFAULT_STR_LENGTH, array[i] );
         CHECK_CALL_FAILURE_MEM1(i, 1, cval, array);
         }

      /*
      I think this functions as a copy, creating needed
      memory for plhs.
      */
      plhs[0] = mxCreateCharMatrixFromStrings( extra->count,
                                               (const char **)array);

      free_SpiceString_C_array ( 1, cval );
      free_SpiceMemory( array );

      }
   else
      {

      frcode   = *vec_code;

      frmnam_c(frcode, DEFAULT_STR_LENGTH, frname );
      CHECK_CALL_FAILURE(SCALAR);

      plhs[0] = mxCreateString( frname );
      if ( plhs[0] == NULL )
         {
         mexErrMsgTxt( "MICE(BUG): mxCreateString failed in cspice_fmrnam" );
         }

      }

   /*
   Confirm the code released all allocated memory.
   */
   MICE_ALLOC_CHECK;

   }




/*
   void              furnsh_c ( ConstSpiceChar    * file );
*/
void cspice_furnsh(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar           file[DEFAULT_STR_LENGTH+1];
   mxChar            * mx_file;

   mwIndex             i;
   SpiceInt            j;

   struct extra_dims * extra;
   struct argcheck ArgCheck[] =
      {
      { "file", MiceChar, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 1, 0 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   if (extra->count>1)
      {

      mx_file = (mxChar *)mxGetChars(prhs[1]);

      for ( i=0; i<extra->count; i++)
         {

         /*
         Extract the string data, character by character, into
         CSPICE strings. The mx_str array stores the data in a column
         major format, we need to extract the data by rows.
         */
         for ( j=0; j<extra->offset[0]; j++)
            {
            file[j] = (char)mx_file[i + (extra->count*j)];
            }

         file[extra->offset[0]] = '\0';

         furnsh_c(file);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {
      mxGetString(prhs[1], file, DEFAULT_STR_LENGTH);

      furnsh_c(file);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void              gcpool_c ( ConstSpiceChar    * name,
                                SpiceInt            start,
                                SpiceInt            room,
                                SpiceInt            lenout,
                                SpiceInt          * n,
                                void              * cvals,
                                SpiceBoolean      * found );
*/
void cspice_gcpool(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            name[MAXLEN+1];
   SpiceInt             start;
   SpiceInt             room;
   SpiceInt             lenout;
   SpiceInt             n = 0;
   SpiceChar         ** cvals;
   SpiceChar         ** array;
   SpiceBoolean         found;

   SpiceInt             i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "name",   MiceChar,   0, {0}, 0},
      { "start",  MiceInt,    0, {0}, 0},
      { "room",   MiceInt,    0, {0}, 0},
      { "cvals",  MiceIgnore, 0, {0}, 0},
      { "found",  MiceIgnore, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 3, 2 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], name, MAXLEN);

   /*
   MATLAB uses a base 1 array index convention, as is proper,
   C does not, which is weird. Subtract one off the 'start' index.
   */
   start  = S_INT_ARGV(2) - 1;
   room   = S_INT_ARGV(3);
   lenout = MAXCHR;

   cvals  = (SpiceChar**)alloc_SpiceString_C_array ( lenout, room );
   array  = (SpiceChar**)alloc_SpiceString_Pointer_array(room);

   CHECK_CALL_FAILURE_MEM1(SCALAR, 1, cvals, array);

   gcpool_c(name, start, room, lenout, &n, *cvals, &found);
   CHECK_CALL_FAILURE_MEM1(SCALAR, 1, cvals, array);

   if ( found )
      {
      for (i=0;i<n;i++)
         {

         /*
         Copy the ith string pointer to the array of pointers for input
         to the mx call.
         */
         array[i] = *cvals + i*lenout;
         }

      /*
      I think this functions as a copy, creating needed memory to 'plhs'.
      */
      plhs[0] = mxCreateCharMatrixFromStrings( n, (const char **)array);
      }
   else
      {
      plhs[0] = mxCreateString( "\0" );
      }

   plhs[1] = zzmice_CreateIntScalar(found);

   free_SpiceString_C_array( 1, cvals );
   free_SpiceMemory( array );

   /*
   Confirm the code released all allocated memory.
   */
   MICE_ALLOC_CHECK;

   }




/*
   void              gdpool_c ( ConstSpiceChar    * name,
                                SpiceInt            start,
                                SpiceInt            room,
                                SpiceInt          * n,
                                SpiceDouble       * values,
                                SpiceBoolean      * found );
*/
void cspice_gdpool(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            name [MAXLEN+1];
   SpiceInt             start;
   SpiceInt             room;
   SpiceInt             n = 0;
   SpiceDouble        * dvals;
   SpiceDouble        * dvals_ret;
   SpiceBoolean         found;

   mwSize               sizearray[2];

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "name",   MiceChar,    0, {0}, 0},
      { "start",  MiceInt,     0, {0}, 0},
      { "room",   MiceInt,     0, {0}, 0},
      { "values", MiceIgnore,  0, {0}, 0},
      { "found",  MiceIgnore,  0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 3, 2 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], name, MAXLEN);

   /*
   MATLAB uses a base 1 array index convention, as is proper,
   C does not, which is weird. Subtract one off the 'start' index.
   */
   start  = S_INT_ARGV(2) - 1;
   room   = S_INT_ARGV(3);

   dvals  = (SpiceDouble*)mxMalloc(room * sizeof(SpiceDouble) );
   memset( dvals,  0, room * sizeof(SpiceDouble) );

   gdpool_c(name, start, room, &n, dvals, &found);

   /*
   Check for a failure signal. Free the memory assigned to 'dvals'
   before signaling a Matlab error.
   */
   if ( failed_c())
      {
      mxFree( dvals );

      /*
      The mice_fail call creates the error string then returns control
      to the MATLAB interpreter.
      */
      mice_fail(SCALAR);
      }

   if( found )
      {
      sizearray[0] = n;
      sizearray[1] = 1;
      }
   else
      {
      sizearray[0] = 0;
      sizearray[1] = 0;
      }

   plhs[0]   = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
   dvals_ret = A_DBL_RET_ARGV(0);

   plhs[1] = zzmice_CreateIntScalar(found);

   MOVED( dvals, n, dvals_ret );
   mxFree( dvals );

   }




/*
   void              georec_c ( SpiceDouble         lon,
                                SpiceDouble         lat,
                                SpiceDouble         alt,
                                SpiceDouble         re,
                                SpiceDouble         f,
                                SpiceDouble         rectan[3] );
*/
void cspice_georec(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_lon;
   SpiceDouble        * vec_lat;
   SpiceDouble        * vec_alt;
   SpiceDouble        * vec_rectan;
   SpiceDouble          lon;
   SpiceDouble          lat;
   SpiceDouble          alt;
   SpiceDouble          re;
   SpiceDouble          f;
   SpiceDouble        * rectan;

   mwIndex              i;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "lon",    MiceDouble, 0, {0}, 1},
      { "lat",    MiceDouble, 0, {0}, 1},
      { "alt",    MiceDouble, 0, {0}, 1},
      { "re",     MiceDouble, 0, {0}, 0},
      { "f",      MiceDouble, 0, {0}, 0},
      { "rectan", MiceDouble, 1, {3}, 1},
      };

   check_arg_num( nrhs, nlhs, 5, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_lon    = A_DBL_ARGV(1);
   vec_lat    = A_DBL_ARGV(2);
   vec_alt    = A_DBL_ARGV(3);
   vec_rectan = A_DBL_RET_ARGV(0);

   lon        = *(vec_lon);
   lat        = *(vec_lat);
   alt        = *(vec_alt);
   re         = S_DBL_ARGV(4);
   f          = S_DBL_ARGV(5);
   rectan     =  (vec_rectan);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         lon    = *(vec_lon    + i*extra->offset[0]);
         lat    = *(vec_lat    + i*extra->offset[1]);
         alt    = *(vec_alt    + i*extra->offset[2]);
         rectan =  (vec_rectan + i*extra->offset[5]);

         georec_c(lon, lat, alt, re, f, rectan);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {

      georec_c(lon, lat, alt, re, f, rectan);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void getelm_c ( SpiceInt         frstyr,
                   SpiceInt         lineln,
                   const void     * lines,
                   SpiceDouble    * epoch,
                   SpiceDouble    * elems   );
*/
void cspice_getelm(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {
   SpiceInt             frstyr;
   SpiceChar            str [LINLEN + 1];
   SpiceChar         ** cvals = NULL;
   SpiceInt             cvals_len;
   SpiceInt             cvals_size;
   SpiceDouble        * epoch;
   SpiceDouble        * elems;

   char                 msg[1024];

   mxChar             * mx_str;

   mwIndex              i;
   SpiceInt             j;
   mwSize               count;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "frstyr",  MiceInt,      0, {  0 }, 0},
      { "lines",   MiceChar,     0, {  0 }, 1},
      { "epoch",   MiceDouble,   0, {  0 }, 0},
      { "elems",   MiceDouble,   1, { 10 }, 0},
      };

   check_arg_num( nrhs, nlhs, 2, 2 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   frstyr   = S_INT_ARGV(1);

   /*
   Confirm the input consists of two strings.
   */
   if (extra->count != 2 )
      {
      sprintf( msg,
               "MICE(INVALIDSIZE): TLE input argument "
               "must contain two (2) data lines." );

      mexErrMsgTxt(msg);
      }

   count = extra->count;

   mx_str = (mxChar *)mxGetChars(prhs[TWO_IN]);


   /*
   An input string has at most LINLEN characters
   so the maximum room needed is either extra->offset[0] +1 if that
   value less than LINLEN or LINLEN + 1 (for \n).
   */
   if( extra->offset[TWO_IN] > LINLEN )
      {
      cvals_len  = LINLEN + 1;
      }
   else
      {
      cvals_len  = extra->offset[TWO_OFF] + 1;
      }


   cvals_size = count;
   cvals      = alloc_SpiceString_C_array( cvals_len, cvals_size );

   CHECK_CALL_FAILURE( SCALAR );

   for ( i=0; i<count; i++)
      {

      /*
      Extract the string data, character by character, into
      CSPICE strings. The mx_str array stores the data in a column
      major format, we need to extract the data by rows.
      */
      for ( j=0; j<cvals_len - 1; j++)
         {
         str[j] = (char)mx_str[i + (count*j)];
         }

      str[cvals_len - 1] = '\0';

      strncpy( *cvals + i*cvals_len,
               str,
               cvals_len);
      }

   epoch    = A_DBL_RET_ARGV(0);
   elems    = A_DBL_RET_ARGV(1);

   getelm_c ( frstyr, cvals_len, *cvals, epoch, elems );
   CHECK_CALL_FAILURE_MEM( 1, cvals );

   /* Clean up temporary variables */
   free_SpiceString_C_array ( 1, cvals );

   /*
   Confirm the code released all allocated memory.
   */
   MICE_ALLOC_CHECK;

   }


/*
   void getfat_c ( ConstSpiceChar   * file,
                   SpiceInt           arclen,
                   SpiceInt           kertln,
                   SpiceChar        * arch,
                   SpiceChar        * kertyp   )
*/
void cspice_getfat(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            file   [DEFAULT_STR_LENGTH+1];
   SpiceChar            arch   [DEFAULT_STR_LENGTH+1];
   SpiceChar            kertyp [DEFAULT_STR_LENGTH+1];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "file",   MiceChar,    0, {0}, 0},
      { "arch",   MiceIgnore,  0, {0}, 0},
      { "kertyp", MiceIgnore,  0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 1, 2 );

   memset( arch, 0, default_str_size );
   memset( kertyp, 0, default_str_size );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], file, DEFAULT_STR_LENGTH);


   getfat_c ( file, DEFAULT_STR_LENGTH, DEFAULT_STR_LENGTH, arch, kertyp );
   CHECK_CALL_FAILURE(SCALAR);

   plhs[0] = mxCreateString(arch);
   plhs[1] = mxCreateString(kertyp);

   if ( (plhs[0] == NULL) || (plhs[1] == NULL) )
      {
      mexErrMsgTxt( "MICE(BUG): mxCreateString failed in cspice_getfat" );
      }

   }




/*
   void              getfov_c ( SpiceInt            instid,
                                SpiceInt            room,
                                SpiceInt            shapelen,
                                SpiceInt            framelen,
                                SpiceChar         * shape,
                                SpiceChar         * frame,
                                SpiceDouble         bsight [3],
                                SpiceInt          * n,
                                SpiceDouble         bounds [][3] );
*/
void cspice_getfov(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             instid;
   SpiceInt             room;
   SpiceChar            shape[DEFAULT_STR_LENGTH+1];
   SpiceChar            frame[DEFAULT_STR_LENGTH+1];
   SpiceDouble        * bsight;
   SpiceInt             n = 0;
   SpiceDouble        * bounds;
   SpiceDouble        * bounds_ret;

   mwSize               sizearray[2];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "instid",   MiceInt,    0, {0}, 0},
      { "room",     MiceInt,    0, {0}, 0},
      { "shape",    MiceChar,   0, {0}, 0},
      { "frame",    MiceChar,   0, {0}, 0},
      { "bsight",   MiceDouble, 1, {3}, 0},
      { "bounds",   MiceIgnore, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 2, 4 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   instid = S_INT_ARGV(1);
   room   = S_INT_ARGV(2);

   bsight = A_DBL_RET_ARGV(2);

   bounds = (SpiceDouble*)mxMalloc( 3 * room * sizeof(SpiceDouble) );
   memset( bounds,  0, 3 * room * sizeof(SpiceDouble) );

   getfov_c( instid,
             room,
             DEFAULT_STR_LENGTH,
             DEFAULT_STR_LENGTH,
             shape,
             frame,
             bsight,
             &n,
             (SpiceDouble(*)[3])bounds);

   /*
   Check for a failure signal. Free the memory assigned to 'bounds'
   before signaling a Matlab error.
   */
   if ( failed_c())
      {
      mxFree( bounds );

      /*
      The mice_fail call creates the error string then returns control
      to the MATLAB interpreter.
      */
      mice_fail(SCALAR);
      }

   if ( n > 0 )
      {
      plhs[0] = mxCreateString( shape );
      plhs[1] = mxCreateString( frame );

      /*
      Set the size for the numeric array as 3XN
      */
      sizearray[0] = 3;
      sizearray[1] = n;
      }
   else
      {

      /*
      No variables found matching the template. Set 'frame' and 'shape' to
      nulls.
      */
      plhs[0] = mxCreateString( "\0" );
      plhs[1] = mxCreateString( "\0" );

      sizearray[0] = 0;
      sizearray[1] = 0;
      }

   if ( (plhs[0] == NULL) || (plhs[1] == NULL) )
      {
      mexErrMsgTxt( "MICE(BUG): mxCreateString failed in cspice_getfov" );
      }

   plhs[3]    = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
   bounds_ret = A_DBL_RET_ARGV(3);

   /*
   Move the contents of 'bounds' to the return matrix 'bounds_ret'. On return
   to MATLAB the matrix will have dimension 3xN.
   */
   MOVED( bounds, 3*n, bounds_ret );
   mxFree( bounds );

   }




/*
   void getfvn_c ( ConstSpiceChar    * inst,
                   SpiceInt            room,
                   SpiceInt            shalen,
                   SpiceInt            fralen,
                   SpiceChar         * shape,
                   SpiceChar         * frame,
                   SpiceDouble         bsight [3],
                   SpiceInt          * n,
                   SpiceDouble         bounds [][3] )
*/
void cspice_getfvn(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            inst   [DEFAULT_STR_LENGTH+1];
   SpiceInt             room;
   SpiceChar            shape  [DEFAULT_STR_LENGTH+1];
   SpiceChar            frame  [DEFAULT_STR_LENGTH+1];
   SpiceDouble        * bsight;
   SpiceInt             n;
   SpiceDouble        * bounds;
   SpiceDouble        * ret_bounds;


   mwSize               sizearray[2];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "inst",    MiceChar,     0, {0},   0},
      { "room",    MiceInt,      0, {0},   0},
      { "shape",   MiceChar,     0, {0},   0},
      { "frame",   MiceChar,     0, {0},   0},
      { "bsight",  MiceDouble,   1, {3},   0},
      { "bounds",  MiceDouble,   2, {3,0}, 0},
      };

   check_arg_num( nrhs, nlhs, 2, 4 );

   memset( shape, 0, default_str_size );
   memset( frame, 0, default_str_size );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], inst, DEFAULT_STR_LENGTH);

   room     = S_INT_ARGV(2);

   bsight   = A_DBL_RET_ARGV(2);

   ret_bounds = (SpiceDouble*)mxMalloc( 3 * room * sizeof(SpiceDouble) );
   memset( ret_bounds,  0, 3 * room * sizeof(SpiceDouble) );

   getfvn_c ( inst,               room,  DEFAULT_STR_LENGTH,
              DEFAULT_STR_LENGTH, shape, frame,
              bsight,             &n,    (SpiceDouble(*)[3])ret_bounds );

   /*
   Check for a failure signal. Free the memory assigned to 'bounds'
   before signaling a Matlab error.
   */
   if ( failed_c())
      {
      mxFree( ret_bounds );

      /*
      The mice_fail call creates the error string then returns control
      to the MATLAB interpreter.
      */
      mice_fail(SCALAR);
      }

   plhs[0] = mxCreateString(shape);
   plhs[1] = mxCreateString(frame);

   if ( (plhs[0] == NULL) || (plhs[1] == NULL) )
      {
      mexErrMsgTxt( "MICE(BUG): mxCreateString failed in cspice_getfvn" );
      }

   /*
   Set the size for the numeric array as 3XN
   */
   sizearray[0] = 3;
   sizearray[1] = n;
   plhs[3]      = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
   bounds       = A_DBL_RET_ARGV(3);

   /*
   Move the contents of `bounds_ret' to the return matrix `bounds'. On return
   to MATLAB the matrix will have dimension 3xN.
   */
   MOVED( ret_bounds, 3*n, bounds );
   mxFree( ret_bounds );

   }




/*
   void              gfdist_c ( ConstSpiceChar     * target,
                                ConstSpiceChar     * abcorr,
                                ConstSpiceChar     * obsrvr,
                                ConstSpiceChar     * relate,
                                SpiceDouble          refval,
                                SpiceDouble          adjust,
                                SpiceDouble          step,
                                SpiceInt             nintvls,
                                SpiceCell          * cnfine,
                                SpiceCell          * result     )

*/
void cspice_gfdist(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            target [DEFAULT_STR_LENGTH+1];
   SpiceChar            abcorr [DEFAULT_STR_LENGTH+1];
   SpiceChar            obsrvr [DEFAULT_STR_LENGTH+1];
   SpiceChar            relate [DEFAULT_STR_LENGTH+1];
   SpiceDouble          refval;
   SpiceDouble          adjust;
   SpiceDouble          step;
   SpiceInt             nintvls;
   SpiceDouble        * cnfine;
   SpiceInt             size;
   SpiceDouble        * result;
   SpiceDouble        * result_f;

   mwSize               sizearray[2];

   SpiceInt             cnfine_size;

   /*
   Initialize the 'cnfine_cell' and 'result_cell' cells
   as double precision with zero size and zero cardinality.
   */
   SpiceCell           cnfine_cell = { SPICE_DP,
                                       0,
                                       0,
                                       0,
                                       SPICETRUE,
                                       SPICEFALSE,
                                       SPICEFALSE,
                                       NULL,
                                       NULL };

   SpiceCell           result_cell = { SPICE_DP,
                                       0,
                                       0,
                                       0,
                                       SPICETRUE,
                                       SPICEFALSE,
                                       SPICEFALSE,
                                       NULL,
                                       NULL };

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "target",  MiceChar,   0, {0}, 0},
      { "abcorr",  MiceChar,   0, {0}, 0},
      { "obsrvr",  MiceChar,   0, {0}, 0},
      { "relate",  MiceChar,   0, {0}, 0},
      { "refval",  MiceDouble, 0, {0}, 0},
      { "adjust",  MiceDouble, 0, {0}, 0},
      { "step",    MiceDouble, 0, {0}, 0},
      { "nintvls", MiceInt,    0, {0}, 0},
      { "cnfine",  MiceWin,    1, {0}, 0},
      { "result",  MiceIgnore, 0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 9, 1);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], target,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], abcorr,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[3], obsrvr,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[4], relate,  DEFAULT_STR_LENGTH);

   refval  = S_DBL_ARGV(5);
   adjust  = S_DBL_ARGV(6);
   step    = S_DBL_ARGV(7);
   nintvls = S_INT_ARGV(8);

   cnfine = (SpiceDouble*)mxGetData(prhs[9]);

   size = nintvls*2.;

   /*
   The size of array 'cnfine' includes an addition SPICE_CELL_CTRLSZ
   zero elements appended to the arrays. Calculate the size of
   'cnfine' without the append size.
   */
   cnfine_size = mxGetNumberOfElements( prhs[9] ) - SPICE_CELL_CTRLSZ;

   /*
   Set the struct fields to fully describe the 'cnfine_cell' cell. A Mice
   window implementation has size equal to cardinality.
   */
   cnfine_cell.size = cnfine_size;
   cnfine_cell.card = cnfine_size;
   cnfine_cell.base = cnfine;
   cnfine_cell.data = &cnfine[SPICE_CELL_CTRLSZ];

   /*
   mxMalloc returns to top level on error.
   */
   result = (SpiceDouble*)
            mxMalloc( (size + SPICE_CELL_CTRLSZ)*sizeof(SpiceDouble)  );


   /*
   Set the struct fields to initialize the 'result_cell' cell.
   The cardinality remains zero as this assignment occurs prior
   to use.
   */
   result_cell.size = size;
   result_cell.base = result;
   result_cell.data = &result[SPICE_CELL_CTRLSZ];

   (void) gfdist_c ( target,
                     abcorr,
                     obsrvr,
                     relate,
                     refval,
                     adjust,
                     step,
                     nintvls,
                     &cnfine_cell,
                     &result_cell );

   /*
   Check for a failure signal. Free the memory assigned to 'result'
   before signaling a Matlab error.
   */
   if ( failed_c())
      {
      mxFree( result );
      mice_fail(SCALAR);
      }

   /*
   Create an output array CARDx1.
   */
   sizearray[0] = card_c( &result_cell );
   sizearray[1] = 1;

   plhs[0]  = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
   result_f = A_DBL_RET_ARGV(0);

   /*
   Copy the data contents of 'result' to 'result_f'. The set of window data
   starts at 'result' array index SPICE_CELL_CTRLSZ and contains 'sizearray[0]'
   elements.
   */
   MOVED( result + SPICE_CELL_CTRLSZ, sizearray[0], result_f );

   mxFree( result );

   }




/*
   void              gfilum_c ( ConstSpiceChar     * method,
                                ConstSpiceChar     * angtyp,
                                ConstSpiceChar     * target,
                                ConstSpiceChar     * illmn,
                                ConstSpiceChar     * fixref,
                                ConstSpiceChar     * abcorr,
                                ConstSpiceChar     * obsrvr,
                                ConstSpiceDouble     spoint [3],
                                ConstSpiceChar     * relate,
                                SpiceDouble          refval,
                                SpiceDouble          adjust,
                                SpiceDouble          step,
                                SpiceInt             nintvls,
                                SpiceCell          * cnfine,
                                SpiceCell          * result     )
*/
void cspice_gfilum(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            method [DEFAULT_STR_LENGTH+1];
   SpiceChar            angtyp [DEFAULT_STR_LENGTH+1];
   SpiceChar            target [DEFAULT_STR_LENGTH+1];
   SpiceChar            illmn  [DEFAULT_STR_LENGTH+1];
   SpiceChar            fixref [DEFAULT_STR_LENGTH+1];
   SpiceChar            abcorr [DEFAULT_STR_LENGTH+1];
   SpiceChar            obsrvr [DEFAULT_STR_LENGTH+1];
   SpiceDouble        * spoint;
   SpiceChar            relate [DEFAULT_STR_LENGTH+1];
   SpiceDouble          refval;
   SpiceDouble          adjust;
   SpiceDouble          step;
   SpiceInt             nintvls;
   SpiceDouble        * cnfine;
   SpiceInt             size;
   SpiceDouble        * result;
   SpiceDouble        * result_f;

   mwSize               sizearray[2];

   SpiceInt             cnfine_size;

   /*
   Initialize the 'cnfine_cell' and 'result_cell' cells
   as double precision with zero size and zero cardinality.
   */
   SpiceCell           cnfine_cell = { SPICE_DP,
                                       0,
                                       0,
                                       0,
                                       SPICETRUE,
                                       SPICEFALSE,
                                       SPICEFALSE,
                                       NULL,
                                       NULL };

   SpiceCell           result_cell = { SPICE_DP,
                                       0,
                                       0,
                                       0,
                                       SPICETRUE,
                                       SPICEFALSE,
                                       SPICEFALSE,
                                       NULL,
                                       NULL };

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "method",  MiceChar,   0, {0}, 0},
      { "angtyp",  MiceChar,   0, {0}, 0},
      { "target",  MiceChar,   0, {0}, 0},
      { "illmn",   MiceChar,   0, {0}, 0},
      { "fixref",  MiceChar,   0, {0}, 0},
      { "abcorr",  MiceChar,   0, {0}, 0},
      { "obsrvr",  MiceChar,   0, {0}, 0},
      { "spoint",  MiceDouble, 1, {3}, 0},
      { "relate",  MiceChar,   0, {0}, 0},
      { "refval",  MiceDouble, 0, {0}, 0},
      { "adjust",  MiceDouble, 0, {0}, 0},
      { "step",    MiceDouble, 0, {0}, 0},
      { "nintvls", MiceInt,    0, {0}, 0},
      { "cnfine",  MiceWin,    1, {0}, 0},
      { "result",  MiceIgnore, 0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 14, 1);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], method, DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], angtyp, DEFAULT_STR_LENGTH);
   mxGetString(prhs[3], target, DEFAULT_STR_LENGTH);
   mxGetString(prhs[4], illmn,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[5], fixref, DEFAULT_STR_LENGTH);
   mxGetString(prhs[6], abcorr, DEFAULT_STR_LENGTH);
   mxGetString(prhs[7], obsrvr, DEFAULT_STR_LENGTH);

   spoint = A_DBL_ARGV(8);

   mxGetString(prhs[9], relate,  DEFAULT_STR_LENGTH);

   refval  = S_DBL_ARGV(10);
   adjust  = S_DBL_ARGV(11);
   step    = S_DBL_ARGV(12);
   nintvls = S_INT_ARGV(13);

   cnfine = (SpiceDouble*)mxGetData(prhs[14]);

   size = nintvls*2.;

   /*
   The size of array 'cnfine' includes an addition SPICE_CELL_CTRLSZ
   zero elements appended to the arrays. Calculate the size of
   'cnfine' without the append size.
   */
   cnfine_size = mxGetNumberOfElements( prhs[14] ) - SPICE_CELL_CTRLSZ;

   /*
   Set the struct fields to fully describe the 'cnfine_cell' cell. A Mice
   window implementation has size equal to cardinality.
   */
   cnfine_cell.size = cnfine_size;
   cnfine_cell.card = cnfine_size;
   cnfine_cell.base = cnfine;
   cnfine_cell.data = &cnfine[SPICE_CELL_CTRLSZ];

   /*
   mxMalloc returns to top level on error.
   */
   result = (SpiceDouble*)
            mxMalloc( (size + SPICE_CELL_CTRLSZ)*sizeof(SpiceDouble)  );


   /*
   Set the struct fields to initialize the 'result_cell' cell.
   The cardinality remains zero as this assignment occurs prior
   to use.
   */
   result_cell.size = size;
   result_cell.base = result;
   result_cell.data = &result[SPICE_CELL_CTRLSZ];

   (void) gfilum_c ( method,
                     angtyp,
                     target,
                     illmn,
                     fixref,
                     abcorr,
                     obsrvr,
                     spoint,
                     relate,
                     refval,
                     adjust,
                     step,
                     nintvls,
                     &cnfine_cell,
                     &result_cell  );

   /*
   Check for a failure signal. Free the memory assigned to 'result'
   before signaling a Matlab error.
   */
   if ( failed_c())
      {
      mxFree( result );
      mice_fail(SCALAR);
      }

   /*
   Create an output array CARDx1.
   */
   sizearray[0] = card_c( &result_cell );
   sizearray[1] = 1;

   plhs[0]  = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
   result_f = A_DBL_RET_ARGV(0);

   /*
   Copy the data contents of 'result' to 'result_f'. The set of window data
   starts at 'result' array index SPICE_CELL_CTRLSZ and contains 'sizearray[0]'
   elements.
   */
   MOVED( result + SPICE_CELL_CTRLSZ, sizearray[0], result_f );

   mxFree( result );

   }




/*
   void              gfoclt_c ( ConstSpiceChar   * occtyp,
                                ConstSpiceChar   * front,
                                ConstSpiceChar   * fshape,
                                ConstSpiceChar   * fframe,
                                ConstSpiceChar   * back,
                                ConstSpiceChar   * bshape,
                                ConstSpiceChar   * bframe,
                                ConstSpiceChar   * abcorr,
                                ConstSpiceChar   * obsrvr,
                                SpiceDouble        step,
                                SpiceCell        * cnfine,
                                SpiceCell        * result )

*/
void cspice_gfoclt(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            occtyp [DEFAULT_STR_LENGTH+1];
   SpiceChar            front  [DEFAULT_STR_LENGTH+1];
   SpiceChar            fshape [DEFAULT_STR_LENGTH+1];
   SpiceChar            fframe [DEFAULT_STR_LENGTH+1];
   SpiceChar            back   [DEFAULT_STR_LENGTH+1];
   SpiceChar            bshape [DEFAULT_STR_LENGTH+1];
   SpiceChar            bframe [DEFAULT_STR_LENGTH+1];
   SpiceChar            abcorr [DEFAULT_STR_LENGTH+1];
   SpiceChar            obsrvr [DEFAULT_STR_LENGTH+1];
   SpiceDouble          step;
   SpiceDouble        * cnfine;
   SpiceInt             size;
   SpiceDouble        * result;
   SpiceDouble        * result_f;

   mwSize               sizearray[2];

   SpiceInt             cnfine_size;

   /*
   Initialize the 'cnfine_cell' and 'result_cell' cells
   as double precision with zero size and zero cardinality.
   */
   SpiceCell           cnfine_cell = { SPICE_DP,
                                       0,
                                       0,
                                       0,
                                       SPICETRUE,
                                       SPICEFALSE,
                                       SPICEFALSE,
                                       NULL,
                                       NULL };

   SpiceCell           result_cell = { SPICE_DP,
                                       0,
                                       0,
                                       0,
                                       SPICETRUE,
                                       SPICEFALSE,
                                       SPICEFALSE,
                                       NULL,
                                       NULL };

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "occtyp",  MiceChar,   0, {0}, 0},
      { "front",   MiceChar,   0, {0}, 0},
      { "fshape",  MiceChar,   0, {0}, 0},
      { "fframe",  MiceChar,   0, {0}, 0},
      { "back",    MiceChar,   0, {0}, 0},
      { "bshape",  MiceChar,   0, {0}, 0},
      { "bframe",  MiceChar,   0, {0}, 0},
      { "abcorr",  MiceChar,   0, {0}, 0},
      { "obsrvr",  MiceChar,   0, {0}, 0},
      { "step",    MiceDouble, 0, {0}, 0},
      { "cnfine",  MiceWin,    1, {0}, 0},
      { "nintvls", MiceInt,    0, {0}, 0},
      { "result",  MiceIgnore, 0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 12, 1);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], occtyp,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], front,   DEFAULT_STR_LENGTH);
   mxGetString(prhs[3], fshape,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[4], fframe,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[5], back,    DEFAULT_STR_LENGTH);
   mxGetString(prhs[6], bshape,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[7], bframe,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[8], abcorr,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[9], obsrvr,  DEFAULT_STR_LENGTH);

   step = S_DBL_ARGV(10);

   cnfine = (SpiceDouble*)mxGetData(prhs[11]);

   /*
   `size' defines the number of intervals for the `result' window,
   so double the value of `size' since an interval consists of
   two double precision values.
   */
   size = S_INT_ARGV(12) * 2;

   /*
   The size of array 'cnfine' includes an addition SPICE_CELL_CTRLSZ
   zero elements appended to the arrays. Calculate the size of
   'cnfine' without the append size.
   */
   cnfine_size = mxGetNumberOfElements( prhs[11] ) - SPICE_CELL_CTRLSZ;

   /*
   Set the struct fields to fully describe the 'cnfine_cell' cell. A Mice
   window implementation has size equal to cardinality.
   */
   cnfine_cell.size = cnfine_size;
   cnfine_cell.card = cnfine_size;
   cnfine_cell.base = cnfine;
   cnfine_cell.data = &cnfine[SPICE_CELL_CTRLSZ];

   /*
   mxMalloc returns to top level on error.
   */
   result = (SpiceDouble*)
            mxMalloc( (size + SPICE_CELL_CTRLSZ)*sizeof(SpiceDouble)  );


   /*
   Set the struct fields to initialize the 'result_cell' cell.
   The cardinality remains zero as this assignment occurs prior
   to use.
   */
   result_cell.size = size;
   result_cell.base = result;
   result_cell.data = &result[SPICE_CELL_CTRLSZ];

   (void) gfoclt_c ( occtyp,
                     front,
                     fshape,
                     fframe,
                     back,
                     bshape,
                     bframe,
                     abcorr,
                     obsrvr,
                     step,
                     &cnfine_cell,
                     &result_cell  );


   /*
   Check for a failure signal. Free the memory assigned to 'result'
   before signaling a Matlab error.
   */
   if ( failed_c())
      {
      mxFree( result );
      mice_fail(SCALAR);
      }

   /*
   Create an output array CARDx1.
   */
   sizearray[0] = card_c( &result_cell );
   sizearray[1] = 1;

   plhs[0]  = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
   result_f = A_DBL_RET_ARGV(0);

   /*
   Copy the data contents of 'result' to 'result_f'. The set of window data
   starts at 'result' array index SPICE_CELL_CTRLSZ and contains 'sizearray[0]'
   elements.
   */
   MOVED( result + SPICE_CELL_CTRLSZ, sizearray[0], result_f );

   mxFree( result );

   }




/*
   void              gfpa_c ( ConstSpiceChar     * target,
                              ConstSpiceChar     * illmn,
                              ConstSpiceChar     * abcorr,
                              ConstSpiceChar     * obsrvr,
                              ConstSpiceChar     * relate,
                              SpiceDouble          refval,
                              SpiceDouble          adjust,
                              SpiceDouble          step,
                              SpiceInt             nintvls,
                              SpiceCell          * cnfine,
                              SpiceCell          * result     )

*/
void cspice_gfpa(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            target [DEFAULT_STR_LENGTH+1];
   SpiceChar            illmn  [DEFAULT_STR_LENGTH+1];
   SpiceChar            abcorr [DEFAULT_STR_LENGTH+1];
   SpiceChar            obsrvr [DEFAULT_STR_LENGTH+1];
   SpiceChar            relate [DEFAULT_STR_LENGTH+1];
   SpiceDouble          refval;
   SpiceDouble          adjust;
   SpiceDouble          step;
   SpiceInt             nintvls;
   SpiceDouble        * cnfine;
   SpiceInt             size;
   SpiceDouble        * result;
   SpiceDouble        * result_f;

   mwSize               sizearray[2];

   SpiceInt             cnfine_size;

   /*
   Initialize the 'cnfine_cell' and 'result_cell' cells
   as double precision with zero size and zero cardinality.
   */
   SpiceCell           cnfine_cell = { SPICE_DP,
                                       0,
                                       0,
                                       0,
                                       SPICETRUE,
                                       SPICEFALSE,
                                       SPICEFALSE,
                                       NULL,
                                       NULL };

   SpiceCell           result_cell = { SPICE_DP,
                                       0,
                                       0,
                                       0,
                                       SPICETRUE,
                                       SPICEFALSE,
                                       SPICEFALSE,
                                       NULL,
                                       NULL };

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "target",  MiceChar,   0, {0}, 0},
      { "illmn",   MiceChar,   0, {0}, 0},
      { "abcorr",  MiceChar,   0, {0}, 0},
      { "obsrvr",  MiceChar,   0, {0}, 0},
      { "relate",  MiceChar,   0, {0}, 0},
      { "refval",  MiceDouble, 0, {0}, 0},
      { "adjust",  MiceDouble, 0, {0}, 0},
      { "step",    MiceDouble, 0, {0}, 0},
      { "nintvls", MiceInt,    0, {0}, 0},
      { "cnfine",  MiceWin,    1, {0}, 0},
      { "result",  MiceIgnore, 0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 10, 1);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], target,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], illmn,   DEFAULT_STR_LENGTH);
   mxGetString(prhs[3], abcorr,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[4], obsrvr,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[5], relate,  DEFAULT_STR_LENGTH);

   refval  = S_DBL_ARGV(6);
   adjust  = S_DBL_ARGV(7);
   step    = S_DBL_ARGV(8);
   nintvls = S_INT_ARGV(9);

   cnfine = (SpiceDouble*)mxGetData(prhs[10]);

   size = nintvls*2.;

   /*
   The size of array 'cnfine' includes an addition SPICE_CELL_CTRLSZ
   zero elements appended to the arrays. Calculate the size of
   'cnfine' without the append size.
   */
   cnfine_size = mxGetNumberOfElements( prhs[10] ) - SPICE_CELL_CTRLSZ;

   /*
   Set the struct fields to fully describe the 'cnfine_cell' cell. A Mice
   window implementation has size equal to cardinality.
   */
   cnfine_cell.size = cnfine_size;
   cnfine_cell.card = cnfine_size;
   cnfine_cell.base = cnfine;
   cnfine_cell.data = &cnfine[SPICE_CELL_CTRLSZ];

   /*
   mxMalloc returns to top level on error.
   */
   result = (SpiceDouble*)
            mxMalloc( (size + SPICE_CELL_CTRLSZ)*sizeof(SpiceDouble)  );


   /*
   Set the struct fields to initialize the 'result_cell' cell.
   The cardinality remains zero as this assignment occurs prior
   to use.
   */
   result_cell.size = size;
   result_cell.base = result;
   result_cell.data = &result[SPICE_CELL_CTRLSZ];

   (void) gfpa_c ( target,
                   illmn,
                   abcorr,
                   obsrvr,
                   relate,
                   refval,
                   adjust,
                   step,
                   nintvls,
                   &cnfine_cell,
                   &result_cell );

   /*
   Check for a failure signal. Free the memory assigned to 'result'
   before signaling a Matlab error.
   */
   if ( failed_c())
      {
      mxFree( result );
      mice_fail(SCALAR);
      }

   /*
   Create an output array CARDx1.
   */
   sizearray[0] = card_c( &result_cell );
   sizearray[1] = 1;

   plhs[0]  = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
   result_f = A_DBL_RET_ARGV(0);

   /*
   Copy the data contents of 'result' to 'result_f'. The set of window data
   starts at 'result' array index SPICE_CELL_CTRLSZ and contains 'sizearray[0]'
   elements.
   */
   MOVED( result + SPICE_CELL_CTRLSZ, sizearray[0], result_f );

   mxFree( result );

   }




/*
   void              gfposc_c ( ConstSpiceChar     * target,
                                ConstSpiceChar     * frame,
                                ConstSpiceChar     * abcorr,
                                ConstSpiceChar     * obsrvr,
                                ConstSpiceChar     * crdsys,
                                ConstSpiceChar     * coord,
                                ConstSpiceChar     * relate,
                                SpiceDouble          refval,
                                SpiceDouble          adjust,
                                SpiceDouble          step,
                                SpiceInt             nintvls,
                                SpiceCell          * cnfine,
                                SpiceCell          * result  );

*/
void cspice_gfposc(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            target [DEFAULT_STR_LENGTH+1];
   SpiceChar            frame  [DEFAULT_STR_LENGTH+1];
   SpiceChar            abcorr [DEFAULT_STR_LENGTH+1];
   SpiceChar            obsrvr [DEFAULT_STR_LENGTH+1];
   SpiceChar            crdsys [DEFAULT_STR_LENGTH+1];
   SpiceChar            coord  [DEFAULT_STR_LENGTH+1];
   SpiceChar            relate [DEFAULT_STR_LENGTH+1];
   SpiceDouble          refval;
   SpiceDouble          adjust;
   SpiceDouble          step;
   SpiceInt             nintvls;
   SpiceDouble        * cnfine;
   SpiceInt             size;
   SpiceDouble        * result;
   SpiceDouble        * result_f;

   mwSize               sizearray[2];

   SpiceInt             cnfine_size;

   /*
   Initialize the 'cnfine_cell' and 'result_cell' cells
   as double precision with zero size and zero cardinality.
   */
   SpiceCell           cnfine_cell = { SPICE_DP,
                                       0,
                                       0,
                                       0,
                                       SPICETRUE,
                                       SPICEFALSE,
                                       SPICEFALSE,
                                       NULL,
                                       NULL };

   SpiceCell           result_cell = { SPICE_DP,
                                       0,
                                       0,
                                       0,
                                       SPICETRUE,
                                       SPICEFALSE,
                                       SPICEFALSE,
                                       NULL,
                                       NULL };

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "target",  MiceChar,   0, {0}, 0},
      { "frame",   MiceChar,   0, {0}, 0},
      { "abcorr",  MiceChar,   0, {0}, 0},
      { "obsrvr",  MiceChar,   0, {0}, 0},
      { "crdsys",  MiceChar,   0, {0}, 0},
      { "coord",   MiceChar,   0, {0}, 0},
      { "relate",  MiceChar,   0, {0}, 0},
      { "refval",  MiceDouble, 0, {0}, 0},
      { "adjust",  MiceDouble, 0, {0}, 0},
      { "step",    MiceDouble, 0, {0}, 0},
      { "nintvls", MiceInt,    0, {0}, 0},
      { "cnfine",  MiceWin,    1, {0}, 0},
      { "result",  MiceIgnore, 0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 12, 1);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], target,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], frame,   DEFAULT_STR_LENGTH);
   mxGetString(prhs[3], abcorr,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[4], obsrvr,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[5], crdsys,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[6], coord,   DEFAULT_STR_LENGTH);
   mxGetString(prhs[7], relate,  DEFAULT_STR_LENGTH);

   refval  = S_DBL_ARGV(8);
   adjust  = S_DBL_ARGV(9);
   step    = S_DBL_ARGV(10);
   nintvls = S_INT_ARGV(11);

   cnfine = (SpiceDouble*)mxGetData(prhs[12]);

   size = nintvls*2.;

   /*
   The size of array 'cnfine' includes an addition SPICE_CELL_CTRLSZ
   zero elements appended to the arrays. Calculate the size of
   'cnfine' without the append size.
   */
   cnfine_size = mxGetNumberOfElements( prhs[12] ) - SPICE_CELL_CTRLSZ;

   /*
   Set the struct fields to fully describe the 'cnfine_cell' cell. A Mice
   window implementation has size equal to cardinality.
   */
   cnfine_cell.size = cnfine_size;
   cnfine_cell.card = cnfine_size;
   cnfine_cell.base = cnfine;
   cnfine_cell.data = &cnfine[SPICE_CELL_CTRLSZ];

   /*
   mxMalloc returns to top level on error.
   */
   result = (SpiceDouble*)
            mxMalloc( (size + SPICE_CELL_CTRLSZ)*sizeof(SpiceDouble)  );


   /*
   Set the struct fields to initialize the 'result_cell' cell.
   The cardinality remains zero as this assignment occurs prior
   to use.
   */
   result_cell.size = size;
   result_cell.base = result;
   result_cell.data = &result[SPICE_CELL_CTRLSZ];

   (void) gfposc_c ( target,
                     frame,
                     abcorr,
                     obsrvr,
                     crdsys,
                     coord,
                     relate,
                     refval,
                     adjust,
                     step,
                     nintvls,
                     &cnfine_cell,
                     &result_cell  );


   /*
   Check for a failure signal. Free the memory assigned to 'result'
   before signaling a Matlab error.
   */
   if ( failed_c())
      {
      mxFree( result );
      mice_fail(SCALAR);
      }

   /*
   Create an output array CARDx1.
   */
   sizearray[0] = card_c( &result_cell );
   sizearray[1] = 1;

   plhs[0]  = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
   result_f = A_DBL_RET_ARGV(0);

   /*
   Copy the data contents of 'result' to 'result_f'. The set of window data
   starts at 'result' array index SPICE_CELL_CTRLSZ and contains 'sizearray[0]'
   elements.
   */
   MOVED( result + SPICE_CELL_CTRLSZ, sizearray[0], result_f );

   mxFree( result );

   }




/*
   void              gfrfov_c ( ConstSpiceChar    * inst,
                                ConstSpiceDouble    raydir [3],
                                ConstSpiceChar    * rframe,
                                ConstSpiceChar    * abcorr,
                                ConstSpiceChar    * obsrvr,
                                SpiceDouble         step,
                                SpiceCell         * cnfine,
                                SpiceCell         * result     );
*/
void cspice_gfrfov(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            inst   [DEFAULT_STR_LENGTH+1];
   SpiceDouble        * raydir;
   SpiceChar            rframe [DEFAULT_STR_LENGTH+1];
   SpiceChar            abcorr [DEFAULT_STR_LENGTH+1];
   SpiceChar            obsrvr [DEFAULT_STR_LENGTH+1];
   SpiceDouble          step;
   SpiceDouble        * cnfine;
   SpiceInt             size;
   SpiceDouble        * result;
   SpiceDouble        * result_f;

   mwSize               sizearray[2];

   SpiceInt             cnfine_size;

   /*
   Initialize the 'cnfine_cell' and 'result_cell' cells
   as double precision with zero size and zero cardinality.
   */
   SpiceCell           cnfine_cell = { SPICE_DP,
                                       0,
                                       0,
                                       0,
                                       SPICETRUE,
                                       SPICEFALSE,
                                       SPICEFALSE,
                                       NULL,
                                       NULL };

   SpiceCell           result_cell = { SPICE_DP,
                                       0,
                                       0,
                                       0,
                                       SPICETRUE,
                                       SPICEFALSE,
                                       SPICEFALSE,
                                       NULL,
                                       NULL };

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "inst",    MiceChar,   0, {0}, 0},
      { "raydir",  MiceDouble, 1, {3}, 0},
      { "rframe",  MiceChar,   0, {0}, 0},
      { "abcorr",  MiceChar,   0, {0}, 0},
      { "obsrvr",  MiceChar,   0, {0}, 0},
      { "step",    MiceDouble, 0, {0}, 0},
      { "cnfine",  MiceWin,    1, {0}, 0},
      { "nintvls", MiceInt,    0, {0}, 0},
      { "result",  MiceIgnore, 0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 8, 1);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], inst,   DEFAULT_STR_LENGTH);

   raydir = A_DBL_ARGV(2);

   mxGetString(prhs[3], rframe, DEFAULT_STR_LENGTH);
   mxGetString(prhs[4], abcorr, DEFAULT_STR_LENGTH);
   mxGetString(prhs[5], obsrvr, DEFAULT_STR_LENGTH);

   step   = S_DBL_ARGV(6);

   cnfine = (SpiceDouble*)mxGetData(prhs[7]);

   /*
   `size' defines the number of intervals for the `result' window,
   so double the value of `size' since an interval consists of
   two double precision values.
   */
   size   = S_INT_ARGV(8) * 2;

   /*
   The size of array 'cnfine' includes an addition SPICE_CELL_CTRLSZ
   zero elements appended to the arrays. Calculate the size of
   'cnfine' without the append size.
   */
   cnfine_size = mxGetNumberOfElements( prhs[7] ) - SPICE_CELL_CTRLSZ;

   /*
   Set the struct fields to fully describe the 'cnfine_cell' cell. A Mice
   window implementation has size equal to cardinality.
   */
   cnfine_cell.size = cnfine_size;
   cnfine_cell.card = cnfine_size;
   cnfine_cell.base = cnfine;
   cnfine_cell.data = &cnfine[SPICE_CELL_CTRLSZ];

   /*
   mxMalloc returns to top level on error.
   */
   result = (SpiceDouble*)
            mxMalloc( (size + SPICE_CELL_CTRLSZ)*sizeof(SpiceDouble)  );


   /*
   Set the struct fields to initialize the 'result_cell' cell.
   The cardinality remains zero as this assignment occurs prior
   to use.
   */
   result_cell.size = size;
   result_cell.base = result;
   result_cell.data = &result[SPICE_CELL_CTRLSZ];

   (void) gfrfov_c ( inst,
                     raydir,
                     rframe,
                     abcorr,
                     obsrvr,
                     step,
                     &cnfine_cell,
                     &result_cell  );

   /*
   Check for a failure signal. Free the memory assigned to 'result'
   before signaling a Matlab error.
   */
   if ( failed_c())
      {
      mxFree( result );
      mice_fail(SCALAR);
      }

   /*
   Create an output array CARDx1.
   */
   sizearray[0] = card_c( &result_cell );
   sizearray[1] = 1;

   plhs[0]  = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
   result_f = A_DBL_RET_ARGV(0);

   /*
   Copy the data contents of 'result' to 'result_f'. The set of window data
   starts at 'result' array index SPICE_CELL_CTRLSZ and contains 'sizearray[0]'
   elements.
   */
   MOVED( result + SPICE_CELL_CTRLSZ, sizearray[0], result_f );

   mxFree( result );

   }




/*
   void              gfrr_c ( ConstSpiceChar     * target,
                              ConstSpiceChar     * abcorr,
                              ConstSpiceChar     * obsrvr,
                              ConstSpiceChar     * relate,
                              SpiceDouble          refval,
                              SpiceDouble          adjust,
                              SpiceDouble          step,
                              SpiceInt             nintvls,
                              SpiceCell          * cnfine,
                              SpiceCell          * result  )

*/
void cspice_gfrr(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            target [DEFAULT_STR_LENGTH+1];
   SpiceChar            abcorr [DEFAULT_STR_LENGTH+1];
   SpiceChar            obsrvr [DEFAULT_STR_LENGTH+1];
   SpiceChar            relate [DEFAULT_STR_LENGTH+1];
   SpiceDouble          refval;
   SpiceDouble          adjust;
   SpiceDouble          step;
   SpiceInt             nintvls;
   SpiceDouble        * cnfine;
   SpiceInt             size;
   SpiceDouble        * result;
   SpiceDouble        * result_f;

   mwSize               sizearray[2];

   SpiceInt             cnfine_size;

   /*
   Initialize the 'cnfine_cell' and 'result_cell' cells
   as double precision with zero size and zero cardinality.
   */
   SpiceCell           cnfine_cell = { SPICE_DP,
                                       0,
                                       0,
                                       0,
                                       SPICETRUE,
                                       SPICEFALSE,
                                       SPICEFALSE,
                                       NULL,
                                       NULL };

   SpiceCell           result_cell = { SPICE_DP,
                                       0,
                                       0,
                                       0,
                                       SPICETRUE,
                                       SPICEFALSE,
                                       SPICEFALSE,
                                       NULL,
                                       NULL };

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "target",  MiceChar,   0, {0}, 0},
      { "abcorr",  MiceChar,   0, {0}, 0},
      { "obsrvr",  MiceChar,   0, {0}, 0},
      { "relate",  MiceChar,   0, {0}, 0},
      { "refval",  MiceDouble, 0, {0}, 0},
      { "adjust",  MiceDouble, 0, {0}, 0},
      { "step",    MiceDouble, 0, {0}, 0},
      { "nintvls", MiceInt,    0, {0}, 0},
      { "cnfine",  MiceWin,    1, {0}, 0},
      { "result",  MiceIgnore, 0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 9, 1);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], target,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], abcorr,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[3], obsrvr,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[4], relate,  DEFAULT_STR_LENGTH);

   refval  = S_DBL_ARGV(5);
   adjust  = S_DBL_ARGV(6);
   step    = S_DBL_ARGV(7);
   nintvls = S_INT_ARGV(8);

   cnfine = (SpiceDouble*)mxGetData(prhs[9]);

   size = nintvls*2.;

   /*
   The size of array 'cnfine' includes an addition SPICE_CELL_CTRLSZ
   zero elements appended to the arrays. Calculate the size of
   'cnfine' without the append size.
   */
   cnfine_size = mxGetNumberOfElements( prhs[9] ) - SPICE_CELL_CTRLSZ;

   /*
   Set the struct fields to fully describe the 'cnfine_cell' cell. A Mice
   window implementation has size equal to cardinality.
   */
   cnfine_cell.size = cnfine_size;
   cnfine_cell.card = cnfine_size;
   cnfine_cell.base = cnfine;
   cnfine_cell.data = &cnfine[SPICE_CELL_CTRLSZ];

   /*
   mxMalloc returns to top level on error.
   */
   result = (SpiceDouble*)
            mxMalloc( (size + SPICE_CELL_CTRLSZ)*sizeof(SpiceDouble)  );


   /*
   Set the struct fields to initialize the 'result_cell' cell.
   The cardinality remains zero as this assignment occurs prior
   to use.
   */
   result_cell.size = size;
   result_cell.base = result;
   result_cell.data = &result[SPICE_CELL_CTRLSZ];

   (void) gfrr_c ( target,
                   abcorr,
                   obsrvr,
                   relate,
                   refval,
                   adjust,
                   step,
                   nintvls,
                   &cnfine_cell,
                   &result_cell );

   /*
   Check for a failure signal. Free the memory assigned to 'result'
   before signaling a Matlab error.
   */
   if ( failed_c())
      {
      mxFree( result );
      mice_fail(SCALAR);
      }

   /*
   Create an output array CARDx1.
   */
   sizearray[0] = card_c( &result_cell );
   sizearray[1] = 1;

   plhs[0]  = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
   result_f = A_DBL_RET_ARGV(0);

   /*
   Copy the data contents of 'result' to 'result_f'. The set of window data
   starts at 'result' array index SPICE_CELL_CTRLSZ and contains 'sizearray[0]'
   elements.
   */
   MOVED( result + SPICE_CELL_CTRLSZ, sizearray[0], result_f );

   mxFree( result );

   }




/*
   void              gfsep_c (  ConstSpiceChar     * targ1,
                                ConstSpiceChar     * shape1,
                                ConstSpiceChar     * frame1,
                                ConstSpiceChar     * targ2,
                                ConstSpiceChar     * shape2,
                                ConstSpiceChar     * frame2,
                                ConstSpiceChar     * abcorr,
                                ConstSpiceChar     * obsrvr,
                                ConstSpiceChar     * relate,
                                SpiceDouble          refval,
                                SpiceDouble          adjust,
                                SpiceDouble          step,
                                SpiceInt             nintvls,
                                SpiceCell          * cnfine,
                                SpiceCell          * result  )

*/
void cspice_gfsep(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            targ1  [DEFAULT_STR_LENGTH+1];
   SpiceChar            shape1 [DEFAULT_STR_LENGTH+1];
   SpiceChar            frame1 [DEFAULT_STR_LENGTH+1];
   SpiceChar            targ2  [DEFAULT_STR_LENGTH+1];
   SpiceChar            shape2 [DEFAULT_STR_LENGTH+1];
   SpiceChar            frame2 [DEFAULT_STR_LENGTH+1];
   SpiceChar            abcorr [DEFAULT_STR_LENGTH+1];
   SpiceChar            obsrvr [DEFAULT_STR_LENGTH+1];
   SpiceChar            relate [DEFAULT_STR_LENGTH+1];
   SpiceDouble          refval;
   SpiceDouble          adjust;
   SpiceDouble          step;
   SpiceInt             nintvls;
   SpiceDouble        * cnfine;
   SpiceInt             size;
   SpiceDouble        * result;
   SpiceDouble        * result_f;

   mwSize               sizearray[2];

   SpiceInt             cnfine_size;

   /*
   Initialize the 'cnfine_cell' and 'result_cell' cells
   as double precision with zero size and zero cardinality.
   */
   SpiceCell           cnfine_cell = { SPICE_DP,
                                       0,
                                       0,
                                       0,
                                       SPICETRUE,
                                       SPICEFALSE,
                                       SPICEFALSE,
                                       NULL,
                                       NULL };

   SpiceCell           result_cell = { SPICE_DP,
                                       0,
                                       0,
                                       0,
                                       SPICETRUE,
                                       SPICEFALSE,
                                       SPICEFALSE,
                                       NULL,
                                       NULL };

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "targ1",   MiceChar,   0, {0}, 0},
      { "shape1",  MiceChar,   0, {0}, 0},
      { "frame1",  MiceChar,   0, {0}, 0},
      { "targ2",   MiceChar,   0, {0}, 0},
      { "shape2",  MiceChar,   0, {0}, 0},
      { "frame2",  MiceChar,   0, {0}, 0},
      { "abcorr",  MiceChar,   0, {0}, 0},
      { "obsrvr",  MiceChar,   0, {0}, 0},
      { "relate",  MiceChar,   0, {0}, 0},
      { "refval",  MiceDouble, 0, {0}, 0},
      { "adjust",  MiceDouble, 0, {0}, 0},
      { "step",    MiceDouble, 0, {0}, 0},
      { "nintvls", MiceInt,    0, {0}, 0},
      { "cnfine",  MiceWin,    1, {0}, 0},
      { "result",  MiceIgnore, 0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 14, 1);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], targ1,   DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], shape1,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[3], frame1,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[4], targ2,   DEFAULT_STR_LENGTH);
   mxGetString(prhs[5], shape2,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[6], frame2,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[7], abcorr,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[8], obsrvr,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[9], relate,  DEFAULT_STR_LENGTH);

   refval  = S_DBL_ARGV(10);
   adjust  = S_DBL_ARGV(11);
   step    = S_DBL_ARGV(12);
   nintvls = S_INT_ARGV(13);

   cnfine = (SpiceDouble*)mxGetData(prhs[14]);

   size = nintvls*2.;

   /*
   The size of array 'cnfine' includes an addition SPICE_CELL_CTRLSZ
   zero elements appended to the arrays. Calculate the size of
   'cnfine' without the append size.
   */
   cnfine_size = mxGetNumberOfElements( prhs[14] ) - SPICE_CELL_CTRLSZ;

   /*
   Set the struct fields to fully describe the 'cnfine_cell' cell. A Mice
   window implementation has size equal to cardinality.
   */
   cnfine_cell.size = cnfine_size;
   cnfine_cell.card = cnfine_size;
   cnfine_cell.base = cnfine;
   cnfine_cell.data = &cnfine[SPICE_CELL_CTRLSZ];

   /*
   mxMalloc returns to top level on error.
   */
   result = (SpiceDouble*)
            mxMalloc( (size + SPICE_CELL_CTRLSZ)*sizeof(SpiceDouble)  );


   /*
   Set the struct fields to initialize the 'result_cell' cell.
   The cardinality remains zero as this assignment occurs prior
   to use.
   */
   result_cell.size = size;
   result_cell.base = result;
   result_cell.data = &result[SPICE_CELL_CTRLSZ];

   (void) gfsep_c (  targ1,
                     shape1,
                     frame1,
                     targ2,
                     shape2,
                     frame2,
                     abcorr,
                     obsrvr,
                     relate,
                     refval,
                     adjust,
                     step,
                     nintvls,
                     &cnfine_cell,
                     &result_cell );

   /*
   Check for a failure signal. Free the memory assigned to 'result'
   before signaling a Matlab error.
   */
   if ( failed_c())
      {
      mxFree( result );
      mice_fail(SCALAR);
      }

   /*
   Create an output array CARDx1.
   */
   sizearray[0] = card_c( &result_cell );
   sizearray[1] = 1;

   plhs[0]  = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
   result_f = A_DBL_RET_ARGV(0);

   /*
   Copy the data contents of 'result' to 'result_f'. The set of window data
   starts at 'result' array index SPICE_CELL_CTRLSZ and contains 'sizearray[0]'
   elements.
   */
   MOVED( result + SPICE_CELL_CTRLSZ, sizearray[0], result_f );

   mxFree( result );

   }




/*
   void              gfsntc_c ( ConstSpiceChar     * target,
                                ConstSpiceChar     * fixref,
                                ConstSpiceChar     * method,
                                ConstSpiceChar     * abcorr,
                                ConstSpiceChar     * obsrvr,
                                ConstSpiceChar     * dref,
                                ConstSpiceDouble     dvec   [3],
                                ConstSpiceChar     * crdsys,
                                ConstSpiceChar     * coord,
                                ConstSpiceChar     * relate,
                                SpiceDouble          refval,
                                SpiceDouble          adjust,
                                SpiceDouble          step,
                                SpiceInt             nintvls,
                                SpiceCell          * cnfine,
                                SpiceCell          * result  );
*/
void cspice_gfsntc(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            target [DEFAULT_STR_LENGTH+1];
   SpiceChar            fixref [DEFAULT_STR_LENGTH+1];
   SpiceChar            method [DEFAULT_STR_LENGTH+1];
   SpiceChar            abcorr [DEFAULT_STR_LENGTH+1];
   SpiceChar            obsrvr [DEFAULT_STR_LENGTH+1];
   SpiceChar            dref   [DEFAULT_STR_LENGTH+1];
   SpiceDouble        * dvec;
   SpiceChar            crdsys [DEFAULT_STR_LENGTH+1];
   SpiceChar            coord  [DEFAULT_STR_LENGTH+1];
   SpiceChar            relate [DEFAULT_STR_LENGTH+1];
   SpiceDouble          refval;
   SpiceDouble          adjust;
   SpiceDouble          step;
   SpiceInt             nintvls;
   SpiceDouble        * cnfine;
   SpiceInt             size;
   SpiceDouble        * result;
   SpiceDouble        * result_f;

   mwSize               sizearray[2];

   SpiceInt             cnfine_size;

   /*
   Initialize the 'cnfine_cell' and 'result_cell' cells
   as double precision with zero size and zero cardinality.
   */
   SpiceCell           cnfine_cell = { SPICE_DP,
                                       0,
                                       0,
                                       0,
                                       SPICETRUE,
                                       SPICEFALSE,
                                       SPICEFALSE,
                                       NULL,
                                       NULL };

   SpiceCell           result_cell = { SPICE_DP,
                                       0,
                                       0,
                                       0,
                                       SPICETRUE,
                                       SPICEFALSE,
                                       SPICEFALSE,
                                       NULL,
                                       NULL };

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "target",  MiceChar,   0, {0}, 0},
      { "fixref",  MiceChar,   0, {0}, 0},
      { "method",  MiceChar,   0, {0}, 0},
      { "abcorr",  MiceChar,   0, {0}, 0},
      { "obsrvr",  MiceChar,   0, {0}, 0},
      { "dref",    MiceChar,   0, {0}, 0},
      { "dvec",    MiceDouble, 1, {3}, 0},
      { "crdsys",  MiceChar,   0, {0}, 0},
      { "coord",   MiceChar,   0, {0}, 0},
      { "relate",  MiceChar,   0, {0}, 0},
      { "refval",  MiceDouble, 0, {0}, 0},
      { "adjust",  MiceDouble, 0, {0}, 0},
      { "step",    MiceDouble, 0, {0}, 0},
      { "nintvls", MiceInt,    0, {0}, 0},
      { "cnfine",  MiceWin,    1, {0}, 0},
      { "result",  MiceIgnore, 0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 15, 1);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], target,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], fixref,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[3], method,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[4], abcorr,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[5], obsrvr,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[6], dref,    DEFAULT_STR_LENGTH);

   dvec = A_DBL_ARGV(7);

   mxGetString(prhs[8],  crdsys,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[9],  coord,   DEFAULT_STR_LENGTH);
   mxGetString(prhs[10], relate,  DEFAULT_STR_LENGTH);

   refval  = S_DBL_ARGV(11);
   adjust  = S_DBL_ARGV(12);
   step    = S_DBL_ARGV(13);
   nintvls = S_INT_ARGV(14);

   cnfine = (SpiceDouble*)mxGetData(prhs[15]);

   size = nintvls*2.;

   /*
   The size of array 'cnfine' includes an addition SPICE_CELL_CTRLSZ
   zero elements appended to the arrays. Calculate the size of
   'cnfine' without the append size.
   */
   cnfine_size = mxGetNumberOfElements( prhs[15] ) - SPICE_CELL_CTRLSZ;

   /*
   Set the struct fields to fully describe the 'cnfine_cell' cell. A Mice
   window implementation has size equal to cardinality.
   */
   cnfine_cell.size = cnfine_size;
   cnfine_cell.card = cnfine_size;
   cnfine_cell.base = cnfine;
   cnfine_cell.data = &cnfine[SPICE_CELL_CTRLSZ];

   /*
   mxMalloc returns to top level on error.
   */
   result = (SpiceDouble*)
            mxMalloc( (size + SPICE_CELL_CTRLSZ)*sizeof(SpiceDouble)  );

   /*
   Set the struct fields to initialize the 'result_cell' cell.
   The cardinality remains zero as this assignment occurs prior
   to use.
   */
   result_cell.size = size;
   result_cell.base = result;
   result_cell.data = &result[SPICE_CELL_CTRLSZ];

   (void) gfsntc_c ( target,
                     fixref,
                     method,
                     abcorr,
                     obsrvr,
                     dref,
                     dvec,
                     crdsys,
                     coord,
                     relate,
                     refval,
                     adjust,
                     step,
                     nintvls,
                     &cnfine_cell,
                     &result_cell  );

   /*
   Check for a failure signal. Free the memory assigned to 'result'
   before signaling a Matlab error.
   */
   if ( failed_c())
      {
      mxFree( result );
      mice_fail(SCALAR);
      }

   /*
   Create an output array CARDx1.
   */
   sizearray[0] = card_c( &result_cell );
   sizearray[1] = 1;

   plhs[0]  = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
   result_f = A_DBL_RET_ARGV(0);

   /*
   Copy the data contents of 'result' to 'result_f'. The set of window data
   starts at 'result' array index SPICE_CELL_CTRLSZ and contains 'sizearray[0]'
   elements.
   */
   MOVED( result + SPICE_CELL_CTRLSZ, sizearray[0], result_f );

   mxFree( result );

   }




/*
   void              gfstol_c ( SpiceDouble         value );
*/
void cspice_gfstol(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble          value;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "value",  MiceDouble, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 1, 0 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   value = S_DBL_ARGV(1);

   (void) gfstol_c ( value );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              gfsubc_c ( ConstSpiceChar     * target,
                                ConstSpiceChar     * fixref,
                                ConstSpiceChar     * method,
                                ConstSpiceChar     * abcorr,
                                ConstSpiceChar     * obsrvr,
                                ConstSpiceChar     * crdsys,
                                ConstSpiceChar     * coord,
                                ConstSpiceChar     * relate,
                                SpiceDouble          refval,
                                SpiceDouble          adjust,
                                SpiceDouble          step,
                                SpiceInt             nintvls,
                                SpiceCell          * cnfine,
                                SpiceCell          * result  );
*/
void cspice_gfsubc(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            target [DEFAULT_STR_LENGTH+1];
   SpiceChar            fixref [DEFAULT_STR_LENGTH+1];
   SpiceChar            method [DEFAULT_STR_LENGTH+1];
   SpiceChar            abcorr [DEFAULT_STR_LENGTH+1];
   SpiceChar            obsrvr [DEFAULT_STR_LENGTH+1];
   SpiceChar            crdsys [DEFAULT_STR_LENGTH+1];
   SpiceChar            coord  [DEFAULT_STR_LENGTH+1];
   SpiceChar            relate [DEFAULT_STR_LENGTH+1];
   SpiceDouble          refval;
   SpiceDouble          adjust;
   SpiceDouble          step;
   SpiceInt             nintvls;
   SpiceDouble        * cnfine;
   SpiceInt             size;
   SpiceDouble        * result;
   SpiceDouble        * result_f;

   mwSize               sizearray[2];

   SpiceInt             cnfine_size;

   /*
   Initialize the 'cnfine_cell' and 'result_cell' cells
   as double precision with zero size and zero cardinality.
   */
   SpiceCell           cnfine_cell = { SPICE_DP,
                                       0,
                                       0,
                                       0,
                                       SPICETRUE,
                                       SPICEFALSE,
                                       SPICEFALSE,
                                       NULL,
                                       NULL };

   SpiceCell           result_cell = { SPICE_DP,
                                       0,
                                       0,
                                       0,
                                       SPICETRUE,
                                       SPICEFALSE,
                                       SPICEFALSE,
                                       NULL,
                                       NULL };

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "target",  MiceChar,   0, {0}, 0},
      { "fixref",  MiceChar,   0, {0}, 0},
      { "method",  MiceChar,   0, {0}, 0},
      { "abcorr",  MiceChar,   0, {0}, 0},
      { "obsrvr",  MiceChar,   0, {0}, 0},
      { "crdsys",  MiceChar,   0, {0}, 0},
      { "coord",   MiceChar,   0, {0}, 0},
      { "relate",  MiceChar,   0, {0}, 0},
      { "refval",  MiceDouble, 0, {0}, 0},
      { "adjust",  MiceDouble, 0, {0}, 0},
      { "step",    MiceDouble, 0, {0}, 0},
      { "nintvls", MiceInt,    0, {0}, 0},
      { "cnfine",  MiceWin,    1, {0}, 0},
      { "result",  MiceIgnore, 0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 13, 1);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], target,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], fixref,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[3], method,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[4], abcorr,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[5], obsrvr,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[6], crdsys,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[7], coord,   DEFAULT_STR_LENGTH);
   mxGetString(prhs[8], relate,  DEFAULT_STR_LENGTH);

   refval  = S_DBL_ARGV(9);
   adjust  = S_DBL_ARGV(10);
   step    = S_DBL_ARGV(11);
   nintvls = S_INT_ARGV(12);

   cnfine = (SpiceDouble*)mxGetData(prhs[13]);

   size = nintvls*2.;

   /*
   The size of array 'cnfine' includes an addition SPICE_CELL_CTRLSZ
   zero elements appended to the arrays. Calculate the size of
   'cnfine' without the append size.
   */
   cnfine_size = mxGetNumberOfElements( prhs[13] ) - SPICE_CELL_CTRLSZ;

   /*
   Set the struct fields to fully describe the 'cnfine_cell' cell. A Mice
   window implementation has size equal to cardinality.
   */
   cnfine_cell.size = cnfine_size;
   cnfine_cell.card = cnfine_size;
   cnfine_cell.base = cnfine;
   cnfine_cell.data = &cnfine[SPICE_CELL_CTRLSZ];

   /*
   mxMalloc returns to top level on error.
   */
   result = (SpiceDouble*)
            mxMalloc( (size + SPICE_CELL_CTRLSZ)*sizeof(SpiceDouble)  );


   /*
   Set the struct fields to initialize the 'result_cell' cell.
   The cardinality remains zero as this assignment occurs prior
   to use.
   */
   result_cell.size = size;
   result_cell.base = result;
   result_cell.data = &result[SPICE_CELL_CTRLSZ];

   (void) gfsubc_c ( target,
                     fixref,
                     method,
                     abcorr,
                     obsrvr,
                     crdsys,
                     coord,
                     relate,
                     refval,
                     adjust,
                     step,
                     nintvls,
                     &cnfine_cell,
                     &result_cell  );


   /*
   Check for a failure signal. Free the memory assigned to 'result'
   before signaling a Matlab error.
   */
   if ( failed_c())
      {
      mxFree( result );
      mice_fail(SCALAR);
      }

   /*
   Create an output array CARDx1.
   */
   sizearray[0] = card_c( &result_cell );
   sizearray[1] = 1;

   plhs[0]  = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
   result_f = A_DBL_RET_ARGV(0);

   /*
   Copy the data contents of 'result' to 'result_f'. The set of window data
   starts at 'result' array index SPICE_CELL_CTRLSZ and contains 'sizearray[0]'
   elements.
   */
   MOVED( result + SPICE_CELL_CTRLSZ, sizearray[0], result_f );

   mxFree( result );

   }




/*
   void              gftfov_c ( ConstSpiceChar     * inst,
                                ConstSpiceChar     * target,
                                ConstSpiceChar     * tshape,
                                ConstSpiceChar     * tframe,
                                ConstSpiceChar     * abcorr,
                                ConstSpiceChar     * obsrvr,
                                SpiceDouble          step,
                                SpiceCell          * cnfine,
                                SpiceCell          * result  )
*/
void cspice_gftfov(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            inst   [DEFAULT_STR_LENGTH+1];
   SpiceChar            target [DEFAULT_STR_LENGTH+1];
   SpiceChar            tshape [DEFAULT_STR_LENGTH+1];
   SpiceChar            tframe [DEFAULT_STR_LENGTH+1];
   SpiceChar            abcorr [DEFAULT_STR_LENGTH+1];
   SpiceChar            obsrvr [DEFAULT_STR_LENGTH+1];
   SpiceDouble          step;
   SpiceDouble        * cnfine;
   SpiceInt             size;
   SpiceDouble        * result;
   SpiceDouble        * result_f;

   mwSize               sizearray[2];

   SpiceInt             cnfine_size;

   /*
   Initialize the 'cnfine_cell' and 'result_cell' cells
   as double precision with zero size and zero cardinality.
   */
   SpiceCell           cnfine_cell = { SPICE_DP,
                                       0,
                                       0,
                                       0,
                                       SPICETRUE,
                                       SPICEFALSE,
                                       SPICEFALSE,
                                       NULL,
                                       NULL };

   SpiceCell           result_cell = { SPICE_DP,
                                       0,
                                       0,
                                       0,
                                       SPICETRUE,
                                       SPICEFALSE,
                                       SPICEFALSE,
                                       NULL,
                                       NULL };

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "inst",    MiceChar,   0, {0}, 0},
      { "target",  MiceChar,   0, {0}, 0},
      { "tshape",  MiceChar,   0, {0}, 0},
      { "tframe",  MiceChar,   0, {0}, 0},
      { "abcorr",  MiceChar,   0, {0}, 0},
      { "obsrvr",  MiceChar,   0, {0}, 0},
      { "step",    MiceDouble, 0, {0}, 0},
      { "cnfine",  MiceWin,    1, {0}, 0},
      { "nintvls", MiceInt,    0, {0}, 0},
      { "result",  MiceIgnore, 0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 9, 1);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], inst,   DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], target, DEFAULT_STR_LENGTH);
   mxGetString(prhs[3], tshape, DEFAULT_STR_LENGTH);
   mxGetString(prhs[4], tframe, DEFAULT_STR_LENGTH);
   mxGetString(prhs[5], abcorr, DEFAULT_STR_LENGTH);
   mxGetString(prhs[6], obsrvr, DEFAULT_STR_LENGTH);

   step   = S_DBL_ARGV(7);

   cnfine = (SpiceDouble*)mxGetData(prhs[8]);

   /*
   `size' defines the number of intervals for the `result' window,
   so double the value of `size' since an interval consists of
   two double precision values.
   */
   size   = S_INT_ARGV(9) * 2;

   /*
   The size of array 'cnfine' includes an addition SPICE_CELL_CTRLSZ
   zero elements appended to the arrays. Calculate the size of
   'cnfine' without the append size.
   */
   cnfine_size = mxGetNumberOfElements( prhs[8] ) - SPICE_CELL_CTRLSZ;

   /*
   Set the struct fields to fully describe the 'cnfine_cell' cell. A Mice
   window implementation has size equal to cardinality.
   */
   cnfine_cell.size = cnfine_size;
   cnfine_cell.card = cnfine_size;
   cnfine_cell.base = cnfine;
   cnfine_cell.data = &cnfine[SPICE_CELL_CTRLSZ];

   /*
   mxMalloc returns to top level on error.
   */
   result = (SpiceDouble*)
            mxMalloc( (size + SPICE_CELL_CTRLSZ)*sizeof(SpiceDouble)  );


   /*
   Set the struct fields to initialize the 'result_cell' cell.
   The cardinality remains zero as this assignment occurs prior
   to use.
   */
   result_cell.size = size;
   result_cell.base = result;
   result_cell.data = &result[SPICE_CELL_CTRLSZ];

   (void) gftfov_c ( inst,
                     target,
                     tshape,
                     tframe,
                     abcorr,
                     obsrvr,
                     step,
                     &cnfine_cell,
                     &result_cell  );

   /*
   Check for a failure signal. Free the memory assigned to 'result'
   before signaling a Matlab error.
   */
   if ( failed_c())
      {
      mxFree( result );
      mice_fail(SCALAR);
      }

   /*
   Create an output array CARDx1.
   */
   sizearray[0] = card_c( &result_cell );
   sizearray[1] = 1;

   plhs[0]  = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
   result_f = A_DBL_RET_ARGV(0);

   /*
   Copy the data contents of 'result' to 'result_f'. The set of window data
   starts at 'result' array index SPICE_CELL_CTRLSZ and contains 'sizearray[0]'
   elements.
   */
   MOVED( result + SPICE_CELL_CTRLSZ, sizearray[0], result_f );

   mxFree( result );

   }





/*
   void              gipool_c ( ConstSpiceChar    * name,
                                SpiceInt            start,
                                SpiceInt            room,
                                SpiceInt          * n,
                                SpiceInt          * ivals,
                                SpiceBoolean      * found );
*/
void cspice_gipool(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            name[MAXLEN+1];
   SpiceInt             start;
   SpiceInt             room;
   SpiceInt             n           = 0;
   SpiceInt           * ivals;
   SpiceInt           * ivals_ret;
   SpiceBoolean         found;

   mwSize               sizearray[2];

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "name",  MiceChar,   0, {0}, 0},
      { "start", MiceInt,    0, {0}, 0},
      { "room",  MiceInt,    0, {0}, 0},
      { "ivals", MiceIgnore, 0, {0}, 0},
      { "found", MiceIgnore, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 3, 2 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], name, MAXLEN);

   /*
   MATLAB uses a base 1 array index convention, as is proper,
   C does not, which is weird. Subtract one off the 'start' index.
   */
   start = S_INT_ARGV(2) - 1;
   room  = S_INT_ARGV(3);

   ivals  = (SpiceInt*)mxMalloc(room * sizeof(SpiceInt) );
   memset( ivals,  0, room * sizeof(SpiceInt) );

   gipool_c(name, start, room, &n, ivals, &found);

   /*
   Check for a failure signal. Free the memory assigned to 'ivals'
   before signaling a Matlab error.
   */
   if ( failed_c())
      {
      mxFree( ivals );

      /*
      The mice_fail call creates the error string then returns control
      to the MATLAB interpreter.
      */
      mice_fail(SCALAR);
      }

   if( found )
      {
      sizearray[0] = n;
      sizearray[1] = 1;
      }
   else
      {
      sizearray[0] = 0;
      sizearray[1] = 0;
      }

   plhs[0]   = mxCreateNumericArray( 2, sizearray, mxINT32_CLASS, mxREAL);
   ivals_ret = A_INT_RET_ARGV(0);

   plhs[1] = zzmice_CreateIntScalar(found);

   MOVEI( ivals, n, ivals_ret );
   mxFree( ivals );

   }




/*
   SpiceDouble halfpi_c( void )
*/
void cspice_halfpi(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   check_arg_num( nrhs, nlhs, 0, 1 );

   /*
   Directly return the scalar value. This simple case needs no
   error checks.
   */
   plhs[0] = mxCreateDoubleScalar( halfpi_c() );

   }





/*
   void              gnpool_c ( ConstSpiceChar    * name,
                                SpiceInt            start,
                                SpiceInt            room,
                                SpiceInt            lenout,
                                SpiceInt          * n,
                                void              * cvals,
                                SpiceBoolean      * found  );
*/
void cspice_gnpool(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar             name[MAXLEN+1];
   SpiceInt              start;
   SpiceInt              room;
   SpiceInt              lenout;
   SpiceInt              n        = 0;
   SpiceChar          ** cvals;
   SpiceChar          ** array;
   SpiceBoolean       * found;

   SpiceInt              i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "name",   MiceChar,    0, {0}, 0},
      { "start",  MiceInt,     0, {0}, 0},
      { "room",   MiceInt,     0, {0}, 0},
      { "cvals",  MiceChar,    0, {0}, 0},
      { "found",  MiceBoolean, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 3, 2 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], name, MAXLEN );

   /*
   MATLAB uses a base 1 array index convention, as is proper,
   C does not, which is weird. Subtract one off the 'start' index.
   */
   start  = S_INT_ARGV(2) - 1;
   room   = S_INT_ARGV(3);
   found  = A_BOOL_RET_ARGV(1);

   lenout = MAXLEN;

   cvals  = (SpiceChar**)alloc_SpiceString_C_array ( lenout, room );
   array  = (SpiceChar**)alloc_SpiceString_Pointer_array(room);

   CHECK_CALL_FAILURE_MEM1(SCALAR, 1, cvals, array);

   gnpool_c(name, start, room, lenout, &n, *cvals, found);
   CHECK_CALL_FAILURE_MEM1(SCALAR, 1, cvals, array);

   for (i=0;i<n;i++)
      {

      /*
      Copy the ith string pointer to the array of pointers for input
      to the mx call.
      */
      array[i] = *cvals + i*lenout;
      }

   /*
   I think this functions as a copy, creating needed memory to 'plhs'.
   */
   plhs[0] = mxCreateCharMatrixFromStrings( n, (const char **)array);

   free_SpiceString_C_array( 1, cvals );
   free_SpiceMemory( array );

   /*
   Confirm the code released all allocated memory.
   */
   MICE_ALLOC_CHECK;

   }




/*
   void hrmesp_c ( SpiceInt            n,
                   SpiceDouble         first,
                   SpiceDouble         step,
                   ConstSpiceDouble    yvals  [],
                   SpiceDouble         x,
                   SpiceDouble       * f,
                   SpiceDouble       * df        )
*/
void cspice_hrmesp(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             n;
   SpiceDouble          first;
   SpiceDouble          step;
   ConstSpiceDouble   * yvals;
   SpiceDouble          x;
   SpiceDouble        * f;
   SpiceDouble        * df;

   SpiceInt             yvalen;

   /* The message buffer to write an error message */
   char                 msg[1024];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "n",       MiceInt,      0, {0},   0},
      { "first",   MiceDouble,   0, {0},   0},
      { "step",    MiceDouble,   0, {0},   0},
      { "yvals",   MiceDouble,   1, {0},   0},
      { "x",       MiceDouble,   0, {0},   0},
      { "f",       MiceDouble,   0, {0},   0},
      { "df",      MiceDouble,   0, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 5, 2 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   n        = S_INT_ARGV(1);
   first    = S_DBL_ARGV(2);
   step     = S_DBL_ARGV(3);
   yvals    = A_DBL_ARGV(4);
   x        = S_DBL_ARGV(5);

   /*
   Check that `yvals' has enough data.
   */
   yvalen  = A_LEN_ARGV(4);

   if ( yvalen < 2*n )
   {
      sprintf( msg, "MICE(INSUFFICIENTDATA): `yvals` does not have enough "
               "data: %ld elements required; only %ld provided.",
               (long)(2*n), (long)yvalen );
      mexErrMsgTxt( msg );
   }

   f        = A_DBL_RET_ARGV(0);
   df       = A_DBL_RET_ARGV(1);

   hrmesp_c ( n, first, step, yvals, x, f, df );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void hrmint_c ( SpiceInt            n,
                   ConstSpiceDouble  * xvals,
                   ConstSpiceDouble  * yvals,
                   SpiceDouble         x,
                   SpiceDouble       * work,
                   SpiceDouble       * f,
                   SpiceDouble       * df )
*/
void cspice_hrmint(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             n;
   ConstSpiceDouble   * xvals;
   ConstSpiceDouble   * yvals;
   SpiceDouble          x;

   SpiceInt             nWork;
   SpiceDouble        * work = NULL;

   SpiceDouble        * f;
   SpiceDouble        * df;

   SpiceInt             xvalen;
   SpiceInt             yvalen;

   /* The message buffer to write an error message */
   char                 msg[1024];


   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "n",       MiceInt,      0, {0},   0},
      { "xvals",   MiceDouble,   1, {0},   0},
      { "yvals",   MiceDouble,   1, {0},   0},
      { "x",       MiceDouble,   0, {0},   0},
      { "f",       MiceDouble,   0, {0},   0},
      { "df",      MiceDouble,   0, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 4, 2 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   n        = S_INT_ARGV(1);
   xvals    = A_DBL_ARGV(2);
   yvals    = A_DBL_ARGV(3);
   x        = S_DBL_ARGV(4);

   /*
   Check that `xvals' has enough data.
   */
   xvalen  = A_LEN_ARGV(2);

   if ( xvalen < n )
   {
      sprintf( msg, "MICE(INSUFFICIENTDATA): `xvals` does not have enough "
               "data: %ld elements required; only %ld provided.",
               (long)n, (long)xvalen );
      mexErrMsgTxt( msg );
   }

   /*
   Check that `yvals' has enough data.
   */
   yvalen  = A_LEN_ARGV(3);

   if ( yvalen < 2*n )
   {
      sprintf( msg, "MICE(INSUFFICIENTDATA): `yvals` does not have enough "
               "data: %ld elements required; only %ld provided.",
               (long)(2*n), (long)yvalen );
      mexErrMsgTxt( msg );
   }

   /*
   Allocate the workspace.

   This gateway is not following the standard approach when it comes to
   producing gateways for CSPICE wrappers of SPICELIB routines that use
   workspaces.

   Normally, the workspaces required by SPICELIB code are allocated
   within the CSPICE code, and the Mice gateways are just calling
   CSPICE, without dealing with that memory allocation.

   In the case of cspice_hrmint, CSPICE does not allocate memory for the
   workspace. Instead, it requires the user to provide as input to the
   routines the workspace, and therefore the Mice gateway code must do it.

   We use mxMalloc to create a 1-dimensional array of nWork elements.
   mxMalloc returns to top level in case of error.
   */
   if ( n > 0 )
   {
      nWork = 4 * n;
      work  = (SpiceDouble*) mxMalloc( nWork * sizeof(SpiceDouble) );
   }

   f        = A_DBL_RET_ARGV(0);
   df       = A_DBL_RET_ARGV(1);

   hrmint_c ( n, xvals, yvals, x, work, f, df );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              illum_c  ( ConstSpiceChar    * target,
                                SpiceDouble         et,
                                ConstSpiceChar    * abcorr,
                                ConstSpiceChar    * obsrvr,
                                ConstSpiceDouble    spoint [3],
                                SpiceDouble       * phase,
                                SpiceDouble       * solar,
                                SpiceDouble       * emissn     );
*/
void cspice_illum(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            target[DEFAULT_STR_LENGTH+1];
   SpiceDouble          et;
   SpiceDouble        * vec_et;
   SpiceChar            abcorr[DEFAULT_STR_LENGTH+1];
   SpiceChar            obsrvr[DEFAULT_STR_LENGTH+1];
   SpiceDouble        * spoint;
   SpiceDouble        * phase;
   SpiceDouble        * solar;
   SpiceDouble        * emissn;
   SpiceDouble        * vec_spoint;
   SpiceDouble        * vec_phase;
   SpiceDouble        * vec_solar;
   SpiceDouble        * vec_emissn;
   mwIndex              i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "target", MiceChar,   0, {0}, 0},
      { "et",     MiceDouble, 0, {0}, 1},
      { "abcorr", MiceChar,   0, {0}, 0},
      { "obsrvr", MiceChar,   0, {0}, 0},
      { "spoint", MiceDouble, 1, {3}, 1},
      { "phase",  MiceDouble, 0, {0}, 1},
      { "solar",  MiceDouble, 0, {0}, 1},
      { "emissn", MiceDouble, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 5, 3 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], target, DEFAULT_STR_LENGTH);

   vec_et = A_DBL_ARGV(2);

   mxGetString(prhs[3], abcorr, DEFAULT_STR_LENGTH);
   mxGetString(prhs[4], obsrvr, DEFAULT_STR_LENGTH);

   vec_spoint = A_DBL_ARGV(5);
   vec_phase  = A_DBL_RET_ARGV(0);
   vec_solar  = A_DBL_RET_ARGV(1);
   vec_emissn = A_DBL_RET_ARGV(2);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         et     = *(vec_et     + i*extra->offset[1]);
         spoint =  (vec_spoint + i*extra->offset[4]);
         phase  =  (vec_phase  + i*extra->offset[5]);
         solar  =  (vec_solar  + i*extra->offset[6]);
         emissn =  (vec_emissn + i*extra->offset[7]);

         illum_c(target, et, abcorr, obsrvr, spoint, phase, solar, emissn);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {

      et     = *vec_et;
      spoint = vec_spoint;
      phase  = vec_phase;
      solar  = vec_solar;
      emissn = vec_emissn;

      illum_c(target, et, abcorr, obsrvr, spoint, phase, solar, emissn);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void illum_pl02 ( SpiceInt               handle,
                     ConstSpiceDLADescr   * dladsc,
                     ConstSpiceChar       * target,
                     SpiceDouble            et,
                     ConstSpiceChar       * abcorr,
                     ConstSpiceChar       * obsrvr,
                     SpiceDouble            spoint [3],
                     SpiceDouble          * phase,
                     SpiceDouble          * solar,
                     SpiceDouble          * emissn      )
*/
void cspice_illum_pl02(int nlhs, mxArray *plhs[], int nrhs,
                       const mxArray *prhs[])
   {
   SpiceInt             handle;
   SpiceDLADescr        local_dladsc;
   SpiceInt           * dladsc;
   SpiceChar            target[DEFAULT_STR_LENGTH+1];
   SpiceDouble          et;
   SpiceChar            abcorr[DEFAULT_STR_LENGTH+1];
   SpiceChar            obsrvr[DEFAULT_STR_LENGTH+1];
   SpiceDouble        * spoint;
   SpiceDouble        * phase;
   SpiceDouble        * solar;
   SpiceDouble        * emissn;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle",  MiceInt,     0, {0},                0},
      { "dladsc",  MiceInt,     1, {SPICE_DLA_DSCSIZ}, 0},
      { "target",  MiceChar,    0, {0},                0},
      { "et",      MiceDouble,  0, {0},                0},
      { "abcorr",  MiceChar,    0, {0},                0},
      { "obsrvr",  MiceChar,    0, {0},                0},
      { "spoint",  MiceDouble,  1, {3},                0},
      { "phase",   MiceDouble,  0, {0},                0},
      { "solar",   MiceDouble,  0, {0},                0},
      { "emissn",  MiceDouble,  0, {0},                0},
      };

   check_arg_num( nrhs, nlhs, 7, 3 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle  = S_INT_ARGV(1);
   dladsc  = A_INT_ARGV(2);

   local_dladsc.bwdptr = dladsc[SPICE_DLA_BWDIDX];
   local_dladsc.fwdptr = dladsc[SPICE_DLA_FWDIDX];
   local_dladsc.ibase  = dladsc[SPICE_DLA_IBSIDX];
   local_dladsc.isize  = dladsc[SPICE_DLA_ISZIDX];
   local_dladsc.dbase  = dladsc[SPICE_DLA_DBSIDX];
   local_dladsc.dsize  = dladsc[SPICE_DLA_DSZIDX];
   local_dladsc.cbase  = dladsc[SPICE_DLA_CBSIDX];
   local_dladsc.csize  = dladsc[SPICE_DLA_CSZIDX];

   mxGetString(prhs[3], target, DEFAULT_STR_LENGTH);

   et = S_DBL_ARGV(4);

   mxGetString(prhs[5], abcorr, DEFAULT_STR_LENGTH);
   mxGetString(prhs[6], obsrvr, DEFAULT_STR_LENGTH);

   spoint = A_DBL_ARGV(7);

   phase  = A_DBL_RET_ARGV(0);
   solar  = A_DBL_RET_ARGV(1);
   emissn = A_DBL_RET_ARGV(2);

   illum_pl02 ( handle, &local_dladsc, target, et,    abcorr,
                obsrvr, spoint,        phase,  solar, emissn );

   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void illum_plid_pl02 ( SpiceInt               handle,
                          ConstSpiceDLADescr   * dladsc,
                          ConstSpiceChar       * target,
                          SpiceDouble            et,
                          ConstSpiceChar       * abcorr,
                          ConstSpiceChar       * obsrvr,
                          SpiceDouble            spoint [3],
                          SpiceInt               plid,
                          SpiceDouble          * trgepc,
                          SpiceDouble            srfvec [3],
                          SpiceDouble          * phase,
                          SpiceDouble          * solar,
                          SpiceDouble          * emissn,
                          SpiceBoolean         * visible,
                          SpiceBoolean         * lit       )
*/
void mice_illum_plid_pl02(int nlhs, mxArray *plhs[],
                          int nrhs, const mxArray *prhs[])
   {

   SpiceInt             handle;
   SpiceDLADescr        local_dladsc;
   SpiceInt           * dladsc;
   SpiceChar            target[DEFAULT_STR_LENGTH+1];
   SpiceDouble          et;
   SpiceChar            abcorr[DEFAULT_STR_LENGTH+1];
   SpiceChar            obsrvr[DEFAULT_STR_LENGTH+1];
   SpiceDouble        * spoint;
   SpiceInt             plid;
   SpiceDouble          trgepc;
   SpiceDouble          srfvec[3];
   SpiceDouble          phase;
   SpiceDouble          solar;
   SpiceDouble          emissn;
   SpiceBoolean       * visibl;
   SpiceBoolean       * lit;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle",  MiceInt,     0, {0},                0},
      { "dladsc",  MiceInt,     1, {SPICE_DLA_DSCSIZ}, 0},
      { "target",  MiceChar,    0, {0},                0},
      { "et",      MiceDouble,  0, {0},                0},
      { "abcorr",  MiceChar,    0, {0},                0},
      { "obsrvr",  MiceChar,    0, {0},                0},
      { "spoint",  MiceDouble,  1, {3},                0},
      { "plid",    MiceInt,     0, {0},                0},
      { "ilum",    MiceIlum,    0, {0},                0},
      { "visibl",  MiceBoolean, 0, {0},                0},
      { "lit",     MiceBoolean, 0, {0},                0}
      };

   check_arg_num( nrhs, nlhs, 8, 3 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle  = S_INT_ARGV(1);
   dladsc  = A_INT_ARGV(2);

   local_dladsc.bwdptr = dladsc[SPICE_DLA_BWDIDX];
   local_dladsc.fwdptr = dladsc[SPICE_DLA_FWDIDX];
   local_dladsc.ibase  = dladsc[SPICE_DLA_IBSIDX];
   local_dladsc.isize  = dladsc[SPICE_DLA_ISZIDX];
   local_dladsc.dbase  = dladsc[SPICE_DLA_DBSIDX];
   local_dladsc.dsize  = dladsc[SPICE_DLA_DSZIDX];
   local_dladsc.cbase  = dladsc[SPICE_DLA_CBSIDX];
   local_dladsc.csize  = dladsc[SPICE_DLA_CSZIDX];

   mxGetString(prhs[3], target, DEFAULT_STR_LENGTH);

   et = S_DBL_ARGV(4);

   mxGetString(prhs[5], abcorr, DEFAULT_STR_LENGTH);
   mxGetString(prhs[6], obsrvr, DEFAULT_STR_LENGTH);

   spoint = A_DBL_ARGV(7);
   plid   = S_INT_ARGV(8);

   visibl = A_BOOL_RET_ARGV(1);
   lit    = A_BOOL_RET_ARGV(2);

   illum_plid_pl02 ( handle,
                     &local_dladsc,
                     target,
                     et,
                     abcorr,
                     obsrvr,
                     spoint,
                     plid,
                     &trgepc,
                     srfvec,
                     &phase,
                     &solar,
                     &emissn,
                     visibl,
                     lit );

   CHECK_CALL_FAILURE(SCALAR);

   mxDestroyArray( mxGetField( plhs[0], 0, "trgepc" ) );
   mxSetField( plhs[0], 0, "trgepc",  mxCreateDoubleScalar(trgepc) );

   memcpy( mxGetPr( mxGetField(plhs[0],0,"srfvec" ) ),
           srfvec,
           3*sizeof(SpiceDouble));

   mxDestroyArray( mxGetField( plhs[0], 0, "phase" ) );
   mxSetField( plhs[0], 0, "phase", mxCreateDoubleScalar(phase) );

   mxDestroyArray( mxGetField( plhs[0], 0, "incdnc" ) );
   mxSetField( plhs[0], 0, "incdnc", mxCreateDoubleScalar(solar) );

   mxDestroyArray( mxGetField( plhs[0], 0, "emissn" ) );
   mxSetField( plhs[0], 0, "emissn", mxCreateDoubleScalar(emissn) );

   }




/*
   void              illumf_c ( ConstSpiceChar        * method,
                                ConstSpiceChar        * target,
                                ConstSpiceChar        * ilusrc,
                                SpiceDouble             et,
                                ConstSpiceChar        * fixref,
                                ConstSpiceChar        * abcorr,
                                ConstSpiceChar        * obsrvr,
                                ConstSpiceDouble        spoint [3],
                                SpiceDouble           * trgepc,
                                SpiceDouble             srfvec [3],
                                SpiceDouble           * phase,
                                SpiceDouble           * incdnc,
                                SpiceDouble           * emissn,
                                SpiceBoolean          * visibl,
                                SpiceBoolean          * lit       )
*/
void mice_illumf(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            method[DEFAULT_STR_LENGTH+1];
   SpiceChar            target[DEFAULT_STR_LENGTH+1];
   SpiceChar            ilusrc[DEFAULT_STR_LENGTH+1];
   SpiceDouble          et;
   SpiceChar            fixref[DEFAULT_STR_LENGTH+1];
   SpiceChar            abcorr[DEFAULT_STR_LENGTH+1];
   SpiceChar            obsrvr[DEFAULT_STR_LENGTH+1];
   SpiceDouble        * spoint;
   SpiceDouble          trgepc;
   SpiceDouble          srfvec[3];
   SpiceDouble          phase;
   SpiceDouble          incdnc;
   SpiceDouble          emissn;
   SpiceBoolean       * visibl;
   SpiceBoolean       * lit;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "method", MiceChar,   0, {0}, 0},
      { "target", MiceChar,   0, {0}, 0},
      { "ilusrc", MiceChar,   0, {0}, 0},
      { "et",     MiceDouble, 0, {0}, 0},
      { "fixref", MiceChar,   0, {0}, 0},
      { "abcorr", MiceChar,   0, {0}, 0},
      { "obsrvr", MiceChar,   0, {0}, 0},
      { "spoint", MiceDouble, 1, {3}, 0},
      { "ilum",   MiceIlum,   0, {0}, 0},
      { "visibl", MiceBoolean,0, {0}, 0},
      { "lit",    MiceBoolean,0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 8, 3 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], method, DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], target, DEFAULT_STR_LENGTH);
   mxGetString(prhs[3], ilusrc, DEFAULT_STR_LENGTH);

   et = S_DBL_ARGV(4);

   mxGetString(prhs[5], fixref, DEFAULT_STR_LENGTH);
   mxGetString(prhs[6], abcorr, DEFAULT_STR_LENGTH);
   mxGetString(prhs[7], obsrvr, DEFAULT_STR_LENGTH);

   spoint = A_DBL_ARGV(8);

   visibl = A_BOOL_RET_ARGV(1);
   lit    = A_BOOL_RET_ARGV(2);

   illumf_c( method,
             target,
             ilusrc,
             et,
             fixref,
             abcorr,
             obsrvr,
             spoint,
             &trgepc,
             srfvec,
             &phase,
             &incdnc,
             &emissn,
             visibl,
             lit );

   CHECK_CALL_FAILURE(SCALAR);

   mxDestroyArray( mxGetField( plhs[0], 0, "trgepc" ) );
   mxSetField( plhs[0], 0, "trgepc",  mxCreateDoubleScalar(trgepc) );

   memcpy( mxGetPr( mxGetField(plhs[0],0,"srfvec" ) ),
           srfvec,
           3*sizeof(SpiceDouble));

   mxDestroyArray( mxGetField( plhs[0], 0, "phase" ) );
   mxSetField( plhs[0], 0, "phase", mxCreateDoubleScalar(phase) );

   mxDestroyArray( mxGetField( plhs[0], 0, "incdnc" ) );
   mxSetField( plhs[0], 0, "incdnc", mxCreateDoubleScalar(incdnc) );

   mxDestroyArray( mxGetField( plhs[0], 0, "emissn" ) );
   mxSetField( plhs[0], 0, "emissn", mxCreateDoubleScalar(emissn) );

   }




/*
   void              illumg_c ( ConstSpiceChar        * method,
                                ConstSpiceChar        * target,
                                ConstSpiceChar        * ilusrc,
                                SpiceDouble             et,
                                ConstSpiceChar        * fixref,
                                ConstSpiceChar        * abcorr,
                                ConstSpiceChar        * obsrvr,
                                ConstSpiceDouble        spoint [3],
                                SpiceDouble           * trgepc,
                                SpiceDouble             srfvec [3],
                                SpiceDouble           * phase,
                                SpiceDouble           * incdnc,
                                SpiceDouble           * emissn     )
*/
void mice_illumg(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            method[DEFAULT_STR_LENGTH+1];
   SpiceChar            target[DEFAULT_STR_LENGTH+1];
   SpiceChar            ilusrc[DEFAULT_STR_LENGTH+1];
   SpiceDouble          et;
   SpiceChar            fixref[DEFAULT_STR_LENGTH+1];
   SpiceChar            abcorr[DEFAULT_STR_LENGTH+1];
   SpiceChar            obsrvr[DEFAULT_STR_LENGTH+1];
   SpiceDouble        * spoint;
   SpiceDouble          trgepc;
   SpiceDouble          srfvec[3];
   SpiceDouble          phase;
   SpiceDouble          incdnc;
   SpiceDouble          emissn;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "method", MiceChar,   0, {0}, 0},
      { "target", MiceChar,   0, {0}, 0},
      { "ilusrc", MiceChar,   0, {0}, 0},
      { "et",     MiceDouble, 0, {0}, 0},
      { "fixref", MiceChar,   0, {0}, 0},
      { "abcorr", MiceChar,   0, {0}, 0},
      { "obsrvr", MiceChar,   0, {0}, 0},
      { "spoint", MiceDouble, 1, {3}, 0},
      { "ilum",   MiceIlum,   0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 8, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], method, DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], target, DEFAULT_STR_LENGTH);
   mxGetString(prhs[3], ilusrc, DEFAULT_STR_LENGTH);

   et = S_DBL_ARGV(4);

   mxGetString(prhs[5], fixref, DEFAULT_STR_LENGTH);
   mxGetString(prhs[6], abcorr, DEFAULT_STR_LENGTH);
   mxGetString(prhs[7], obsrvr, DEFAULT_STR_LENGTH);

   spoint = A_DBL_ARGV(8);

   illumg_c( method,
             target,
             ilusrc,
             et,
             fixref,
             abcorr,
             obsrvr,
             spoint,
             &trgepc,
             srfvec,
             &phase,
             &incdnc,
             &emissn );

   CHECK_CALL_FAILURE(SCALAR);

   mxDestroyArray( mxGetField( plhs[0], 0, "trgepc" ) );
   mxSetField( plhs[0], 0, "trgepc",  mxCreateDoubleScalar(trgepc) );

   memcpy( mxGetPr( mxGetField(plhs[0],0,"srfvec" ) ),
           srfvec,
           3*sizeof(SpiceDouble));

   mxDestroyArray( mxGetField( plhs[0], 0, "phase" ) );
   mxSetField( plhs[0], 0, "phase", mxCreateDoubleScalar(phase) );

   mxDestroyArray( mxGetField( plhs[0], 0, "incdnc" ) );
   mxSetField( plhs[0], 0, "incdnc", mxCreateDoubleScalar(incdnc) );

   mxDestroyArray( mxGetField( plhs[0], 0, "emissn" ) );
   mxSetField( plhs[0], 0, "emissn", mxCreateDoubleScalar(emissn) );

   }




/*
   void              ilumin_c ( ConstSpiceChar    * method,
                                ConstSpiceChar    * target,
                                SpiceDouble         et,
                                ConstSpiceChar    * fixref,
                                ConstSpiceChar    * abcorr,
                                ConstSpiceChar    * obsrvr,
                                ConstSpiceDouble    spoint [3],
                                SpiceDouble       * trgepc,
                                SpiceDouble         srfvec [3],
                                SpiceDouble       * phase,
                                SpiceDouble       * solar,
                                SpiceDouble       * emissn     );
*/
void mice_ilumin(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            method[DEFAULT_STR_LENGTH+1];
   SpiceChar            target[DEFAULT_STR_LENGTH+1];
   SpiceDouble          et;
   SpiceChar            fixref[DEFAULT_STR_LENGTH+1];
   SpiceChar            abcorr[DEFAULT_STR_LENGTH+1];
   SpiceChar            obsrvr[DEFAULT_STR_LENGTH+1];
   SpiceDouble        * spoint;
   SpiceDouble          trgepc;
   SpiceDouble          srfvec[3];
   SpiceDouble          phase;
   SpiceDouble          solar;
   SpiceDouble          emissn;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "method", MiceChar,   0, {0}, 0},
      { "target", MiceChar,   0, {0}, 0},
      { "et",     MiceDouble, 0, {0}, 0},
      { "fixref", MiceChar,   0, {0}, 0},
      { "abcorr", MiceChar,   0, {0}, 0},
      { "obsrvr", MiceChar,   0, {0}, 0},
      { "spoint", MiceDouble, 1, {3}, 0},
      { "ilum",   MiceIlum,   0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 7, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], method, DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], target, DEFAULT_STR_LENGTH);

   et = S_DBL_ARGV(3);

   mxGetString(prhs[4], fixref, DEFAULT_STR_LENGTH);
   mxGetString(prhs[5], abcorr, DEFAULT_STR_LENGTH);
   mxGetString(prhs[6], obsrvr, DEFAULT_STR_LENGTH);

   spoint = A_DBL_ARGV(7);

   ilumin_c( method,
             target,
             et,
             fixref,
             abcorr,
             obsrvr,
             spoint,
             &trgepc,
             srfvec,
             &phase,
             &solar,
             &emissn );

   CHECK_CALL_FAILURE(SCALAR);

   mxDestroyArray( mxGetField( plhs[0], 0, "trgepc" ) );
   mxSetField( plhs[0], 0, "trgepc",  mxCreateDoubleScalar(trgepc) );

   memcpy( mxGetPr( mxGetField(plhs[0],0,"srfvec" ) ),
           srfvec,
           3*sizeof(SpiceDouble));

   mxDestroyArray( mxGetField( plhs[0], 0, "phase" ) );
   mxSetField( plhs[0], 0, "phase", mxCreateDoubleScalar(phase) );

   mxDestroyArray( mxGetField( plhs[0], 0, "incdnc" ) );
   mxSetField( plhs[0], 0, "incdnc", mxCreateDoubleScalar(solar) );

   mxDestroyArray( mxGetField( plhs[0], 0, "emissn" ) );
   mxSetField( plhs[0], 0, "emissn", mxCreateDoubleScalar(emissn) );

   }




/*
   void              inedpl_c ( SpiceDouble         a,
                                SpiceDouble         b,
                                SpiceDouble         c,
                                ConstSpicePlane   * plane,
                                SpiceEllipse      * ellips,
                                SpiceBoolean      * found    );
*/
void cspice_inedpl(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble          a;
   SpiceDouble          b;
   SpiceDouble          c;
   SpicePlane           plane;
   SpiceEllipse         ellips;
   SpiceBoolean       * found;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "a",       MiceDouble,  0, {0}, 0},
      { "b",       MiceDouble,  0, {0}, 0},
      { "c",       MiceDouble,  0, {0}, 0},
      { "plane",   MicePlane,   0, {0}, 0},
      { "ellips", MiceEllipse, 0, {0}, 0},
      { "found",   MiceBoolean, 0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 4, 2 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   a = S_DBL_ARGV(1);
   b = S_DBL_ARGV(2);
   c = S_DBL_ARGV(3);

   /*
   Assemble a plane structure from the input arguments.
   */
   memcpy( plane.normal,
           mxGetPr( mxGetField( prhs[4], 0, "normal") ),
           3*sizeof(SpiceDouble)
         );

   plane.constant = *mxGetPr( mxGetField( prhs[4], 0,"constant") );

   found  = A_BOOL_RET_ARGV(1);

   inedpl_c ( a, b, c, &plane, &ellips, found );
   CHECK_CALL_FAILURE(SCALAR);

   memcpy( mxGetPr( mxGetField( plhs[0], 0,"center") ),
           ellips.center,
           3*sizeof(SpiceDouble)
         );

   memcpy( mxGetPr( mxGetField( plhs[0], 0,"semiMajor") ),
           ellips.semiMajor,
           3*sizeof(SpiceDouble)
         );

   memcpy( mxGetPr( mxGetField( plhs[0], 0,"semiMinor") ),
           ellips.semiMinor,
           3*sizeof(SpiceDouble)
         );

   }




/*
   void              inelpl_c ( ConstSpiceEllipse * ellips,
                                ConstSpicePlane   * plane,
                                SpiceInt          * nxpts,
                                SpiceDouble         xpt1[3],
                                SpiceDouble         xpt2[3] );
*/
void cspice_inelpl(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceEllipse         ellips;
   SpicePlane           plane;
   SpiceInt           * nxpts;
   SpiceDouble        * xpt1;
   SpiceDouble        * xpt2;


   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "ellips", MiceEllipse, 0, {0}, 0},
      { "plane",  MicePlane,   0, {0}, 0},
      { "nxpts",  MiceInt,     0, {0}, 0},
      { "xpt1",   MiceDouble,  1, {3}, 0},
      { "xpt2",   MiceDouble,  1, {3}, 0},
      };

   check_arg_num( nrhs, nlhs, 2, 3 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   /*
   Assemble an ellipse structure from the input arguments.
   */
   memcpy( ellips.center,
           mxGetPr( mxGetField( prhs[1], 0,"center") ),
           3*sizeof(SpiceDouble)
         );

   memcpy( ellips.semiMajor,
           mxGetPr( mxGetField( prhs[1], 0,"semiMajor") ),
           3*sizeof(SpiceDouble)
         );

   memcpy( ellips.semiMinor,
           mxGetPr( mxGetField( prhs[1], 0,"semiMinor") ),
           3*sizeof(SpiceDouble)
         );


   /*
   Assemble a plane structure from the input arguments.
   */
   memcpy( plane.normal,
           mxGetPr( mxGetField( prhs[2], 0,"normal") ),
           3*sizeof(SpiceDouble)
         );

   plane.constant = *mxGetPr( mxGetField( prhs[2], 0,"constant") );

   nxpts = A_INT_RET_ARGV(0);
   xpt1  = A_DBL_RET_ARGV(1);
   xpt2  = A_DBL_RET_ARGV(2);

   inelpl_c ( &ellips, &plane, nxpts, xpt1, xpt2 );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              inrypl_c ( ConstSpiceDouble    vertex [3],
                                ConstSpiceDouble    dir    [3],
                                ConstSpicePlane   * plane,
                                SpiceInt          * nxpts,
                                SpiceDouble         xpt    [3] );
*/
void cspice_inrypl(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vertex;
   SpiceDouble        * dir;
   SpicePlane           plane;
   SpiceInt           * nxpts;
   SpiceDouble        * xpt;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "vertex", MiceDouble,  1, {3}, 0},
      { "dir",    MiceDouble,  1, {3}, 0},
      { "plane",  MicePlane,   0, {0}, 0},
      { "nxpts",  MiceInt,     0, {0}, 0},
      { "xpt1",   MiceDouble,  1, {3}, 0},
      };

   check_arg_num( nrhs, nlhs, 3, 2 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vertex = A_DBL_ARGV(1);
   dir    = A_DBL_ARGV(2);

   /*
   Assemble a plane structure from the input arguments.
   */
   memcpy( plane.normal,
           mxGetPr( mxGetField( prhs[3], 0, "normal") ),
           3*sizeof(SpiceDouble)
         );

   plane.constant = *mxGetPr( mxGetField( prhs[3], 0,"constant") );

   nxpts = A_INT_RET_ARGV(0);
   xpt   = A_DBL_RET_ARGV(1);

   inrypl_c ( vertex, dir, &plane, nxpts, xpt );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   SpiceInt intmax_c ()
*/
void cspice_intmax(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   check_arg_num( nrhs, nlhs, 0, 1 );

   /*
   Directly return the scalar value. This simple case needs no
   error checks.
   */
   plhs[0] = mxCreateDoubleScalar( intmax_c() );

   }




/*
   SpiceInt intmin_c ()
*/
void cspice_intmin(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   check_arg_num( nrhs, nlhs, 0, 1 );

   /*
   Directly return the scalar value. This simple case needs no
   error checks.
   */
   plhs[0] = mxCreateDoubleScalar( intmin_c() );

   }




/*
   void              invort_c ( ConstSpiceDouble    m  [3][3],
                                SpiceDouble         mit[3][3] );
*/
void cspice_invort(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * m;
   SpiceDouble        * mit;
   SpiceDouble          xr[3][3];
   SpiceDouble          yr[3][3];

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "m",    MiceDouble, 2, {3, 3}, 0},
      { "mit",  MiceDouble, 2, {3, 3}, 0},
      };

   check_arg_num( nrhs, nlhs, 1, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   m    = A_DBL_ARGV(1);
   mit  = A_DBL_RET_ARGV(0);

   xpose_c( m, (SpiceDouble(*)[3])yr);

   invort_c( yr, (SpiceDouble(*)[3])xr);
   CHECK_CALL_FAILURE(SCALAR);

   xpose_c( xr, (SpiceDouble(*)[3])mit);

   }




/*
   void invstm_c ( ConstSpiceDouble    mat    [6][6],
                   SpiceDouble         invmat [6][6] )
*/
void cspice_invstm(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * mat;
   SpiceDouble          matC [6][6];
   SpiceDouble        * invmat;
   SpiceDouble          ret_invmat[6][6];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "mat",     MiceDouble,   2, {6,6}, 0},
      { "invmat",  MiceDouble,   2, {6,6}, 0},
      };

   check_arg_num( nrhs, nlhs, 1, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mat      = A_DBL_ARGV(1);

   invmat   = A_DBL_RET_ARGV(0);

   xpose6_c ( mat, matC);

   invstm_c ( matC, ret_invmat );
   CHECK_CALL_FAILURE(SCALAR);

   xpose6_c ( ret_invmat, (SpiceDouble(*)[6])invmat );

   }




/*
   SpiceDouble       j1900_c  ( void )
*/
void cspice_j1900(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   check_arg_num( nrhs, nlhs, 0, 1 );

   /*
   Directly return the scalar value. This simple case needs no
   error checks.
   */
   plhs[0] = mxCreateDoubleScalar( j1900_c() );

   }




/*
   SpiceDouble       j1950_c  ( void )
*/
void cspice_j1950(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   check_arg_num( nrhs, nlhs, 0, 1 );

   /*
   Directly return the scalar value. This simple case needs no
   error checks.
   */
   plhs[0] = mxCreateDoubleScalar( j1950_c() );

   }




/*
   SpiceDouble       j2000_c  ( void )
*/
void cspice_j2000(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   check_arg_num( nrhs, nlhs, 0, 1 );

   /*
   Directly return the scalar value. This simple case needs no
   error checks.
   */
   plhs[0] = mxCreateDoubleScalar( j2000_c() );

   }




/*
   SpiceDouble       j2100_c  ( void )
*/
void cspice_j2100(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   check_arg_num( nrhs, nlhs, 0, 1 );

   /*
   Directly return the scalar value. This simple case needs no
   error checks.
   */
   plhs[0] = mxCreateDoubleScalar( j2100_c() );

   }




/*
   SpiceDouble       jyear_c  ( void )
*/
void cspice_jyear(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   check_arg_num( nrhs, nlhs, 0, 1 );

   /*
   Directly return the scalar value. This simple case needs no
   error checks.
   */
   plhs[0] = mxCreateDoubleScalar( jyear_c() );

   }




/*
   void              kclear_c( void )
*/
void cspice_kclear(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   check_arg_num( nrhs, nlhs, 0, 0 );

   /*
   Not much to do, make the call.
   */
   kclear_c();

   }




/*
   void              kdata_c  ( SpiceInt          which,
                                ConstSpiceChar  * kind,
                                SpiceInt          fillen,
                                SpiceInt          typlen,
                                SpiceInt          srclen,
                                SpiceChar       * file,
                                SpiceChar       * filtyp,
                                SpiceChar       * srcfil,
                                SpiceInt        * handle,
                                SpiceBoolean    * found   );
*/
void cspice_kdata(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             which;
   SpiceChar            kind  [DEFAULT_STR_LENGTH+1];
   SpiceChar            file  [DEFAULT_STR_LENGTH+1];
   SpiceChar            filtyp[DEFAULT_STR_LENGTH+1];
   SpiceChar            srcfil[DEFAULT_STR_LENGTH+1];
   SpiceInt           * handle;
   SpiceBoolean       * found;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "which",  MiceInt,     0, {0}, 0},
      { "kind",   MiceChar,    0, {0}, 0},
      { "file",   MiceChar,    0, {0}, 0},
      { "filtyp", MiceChar,    0, {0}, 0},
      { "srcfil", MiceChar,    0, {0}, 0},
      { "handle", MiceInt,     0, {0}, 0},
      { "found",  MiceBoolean, 0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 2, 5 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   /*
   MATLAB uses a base 1 array index convention, as is proper,
   C does not, which is weird. Subtract one off the 'which' index.
   */
   which = S_INT_ARGV(1) - 1;
   mxGetString(prhs[2], kind, DEFAULT_STR_LENGTH);

   handle = A_INT_RET_ARGV(3);
   found  = A_BOOL_RET_ARGV(4);

   kdata_c( which,
            kind,
            DEFAULT_STR_LENGTH,
            DEFAULT_STR_LENGTH,
            DEFAULT_STR_LENGTH,
            file,
            filtyp,
            srcfil,
            handle,
            found);

   if( *found )
      {
      plhs[0] = mxCreateString( file   );
      plhs[1] = mxCreateString( filtyp );
      plhs[2] = mxCreateString( srcfil );
      }
   else
      {
      plhs[0] = mxCreateString( "\0" );
      plhs[1] = mxCreateString( "\0" );
      plhs[2] = mxCreateString( "\0" );
      }

   if ( plhs[0] == NULL )
      {
      mexErrMsgTxt(
         "MICE(BUG): mxCreateString failed in cspice_kdata: plhs[0]" );
      }
   if ( plhs[1] == NULL )
      {
      mexErrMsgTxt(
         "MICE(BUG): mxCreateString failed in cspice_kdata: plhs[1]" );
      }
   if ( plhs[2] == NULL )
      {
      mexErrMsgTxt(
         "MICE(BUG): mxCreateString failed in cspice_kdata: plhs[2]" );
      }

   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              kinfo_c  ( ConstSpiceChar  * file,
                                SpiceInt          typlen,
                                SpiceInt          srclen,
                                SpiceChar       * filtyp,
                                SpiceChar       * srcfil,
                                SpiceInt        * handle,
                                SpiceBoolean    * found  )
*/
void cspice_kinfo(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            file  [DEFAULT_STR_LENGTH+1];
   SpiceChar            filtyp[DEFAULT_STR_LENGTH+1];
   SpiceChar            srcfil[DEFAULT_STR_LENGTH+1];
   SpiceInt           * handle;
   SpiceBoolean       * found;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "file",   MiceChar,    0, {0}, 0},
      { "filtyp", MiceChar,    0, {0}, 0},
      { "srcfil", MiceChar,    0, {0}, 0},
      { "handle", MiceInt,     0, {0}, 0},
      { "found",  MiceBoolean, 0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 1, 4 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], file, DEFAULT_STR_LENGTH);

   handle = A_INT_RET_ARGV(2);
   found  = A_BOOL_RET_ARGV(3);

   kinfo_c( file,
            DEFAULT_STR_LENGTH,
            DEFAULT_STR_LENGTH,
            filtyp,
            srcfil,
            handle,
            found);

   plhs[0] = mxCreateString( filtyp );
   if ( plhs[0] == NULL )
      {
      mexErrMsgTxt( "MICE(BUG): mxCreateString failed in cspice_kinfo" );
      }

   plhs[1] = mxCreateString( srcfil );
   if ( plhs[1] == NULL )
      {
      mexErrMsgTxt( "MICE(BUG): mxCreateString failed in cspice_kinfo" );
      }


   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void kplfrm_c ( SpiceInt      frmcls,
                   SpiceCell   * idset   )
*/
void cspice_kplfrm(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             frmcls;
   SpiceInt             room;
   SpiceInt           * idset;
   SpiceInt           * idset_f;
   mwSize               sizearr_idset[2];

   /*
   Initialize the cells with zero size and zero cardinality.
   */
   SpiceCell           idset_cell  = { SPICE_INT,
                                       0,
                                       0,
                                       0,
                                       SPICETRUE,
                                       SPICEFALSE,
                                       SPICEFALSE,
                                       NULL,
                                       NULL };


   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "frmcls",  MiceInt,      0, {0},   0},
      { "room",    MiceInt,      0, {0},   0},
      { "idset",   MiceIgnore,   0, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   frmcls   = S_INT_ARGV(1);
   room     = S_INT_ARGV(2);

   /*
   mxMalloc returns to top level on error.
   */
   idset = (SpiceInt*)
            mxMalloc( (room + SPICE_CELL_CTRLSZ)*sizeof(SpiceInt) );

   /*
   Set the struct fields to initialize the 'idset_cell' cell.
   The cardinality remains zero as this assignment occurs prior
   to use.
   */
   idset_cell.size = room;
   idset_cell.base = idset;
   idset_cell.data = &idset[SPICE_CELL_CTRLSZ];


   kplfrm_c ( frmcls, &idset_cell );

   /*
   Check for a failure signal. Free the memory assigned to 'idset'
   before signaling a Matlab error.
   */
   if ( failed_c())
      {
      mxFree( idset );

      /*
      The mice_fail call creates the error string then returns control
      to the MATLAB interpreter.
      */
      mice_fail(SCALAR);
      }

   /*
   Create an output array CARDx1.
   */
   sizearr_idset[0] = card_c( &idset_cell );
   sizearr_idset[1] = 1;

   plhs[0]  = mxCreateNumericArray( 2, sizearr_idset, mxINT32_CLASS, mxREAL);
   idset_f  = A_INT_RET_ARGV(0);

   /*
   Copy the data contents of 'idset' to 'idset_f'. The set of window data
   starts at 'idset' array index SPICE_CELL_CTRLSZ and contains
   'sizearr_idset[0]' elements.
   */
   MOVEI( idset + SPICE_CELL_CTRLSZ, sizearr_idset[0], idset_f );

   mxFree( idset );

   }




/*
   void              ktotal_c ( ConstSpiceChar   * kind,
                                SpiceInt         * count )
*/
void cspice_ktotal(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            kind[DEFAULT_STR_LENGTH+1];
   SpiceInt           * count;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "kind",  MiceChar, 0, {0}, 0},
      { "count", MiceInt,  0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 1, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   count = A_INT_RET_ARGV(0);

   mxGetString(prhs[1], kind, DEFAULT_STR_LENGTH);

   ktotal_c( kind, count);
   CHECK_CALL_FAILURE(SCALAR);

   }





/*
   void                latcyl_c( SpiceDouble    radius,
                                 SpiceDouble    lon,
                                 SpiceDouble    lat,
                                 SpiceDouble *  r,
                                 SpiceDouble *  clon,
                                 SpiceDouble *  z )
*/
void cspice_latcyl(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_radius;
   SpiceDouble        * vec_lon;
   SpiceDouble        * vec_lat;
   SpiceDouble        * vec_r;
   SpiceDouble        * vec_clon;
   SpiceDouble        * vec_z;
   SpiceDouble          radius;
   SpiceDouble          lon;
   SpiceDouble          lat;
   SpiceDouble        * r;
   SpiceDouble        * clon;
   SpiceDouble        * z;

   mwIndex              i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "radius", MiceDouble, 0, {0}, 1},
      { "lon",    MiceDouble, 0, {0}, 1},
      { "lat",    MiceDouble, 0, {0}, 1},
      { "r",      MiceDouble, 0, {0}, 1},
      { "clon",   MiceDouble, 0, {0}, 1},
      { "z",      MiceDouble, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 3, 3 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_radius = A_DBL_ARGV(1);
   vec_lon    = A_DBL_ARGV(2);
   vec_lat    = A_DBL_ARGV(3);
   vec_r      = A_DBL_RET_ARGV(0);
   vec_clon   = A_DBL_RET_ARGV(1);
   vec_z      = A_DBL_RET_ARGV(2);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         radius = *(vec_radius + i*extra->offset[0]);
         lon    = *(vec_lon    + i*extra->offset[1]);
         lat    = *(vec_lat    + i*extra->offset[2]);
         r      =  (vec_r      + i*extra->offset[3]);
         clon   =  (vec_clon   + i*extra->offset[4]);
         z      =  (vec_z      + i*extra->offset[5]);

         latcyl_c(radius, lon, lat, r, clon, z);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {

      radius = *(vec_radius);
      lon    = *(vec_lon);
      lat    = *(vec_lat);
      r      =  (vec_r);
      clon   =  (vec_clon);
      z      =  (vec_z);

      latcyl_c(radius, lon, lat, r, clon, z);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void              latrec_c( SpiceDouble    radius,
                               SpiceDouble    lon,
                               SpiceDouble    lat,
                               SpiceDouble    rectan[3] )
*/
void cspice_latrec(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_radius;
   SpiceDouble        * vec_lon;
   SpiceDouble        * vec_lat;
   SpiceDouble        * vec_rectan;
   SpiceDouble          radius;
   SpiceDouble          lon;
   SpiceDouble          lat;
   SpiceDouble        * rectan;

   mwIndex              i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "radius", MiceDouble, 0, {0}, 1},
      { "lon",    MiceDouble, 0, {0}, 1},
      { "lat",    MiceDouble, 0, {0}, 1},
      { "rectan", MiceDouble, 1, {3}, 1},
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra = mice_checkargs(nlhs, plhs, nrhs, prhs, ArgCheck);

   vec_radius = A_DBL_ARGV(1);
   vec_lon    = A_DBL_ARGV(2);
   vec_lat    = A_DBL_ARGV(3);
   vec_rectan = A_DBL_RET_ARGV(0);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         radius = *(vec_radius + i*extra->offset[0]);
         lon    = *(vec_lon    + i*extra->offset[1]);
         lat    = *(vec_lat    + i*extra->offset[2]);
         rectan =  (vec_rectan + i*extra->offset[3]);

         latrec_c(radius, lon, lat, rectan);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {
      radius = *(vec_radius);
      lon    = *(vec_lon);
      lat    = *(vec_lat);
      rectan =  (vec_rectan);

      latrec_c(radius, lon, lat, rectan);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void              latsph_c( SpiceDouble    radius,
                               SpiceDouble    lon,
                               SpiceDouble    lat,
                               SpiceDouble *  rho,
                               SpiceDouble *  colat,
                               SpiceDouble *  slon )
*/
void cspice_latsph(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_radius;
   SpiceDouble        * vec_lon;
   SpiceDouble        * vec_lat;
   SpiceDouble        * vec_rho;
   SpiceDouble        * vec_colat;
   SpiceDouble        * vec_slon;
   SpiceDouble          radius;
   SpiceDouble          lon;
   SpiceDouble          lat;
   SpiceDouble        * rho;
   SpiceDouble        * colat;
   SpiceDouble        * slon;

   mwIndex              i;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "radius", MiceDouble, 0, {0}, 1},
      { "lon",    MiceDouble, 0, {0}, 1},
      { "lat",    MiceDouble, 0, {0}, 1},
      { "rho",    MiceDouble, 0, {0}, 1},
      { "colat",  MiceDouble, 0, {0}, 1},
      { "slon",   MiceDouble, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 3, 3 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_radius = A_DBL_ARGV(ONE_IN  );
   vec_lon    = A_DBL_ARGV(TWO_IN  );
   vec_lat    = A_DBL_ARGV(THREE_IN);

   vec_rho    = A_DBL_RET_ARGV(ONE_OUT  );
   vec_colat  = A_DBL_RET_ARGV(TWO_OUT  );
   vec_slon   = A_DBL_RET_ARGV(THREE_OUT);

   radius     = *vec_radius;
   lon        = *vec_lon;
   lat        = *vec_lat;
   rho        =  vec_rho;
   colat      =  vec_colat;
   slon       =  vec_slon;

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         radius = *(vec_radius + i*extra->offset[ONE_OFF  ]);
         lon    = *(vec_lon    + i*extra->offset[TWO_OFF  ]);
         lat    = *(vec_lat    + i*extra->offset[THREE_OFF]);
         rho    =  (vec_rho    + i*extra->offset[FOUR_OFF ]);
         colat  =  (vec_colat  + i*extra->offset[FIVE_OFF ]);
         slon   =  (vec_slon   + i*extra->offset[SIX_OFF  ]);

         latsph_c(radius, lon, lat, rho, colat, slon);
         CHECK_CALL_FAILURE(i)
         }

      }
   else
      {

      latsph_c(radius, lon, lat, rho, colat, slon);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void              latsrf_c ( ConstSpiceChar     * method,
                                ConstSpiceChar     * target,
                                SpiceDouble          et,
                                ConstSpiceChar     * fixref,
                                SpiceInt             npts,
                                ConstSpiceDouble     lonlat[][2],
                                SpiceDouble          srfpts[][3]  )
*/
void cspice_latsrf(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            method [DEFAULT_STR_LENGTH+1];
   SpiceChar            target [DEFAULT_STR_LENGTH+1];
   SpiceDouble          et;
   SpiceChar            fixref [DEFAULT_STR_LENGTH+1];
   SpiceInt             npts;
   ConstSpiceDouble   * lonlat;
   SpiceDouble       (* srfpts)[3] = 0;

   SpiceDouble        * dvals_ret;

   mwSize               sizearray[2];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "method", MiceChar,   0, {0},   0},
      { "target", MiceChar,   0, {0},   0},
      { "et",     MiceDouble, 0, {0},   0},
      { "fixref", MiceChar,   0, {0},   0},
      { "lonlat", MiceDouble, 2, {2,0}, 0},
      { "srfpts", MiceIgnore, 0, {0},   0}
      };

   check_arg_num( nrhs, nlhs, 5, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], method, DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], target, DEFAULT_STR_LENGTH);
   mxGetString(prhs[4], fixref, DEFAULT_STR_LENGTH);

   et      = S_DBL_ARGV(3);

   lonlat  = (ConstSpiceDouble   *)mxGetData(prhs[5]);

   npts    = mxGetNumberOfElements( prhs[5] )/2;

   if ( npts > 0 )
      {
      srfpts  = (SpiceDouble (*)[3] )mxMalloc(3 * npts * sizeof(SpiceDouble) );

      latsrf_c ( method,
                 target,
                 et,
                 fixref,
                 npts,
                 (Nx2d)lonlat,
                 srfpts );

      if ( failed_c() )
         {
         mxFree( srfpts );
         /*
         The mice_fail call creates the error string then returns control
         to the MATLAB interpreter.
         */
         mice_fail(SCALAR);
         }

      sizearray[0] = 3;
      sizearray[1] = npts;
      }
   else
      {
      sizearray[0] = 0;
      sizearray[1] = 0;
      }

   plhs[0]   = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
   dvals_ret = A_DBL_RET_ARGV(0);

   if ( npts > 0 )
      {
      MOVED( (SpiceDouble *)srfpts, 3*npts, dvals_ret );

      /*
      We allocated space for `npt' normals; deallocate this space now.
      */
      mxFree( srfpts );
      }

   }




/*
   void ldpool_c ( ConstSpiceChar * fname )
*/
void cspice_ldpool(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            fname  [DEFAULT_STR_LENGTH+1];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "fname",   MiceChar,     0, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 1, 0 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], fname, DEFAULT_STR_LENGTH);


   ldpool_c ( fname );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   SpiceDouble lgresp_c ( SpiceInt            n,
                          SpiceDouble         first,
                          SpiceDouble         step,
                          ConstSpiceDouble    yvals  [],
                          SpiceDouble         x         )
*/
void cspice_lgresp(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             n;
   SpiceDouble          first;
   SpiceDouble          step;
   ConstSpiceDouble   * yvals;
   SpiceDouble          x;
   SpiceDouble        * lgresp;

   SpiceInt             yvalen;

   /* The message buffer to write an error message */
   char                 msg[1024];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "n",       MiceInt,      0, {0},   0},
      { "first",   MiceDouble,   0, {0},   0},
      { "step",    MiceDouble,   0, {0},   0},
      { "yvals",   MiceDouble,   1, {0},   0},
      { "x",       MiceDouble,   0, {0},   0},
      { "lgresp",  MiceDouble,   0, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 5, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   n        = S_INT_ARGV(1);
   first    = S_DBL_ARGV(2);
   step     = S_DBL_ARGV(3);
   yvals    = A_DBL_ARGV(4);
   x        = S_DBL_ARGV(5);

   /*
   Check that `yvals' has enough data.
   */
   yvalen  = A_LEN_ARGV(4);

   if ( yvalen < n )
   {
      sprintf( msg, "MICE(INSUFFICIENTDATA): `yvals` does not have enough "
               "data: %ld elements required; only %ld provided.",
               (long)n, (long)yvalen );
      mexErrMsgTxt( msg );
   }

   lgresp   = A_DBL_RET_ARGV(0);

   *lgresp = lgresp_c ( n, first, step, yvals, x );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void lgrind_c ( SpiceInt            n,
                   ConstSpiceDouble  * xvals,
                   ConstSpiceDouble  * yvals,
                   SpiceDouble       * work,
                   SpiceDouble         x,
                   SpiceDouble       * p,
                   SpiceDouble       * dp )
*/
void cspice_lgrind(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             n;
   ConstSpiceDouble   * xvals;
   ConstSpiceDouble   * yvals;

   SpiceInt             nWork;
   SpiceDouble        * work;
   SpiceDouble          x;
   SpiceDouble        * p;
   SpiceDouble        * dp;

   SpiceInt             xvalen;
   SpiceInt             yvalen;

   /* The message buffer to write an error message */
   char                 msg[1024];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "n",       MiceInt,      0, {0},   0},
      { "xvals",   MiceDouble,   1, {0},   0},
      { "yvals",   MiceDouble,   1, {0},   0},
      { "x",       MiceDouble,   0, {0},   0},
      { "p",       MiceDouble,   0, {0},   0},
      { "dp",      MiceDouble,   0, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 4, 2 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   n        = S_INT_ARGV(1);
   xvals    = A_DBL_ARGV(2);
   yvals    = A_DBL_ARGV(3);
   x        = S_DBL_ARGV(4);

   /*
   Check that `xvals' has enough data.
   */
   xvalen  = A_LEN_ARGV(2);

   if ( xvalen < n )
   {
      sprintf( msg, "MICE(INSUFFICIENTDATA): `xvals` does not have enough "
               "data: %ld elements required; only %ld provided.",
               (long)n, (long)xvalen );
      mexErrMsgTxt( msg );
   }

   /*
   Check that `yvals' has enough data.
   */
   yvalen  = A_LEN_ARGV(3);

   if ( yvalen < n )
   {
      sprintf( msg, "MICE(INSUFFICIENTDATA): `yvals` does not have enough "
               "data: %ld elements required; only %ld provided.",
               (long)n, (long)yvalen );
      mexErrMsgTxt( msg );
   }

   /*
   Allocate the workspace.

   This gateway is not following the standard approach when it comes to
   producing gateways for CSPICE wrappers of SPICELIB routines that use
   workspaces.

   Normally, the workspaces required by SPICELIB code are allocated
   within the CSPICE code, and the Mice gateways are just calling
   CSPICE, without dealing with that memory allocation.

   In the case of cspice_lgrind, CSPICE does not allocate memory for the
   workspace. Instead, it requires the user to provide as input to the
   routines the workspace, and therefore the Mice gateway code must do it.

   We use mxMalloc to create a 1-dimensional array of nWork elements.
   mxMalloc returns to top level in case of error.
   */
   nWork = 2 * n;
   work  = (SpiceDouble*) mxMalloc( nWork * sizeof(SpiceDouble) );

   p        = A_DBL_RET_ARGV(0);
   dp       = A_DBL_RET_ARGV(1);

   lgrind_c ( n, xvals, yvals, work, x, p, dp );

   /*
   Free workspace memory.
   */
   mxFree( work );

   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   SpiceDouble lgrint_c ( SpiceInt            n,
                          ConstSpiceDouble    xvals  [],
                          ConstSpiceDouble    yvals  [],
                          SpiceDouble         x         )
*/
void cspice_lgrint(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             n;
   ConstSpiceDouble   * xvals;
   ConstSpiceDouble   * yvals;
   SpiceDouble          x;
   SpiceDouble        * lgrint;

   SpiceInt             xvalen;
   SpiceInt             yvalen;

   /* The message buffer to write an error message */
   char                 msg[1024];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "n",       MiceInt,      0, {0},   0},
      { "xvals",   MiceDouble,   1, {0},   0},
      { "yvals",   MiceDouble,   1, {0},   0},
      { "x",       MiceDouble,   0, {0},   0},
      { "lgrint",  MiceDouble,   0, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 4, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   n        = S_INT_ARGV(1);
   xvals    = A_DBL_ARGV(2);
   yvals    = A_DBL_ARGV(3);
   x        = S_DBL_ARGV(4);

   /*
   Check that `xvals' has enough data.
   */
   xvalen  = A_LEN_ARGV(2);

   if ( xvalen < n )
   {
      sprintf( msg, "MICE(INSUFFICIENTDATA): `xvals` does not have enough "
               "data: %ld elements required; only %ld provided.",
               (long)n, (long)xvalen );
      mexErrMsgTxt( msg );
   }

   /*
   Check that `yvals' has enough data.
   */
   yvalen  = A_LEN_ARGV(3);

   if ( yvalen < n )
   {
      sprintf( msg, "MICE(INSUFFICIENTDATA): `yvals` does not have enough "
               "data: %ld elements required; only %ld provided.",
               (long)n, (long)yvalen );
      mexErrMsgTxt( msg );
   }

   lgrint   = A_DBL_RET_ARGV(0);

   *lgrint = lgrint_c ( n, xvals, yvals, x );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void limb_pl02 ( SpiceInt              handle,
                    ConstSpiceDLADescr  * dladsc,
                    ConstSpiceChar      * target,
                    SpiceDouble           et,
                    ConstSpiceChar      * fixfrm,
                    ConstSpiceChar      * abcorr,
                    ConstSpiceChar      * obsrvr,
                    SpiceInt              npoints,
                    SpiceDouble         * trgepc,
                    SpiceDouble           obspos   [3],
                    SpiceDouble           limbpts  [][3],
                    SpiceInt              plateIDs []     )

 */
void cspice_limb_pl02(int nlhs, mxArray *plhs[], int nrhs,
                      const mxArray *prhs[])
   {
   SpiceInt             handle;
   SpiceDLADescr        local_dladsc;
   SpiceInt           * dladsc;
   SpiceChar            target[DEFAULT_STR_LENGTH+1];
   SpiceDouble          et;
   SpiceChar            fixfrm[DEFAULT_STR_LENGTH+1];
   SpiceChar            abcorr[DEFAULT_STR_LENGTH+1];
   SpiceChar            obsrvr[DEFAULT_STR_LENGTH+1];
   SpiceInt             npoints;
   SpiceDouble        * trgepc;
   SpiceDouble        * obspos;
   SpiceDouble      ( * limbpts )[3];
   SpiceInt           * plateIDs;

   mwSize               size_limbpts [2];
   mwSize               size_plateIDs[2];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle",   MiceInt,     0, {0},                0},
      { "dladsc",   MiceInt,     1, {SPICE_DLA_DSCSIZ}, 0},
      { "target",   MiceChar,    0, {0},                0},
      { "et",       MiceDouble,  0, {0},                0},
      { "fixfrm",   MiceChar,    0, {0},                0},
      { "abcorr",   MiceChar,    0, {0},                0},
      { "obsrvr",   MiceChar,    0, {0},                0},
      { "npoints",  MiceInt,     0, {0},                0},
      { "trgepc",   MiceDouble,  0, {0},                0},
      { "obspos",   MiceDouble,  1, {3},                0},
      { "limbpts",  MiceIgnore,  0, {0},                0},
      { "plateIDs", MiceIgnore,  0, {0},                0}
      };

   check_arg_num( nrhs, nlhs, 8, 4 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle  = S_INT_ARGV(1);
   dladsc  = A_INT_ARGV(2);

   local_dladsc.bwdptr = dladsc[SPICE_DLA_BWDIDX];
   local_dladsc.fwdptr = dladsc[SPICE_DLA_FWDIDX];
   local_dladsc.ibase  = dladsc[SPICE_DLA_IBSIDX];
   local_dladsc.isize  = dladsc[SPICE_DLA_ISZIDX];
   local_dladsc.dbase  = dladsc[SPICE_DLA_DBSIDX];
   local_dladsc.dsize  = dladsc[SPICE_DLA_DSZIDX];
   local_dladsc.cbase  = dladsc[SPICE_DLA_CBSIDX];
   local_dladsc.csize  = dladsc[SPICE_DLA_CSZIDX];

   mxGetString(prhs[3], target, DEFAULT_STR_LENGTH);

   et = S_DBL_ARGV(4);

   mxGetString(prhs[5], fixfrm, DEFAULT_STR_LENGTH);
   mxGetString(prhs[6], abcorr, DEFAULT_STR_LENGTH);
   mxGetString(prhs[7], obsrvr, DEFAULT_STR_LENGTH);

   npoints = S_INT_ARGV(8);

   trgepc  = A_DBL_RET_ARGV(0);
   obspos  = A_DBL_RET_ARGV(1);

   if( npoints <= 0 )
      {
      mexErrMsgTxt( "MICE(INVALIDSIZE): `npoints` must "
                    "be greater-than zero." );
      }

   if ( npoints > 0 )
      {
      size_limbpts[0]  = 3;
      size_limbpts[1]  = npoints;

      size_plateIDs[0] = 1;
      size_plateIDs[1] = npoints;
      }
   else
      {
      size_limbpts[0]  = 0;
      size_limbpts[1]  = 0;

      size_plateIDs[0] = 0;
      size_plateIDs[1] = 0;
      }


   plhs[2]  = mxCreateNumericArray( 2, size_limbpts,  mxDOUBLE_CLASS, mxREAL);
   limbpts  = (SpiceDouble (*)[3])A_DBL_RET_ARGV(2);

   plhs[3]  = mxCreateNumericArray( 2, size_plateIDs, mxINT32_CLASS, mxREAL);
   plateIDs = (SpiceInt *)A_INT_RET_ARGV(3);

   if ( npoints > 0 )
      {
      limb_pl02 ( handle, &local_dladsc, target,  et,     fixfrm,  abcorr,
                  obsrvr, npoints,       trgepc,  obspos, limbpts, plateIDs );
      }

   CHECK_CALL_FAILURE(SCALAR);
   }




/*
   void            limbpt_c ( ConstSpiceChar    * method,
                              ConstSpiceChar    * target,
                              SpiceDouble         et,
                              ConstSpiceChar    * fixref,
                              ConstSpiceChar    * abcorr,
                              ConstSpiceChar    * corloc,
                              ConstSpiceChar    * obsrvr,
                              ConstSpiceDouble    refvec[3],
                              SpiceDouble         rolstp,
                              SpiceInt            ncuts,
                              SpiceDouble         schstp,
                              SpiceDouble         soltol,
                              SpiceInt            maxn,
                              SpiceInt          * npts,
                              SpiceDouble         points[][3],
                              SpiceDouble         epochs[],
                              SpiceDouble         tangts[][3]  )
*/
void cspice_limbpt(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar               method [DEFAULT_STR_LENGTH+1];
   SpiceChar               target [DEFAULT_STR_LENGTH+1];
   SpiceDouble             et;
   SpiceChar               fixref [DEFAULT_STR_LENGTH+1];
   SpiceChar               abcorr [DEFAULT_STR_LENGTH+1];
   SpiceChar               corloc [DEFAULT_STR_LENGTH+1];
   SpiceChar               obsrvr [DEFAULT_STR_LENGTH+1];
   SpiceDouble           * refvec;
   SpiceDouble             rolstp;
   SpiceInt                ncuts;
   SpiceDouble             schstp;
   SpiceDouble             soltol;
   SpiceInt                maxn;
   SpiceInt              * npts;
   SpiceDouble          (* points)[3] = 0;
   SpiceDouble           * epochs;
   SpiceDouble          (* tangts)[3] = 0;

   SpiceDouble           * dvals0_ret;
   SpiceDouble           * dvals1_ret;
   SpiceDouble           * dvals2_ret;
   SpiceDouble           * dvals3_ret;

   mwSize                  sizearray[2];


   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "method", MiceChar,    0, { 0 },    0},
      { "target", MiceChar,    0, { 0 },    0},
      { "et",     MiceDouble,  0, { 0 },    0},
      { "fixref", MiceChar,    0, { 0 },    0},
      { "abcorr", MiceChar,    0, { 0 },    0},
      { "corloc", MiceChar,    0, { 0 },    0},
      { "obsrvr", MiceChar,    0, { 0 },    0},
      { "refvec", MiceDouble,  1, { 3 },    0},
      { "rolstp", MiceDouble,  0, { 0 },    0},
      { "ncuts",  MiceInt,     0, { 0 },    0},
      { "schstp", MiceDouble,  0, { 0 },    0},
      { "soltol", MiceDouble,  0, { 0 },    0},
      { "maxn",   MiceInt,     0, { 0 },    0},
      { "npts",   MiceIgnore,  0, { 0 },    0},
      { "points", MiceIgnore,  0, { 0 },    0},
      { "epochs", MiceIgnore,  0, { 0 },    0},
      { "tangts", MiceIgnore,  0, { 0 },    0},
      };

   check_arg_num( nrhs, nlhs, 13, 4 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], method, DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], target, DEFAULT_STR_LENGTH);

   et = S_DBL_ARGV(3);

   mxGetString(prhs[4], fixref, DEFAULT_STR_LENGTH);
   mxGetString(prhs[5], abcorr, DEFAULT_STR_LENGTH);
   mxGetString(prhs[6], corloc, DEFAULT_STR_LENGTH);
   mxGetString(prhs[7], obsrvr, DEFAULT_STR_LENGTH);

   refvec = A_DBL_ARGV( 8 );

   rolstp = S_DBL_ARGV(9);
   ncuts  = S_INT_ARGV(10);
   schstp = S_DBL_ARGV(11);
   soltol = S_DBL_ARGV(12);

   maxn   = S_INT_ARGV(13);

   if ( maxn > 0 )
      {

      npts  = (SpiceInt * )mxMalloc( maxn * sizeof(SpiceInt) );
      memset( npts,  0, maxn * sizeof(SpiceInt) );

      points  = (SpiceDouble (*)[3] )mxMalloc(3 * maxn * sizeof(SpiceDouble) );
      memset( points,  0, 3 * maxn * sizeof(SpiceDouble) );

      epochs  = (SpiceDouble *)mxMalloc(maxn * sizeof(SpiceDouble)  );
      memset( epochs,  0, maxn * sizeof(SpiceDouble) );

      tangts  = (SpiceDouble (*)[3] )mxMalloc(3 * maxn * sizeof(SpiceDouble) );
      memset( tangts,  0, 3 * maxn * sizeof(SpiceDouble) );

      limbpt_c ( method,    target, et,
                 fixref,    abcorr, corloc, obsrvr,
                 refvec,    rolstp, ncuts,  schstp,
                 soltol,    maxn,   npts,  points,
                 epochs,    tangts                  );

      if ( failed_c() )
         {
         mxFree( npts );
         mxFree( points );
         mxFree( epochs );
         mxFree( tangts );


         /*
         The mice_fail call creates the error string then returns control
         to the MATLAB interpreter.
         */
         mice_fail(SCALAR);
         }

      sizearray[0] = 3;
      sizearray[1] = maxn;

      plhs[1] = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
      dvals1_ret = A_DBL_RET_ARGV(1);

      MOVED( (SpiceDouble *)points, 3*maxn, dvals1_ret );


      plhs[3] = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
      dvals3_ret = A_DBL_RET_ARGV(3);

      MOVED( (SpiceDouble *)tangts, 3*maxn, dvals3_ret );


      sizearray[0] = 1;
      sizearray[1] = maxn;

      plhs[0] = mxCreateNumericArray( 2, sizearray, mxINT32_CLASS, mxREAL);
      dvals0_ret = A_DBL_RET_ARGV(0);

      MOVEI( (SpiceInt *)npts, maxn, dvals0_ret );


      plhs[2] = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
      dvals2_ret = A_DBL_RET_ARGV(2);

      MOVED( (SpiceDouble *)epochs, maxn, dvals2_ret );

      mxFree( npts );
      mxFree( points );
      mxFree( epochs );
      mxFree( tangts );

      }
   else
      {

      sizearray[0] = 0;
      sizearray[1] = 0;

      plhs[0] = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
      dvals0_ret = A_DBL_RET_ARGV(0);

      plhs[1] = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
      dvals1_ret = A_DBL_RET_ARGV(1);

      plhs[2] = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
      dvals2_ret = A_DBL_RET_ARGV(2);

      plhs[3] = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
      dvals3_ret = A_DBL_RET_ARGV(3);

      }

   }




/*
   void llgrid_pl02 ( SpiceInt               handle,
                      ConstSpiceDLADescr   * dladsc,
                      SpiceInt               npoints,
                      ConstSpiceDouble       grid     [][2],
                      SpiceDouble            spoints  [][3],
                      SpiceInt               plateIDs []     )
*/
void cspice_llgrid_pl02(int nlhs, mxArray *plhs[], int nrhs,
                        const mxArray *prhs[])
   {
   SpiceInt             handle;
   SpiceDLADescr        local_dladsc;
   SpiceInt           * dladsc;
   ConstSpiceDouble ( * grid    )[2] = 0;
   SpiceDouble      ( * spoints )[3];
   SpiceInt           * plateIDs;
   SpiceInt             n;
   mwSize               size_spoints [2];
   mwSize               size_plateIDs[2];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle",   MiceInt,     0, {0},                0},
      { "dladsc",   MiceInt,     1, {SPICE_DLA_DSCSIZ}, 0},
      { "grid",     MiceDouble,  2, {2,0},              0},
      { "spoints",  MiceIgnore,  0, {0},                0},
      { "plateIDs", MiceIgnore,  0, {0},                0}
      };

   check_arg_num( nrhs, nlhs, 3, 2 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle  = S_INT_ARGV(1);
   dladsc  = A_INT_ARGV(2);

   local_dladsc.bwdptr = dladsc[SPICE_DLA_BWDIDX];
   local_dladsc.fwdptr = dladsc[SPICE_DLA_FWDIDX];
   local_dladsc.ibase  = dladsc[SPICE_DLA_IBSIDX];
   local_dladsc.isize  = dladsc[SPICE_DLA_ISZIDX];
   local_dladsc.dbase  = dladsc[SPICE_DLA_DBSIDX];
   local_dladsc.dsize  = dladsc[SPICE_DLA_DSZIDX];
   local_dladsc.cbase  = dladsc[SPICE_DLA_CBSIDX];
   local_dladsc.csize  = dladsc[SPICE_DLA_CSZIDX];

   n = mxGetNumberOfElements( prhs[3] ) / 2;

   if ( n > 0 )
      {
      grid = (ConstSpiceDouble (*)[2])mxGetData( prhs[3] );

      size_spoints[0]  = 3;
      size_spoints[1]  = n;

      size_plateIDs[0] = 1;
      size_plateIDs[1] = n;
      }
   else
      {
      size_spoints[0]  = 0;
      size_spoints[1]  = 0;

      size_plateIDs[0] = 0;
      size_plateIDs[1] = 0;
      }

   plhs[0]  = mxCreateNumericArray( 2, size_spoints,  mxDOUBLE_CLASS, mxREAL);
   spoints  = (SpiceDouble (*)[3])A_DBL_RET_ARGV(0);

   plhs[1]  = mxCreateNumericArray( 2, size_plateIDs, mxINT32_CLASS, mxREAL);
   plateIDs = (SpiceInt *)A_INT_RET_ARGV(1);

   /*
   printf ( "n = %d\n", n );

   printf ( "grid[0][0] = %f\n", grid[0][0] );
   printf ( "grid[1][0] = %f\n", grid[1][0] );
   */

   if ( n > 0 )
      {
         llgrid_pl02 ( handle, &local_dladsc, n, grid, spoints, plateIDs  );
      }

   CHECK_CALL_FAILURE(SCALAR);
   }




/*
   void              lmpool_c ( const void        * cvals,
                                SpiceInt            lenvals,
                                SpiceInt            n       );


*/
void cspice_lmpool(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   /*
   MAXCHR and MAXLEN defined in cspice_params.h.
   */
   SpiceChar            str [LINLEN + 1];
   SpiceChar         ** cvals = NULL;
   SpiceInt             cvals_len;
   SpiceInt             cvals_size;

   mxChar             * mx_str;

   SpiceInt             i;
   SpiceInt             j;
   SpiceInt             count;

   struct extra_dims  * extra;

   struct argcheck ArgCheck[] =
      {
      { "cvals", MiceChar, 0, {0}, 1}
      };

   check_arg_num( nrhs, nlhs, 1, 0);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);


   /*
   The following logic differs slightly from other string input arguments.
   A lmpool_c input may consist of an array of strings, where the array
   defines either a single string or an array or strings.

   Recall, extra->count == 0 for scalar inputs. A scalar string requires
   count as 1 (As with pcpool_c, Is this a bug or design failure? EDW)
   */
   if (extra->count>1)
      {
      count = extra->count;
      }
   else
      {
      count = 1;
      }

   mx_str = (mxChar *)mxGetChars(prhs[ONE_IN]);


   /*
   A string lmpool_c input string has at most LINLEN characters
   so the maximum room needed is either extra->offset[0] +1 if that
   value less than LINLEN or LINLEN + 1 (for \n).
   */
   if( extra->offset[ONE_OFF] > LINLEN )
      {
      cvals_len  = LINLEN + 1;
      }
   else
      {
      cvals_len  = extra->offset[ONE_OFF] + 1;
      }


   cvals_size = count;
   cvals      = alloc_SpiceString_C_array( cvals_len, cvals_size );

   CHECK_CALL_FAILURE( SCALAR );

   for ( i=0; i<count; i++)
      {

      /*
      Extract the string data, character by character, into
      CSPICE strings. The mx_str array stores the data in a column
      major format, we need to extract the data by rows.
      */
      for ( j=0; j<cvals_len - 1; j++)
         {
         str[j] = (char)mx_str[i + (count*j)];
         }

      str[cvals_len - 1] = '\0';

      strncpy( *cvals + i*cvals_len,
               str,
               cvals_len);
      }

   lmpool_c(  *cvals, cvals_len, cvals_size);
   CHECK_CALL_FAILURE_MEM( 1, cvals );

   /* Clean up temporary variables */
   free_SpiceString_C_array ( 1, cvals );

   /*
   Confirm the code released all allocated memory.
   */
   MICE_ALLOC_CHECK;

   }




/*
   SpiceDouble       lspcn_c ( ConstSpiceChar   * body,
                               SpiceDouble        et,
                               ConstSpiceChar   * abcorr )
*/
void cspice_lspcn(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            body[DEFAULT_STR_LENGTH+1];
   SpiceDouble        * vec_et;
   SpiceDouble          et;
   SpiceChar            abcorr[DEFAULT_STR_LENGTH+1];
   SpiceDouble        * vec_lspcn;
   SpiceDouble        * lspcn;

   mwIndex              i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "body",   MiceChar,   0, {0}, 0},
      { "et",     MiceDouble, 0, {0}, 1},
      { "abcorr", MiceChar,   0, {0}, 0},
      { "lspcn",  MiceDouble, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], body,   DEFAULT_STR_LENGTH);
   mxGetString(prhs[3], abcorr, DEFAULT_STR_LENGTH);

   vec_et    = A_DBL_ARGV(2);
   vec_lspcn = A_DBL_RET_ARGV(0);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         et    = *(vec_et    + i*extra->offset[1]);
         lspcn =  (vec_lspcn + i*extra->offset[3]);

         *lspcn = lspcn_c (  body, et, abcorr );
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {

      et    = *vec_et;
      lspcn = vec_lspcn;

      *lspcn = lspcn_c (  body, et, abcorr );
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void                ltime_c( SpiceDouble        etobs,
                                SpiceInt           obs,
                                ConstSpiceChar   * dir,
                                SpiceInt           targ,
                                SpiceDouble      * ettarg,
                                SpiceDouble      * elapsd  )
*/
void cspice_ltime(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble      etobs;
   SpiceDouble    * vec_etobs;
   SpiceInt         obs;
   SpiceChar        dir[DEFAULT_STR_LENGTH+1];
   SpiceInt         targ;
   SpiceDouble    * ettarg;
   SpiceDouble    * vec_ettarg;
   SpiceDouble    * elapsd;
   SpiceDouble    * vec_elapsd;

   mwIndex          i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "etobs",  MiceDouble, 0, {0}, 1},
      { "obs",    MiceInt,    0, {0}, 0},
      { "dir",    MiceChar,   0, {0}, 0},
      { "targ",   MiceInt,    0, {0}, 0},
      { "ettarg", MiceDouble, 0, {0}, 1},
      { "elapsd", MiceDouble, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 4, 2);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_etobs  = A_DBL_ARGV(1);
   vec_ettarg = A_DBL_RET_ARGV(0);
   vec_elapsd = A_DBL_RET_ARGV(1);

   obs       = S_INT_ARGV(2);
   mxGetString(prhs[3], dir, DEFAULT_STR_LENGTH);
   targ       = S_INT_ARGV(4);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         etobs  = *(vec_etobs+i*extra->offset[0]);
         ettarg = (vec_ettarg+i*extra->offset[4]);
         elapsd = (vec_elapsd+i*extra->offset[5]);

         ltime_c(etobs, obs, dir, targ, ettarg, elapsd);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {

      etobs  = *(vec_etobs);
      ettarg =  (vec_ettarg);
      elapsd =  (vec_elapsd);

      ltime_c(etobs, obs, dir, targ, ettarg, elapsd);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void              m2eul_c  ( ConstSpiceDouble    r[3][3],
                                SpiceInt            axis3,
                                SpiceInt            axis2,
                                SpiceInt            axis1,
                                SpiceDouble       * angle3,
                                SpiceDouble       * angle2,
                                SpiceDouble       * angle1  );
*/
void cspice_m2eul(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_r;
   SpiceDouble        * vec_angle3;
   SpiceDouble        * vec_angle2;
   SpiceDouble        * vec_angle1;
   SpiceDouble        * r;
   SpiceInt             axis3;
   SpiceInt             axis2;
   SpiceInt             axis1;
   SpiceDouble        * angle3;
   SpiceDouble        * angle2;
   SpiceDouble        * angle1;

   SpiceDouble          xr[3][3];

   mwIndex        i;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "r",      MiceDouble, 2, {3, 3}, 1},
      { "axis3",  MiceInt,    0, {0},    0},
      { "axis2",  MiceInt,    0, {0},    0},
      { "axis1",  MiceInt,    0, {0},    0},
      { "angle3", MiceDouble, 0, {0},    1},
      { "angle2", MiceDouble, 0, {0},    1},
      { "angle1", MiceDouble, 0, {0},    1},
      };

   check_arg_num( nrhs, nlhs, 4, 3 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_r      = A_DBL_ARGV(1);

   vec_angle3 = A_DBL_RET_ARGV(0);
   vec_angle2 = A_DBL_RET_ARGV(1);
   vec_angle1 = A_DBL_RET_ARGV(2);

   axis3  = S_INT_ARGV(2);
   axis2  = S_INT_ARGV(3);
   axis1  = S_INT_ARGV(4);
   angle3 = (vec_angle3);
   angle2 = (vec_angle2);
   angle1 = (vec_angle1);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         r      = (vec_r      + i*extra->offset[0]);
         angle3 = (vec_angle3 + i*extra->offset[4]);
         angle2 = (vec_angle2 + i*extra->offset[5]);
         angle1 = (vec_angle1 + i*extra->offset[6]);

         xpose_c( r, (SpiceDouble(*)[3])xr );

         m2eul_c( xr, axis3, axis2, axis1, angle3, angle2, angle1);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {

      r = vec_r;

      xpose_c( r, (SpiceDouble(*)[3])xr );

      m2eul_c( xr, axis3, axis2, axis1, angle3, angle2, angle1);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void              m2q_c    ( ConstSpiceDouble    r[3][3],
                                SpiceDouble         q[4]     )
*/
void cspice_m2q(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_r;
   SpiceDouble        * vec_q;
   SpiceDouble        * r;
   SpiceDouble        * q;
   SpiceDouble          xr[3][3];

   mwIndex              i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "r",  MiceDouble, 2, {3, 3}, 1},
      { "q",  MiceDouble, 1, {4},    1},
      };

   check_arg_num( nrhs, nlhs, 1, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_r = A_DBL_ARGV(1);
   vec_q = A_DBL_RET_ARGV(0);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         r = (vec_r + i*extra->offset[0]);
         q = (vec_q + i*extra->offset[1]);

         xpose_c( r, (SpiceDouble(*)[3])xr );

         m2q_c( xr, q);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {

      r = (vec_r);
      q = (vec_q);

      xpose_c( r, (SpiceDouble(*)[3])xr );

      m2q_c( xr, q );
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void              namfrm_c ( ConstSpiceChar    * frname,
                                SpiceInt          * frcode );
*/
void cspice_namfrm(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            str[DEFAULT_STR_LENGTH+1];
   mxChar             * mx_str;
   SpiceInt           * frcode;
   SpiceInt           * vec_frcode;

   mwIndex              i;
   SpiceInt             j;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "frname", MiceChar, 0, {0}, 1},
      { "frcode", MiceInt,  0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 1, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_frcode = A_INT_RET_ARGV(0);

   if (extra->count>1)
      {

      mx_str = (mxChar *)mxGetChars(prhs[1]);

      for ( i=0; i<extra->count; i++)
         {

         /*
         Extract the string data, character by character, into
         CSPICE strings. The mx_str array stores the data in a column
         major format, we need to extract the data by rows.
         */
         for ( j=0; j<extra->offset[0]; j++)
            {
            str[j] = (char)mx_str[i + (extra->count*j)];
            }

         str[extra->offset[0]] = '\0';
         frcode                = (vec_frcode+i*extra->offset[1]);

         namfrm_c(str, frcode);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {

      mxGetString(prhs[1], str, DEFAULT_STR_LENGTH);

      frcode = vec_frcode;

      namfrm_c(str, frcode);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void              nearpt_c ( ConstSpiceDouble    positn[3],
                                SpiceDouble         a,
                                SpiceDouble         b,
                                SpiceDouble         c,
                                SpiceDouble         npoint[3],
                                SpiceDouble       * alt        );
*/
void mice_nearpt(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble  * vec_positn;
   SpiceDouble  * positn;
   SpiceDouble    a;
   SpiceDouble    b;
   SpiceDouble    c;
   SpiceDouble    npoint[3];
   SpiceDouble    alt;

   mwIndex        i;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "positn", MiceDouble, 1, {3}, 1},
      { "a",      MiceDouble, 0, {0}, 0},
      { "b",      MiceDouble, 0, {0}, 0},
      { "c",      MiceDouble, 0, {0}, 0},
      { "npoint", MiceNear,    0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 4, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_positn = A_DBL_ARGV(1);

   a = S_DBL_ARGV(2);
   b = S_DBL_ARGV(3);
   c = S_DBL_ARGV(4);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         positn = (vec_positn + i*extra->offset[0]);

         nearpt_c(positn, a, b, c, npoint, &alt);
         CHECK_CALL_FAILURE(i);

         /*
         Copy the position and altitude values into the ith structure
         element.
         */
         memcpy( mxGetPr( mxGetField(plhs[0],i,"pos" ) ),
                 npoint,
                 3*sizeof(SpiceDouble));

         mxDestroyArray( mxGetField( plhs[0], i, "alt" ) );
         mxSetField( plhs[0], i, "alt", mxCreateDoubleScalar(alt) );

         }

      }
   else
      {

      positn = vec_positn;

      nearpt_c(positn, a, b, c, npoint, &alt);
      CHECK_CALL_FAILURE(SCALAR);

      /*
      Copy the position and altitude values into the 0 structure element.
      */
      memcpy( mxGetPr( mxGetField(plhs[0],0,"pos" ) ),
              npoint,
              3*sizeof(SpiceDouble));

      mxDestroyArray( mxGetField( plhs[0], 0, "alt" ) );
      mxSetField( plhs[0], 0, "alt", mxCreateDoubleScalar(alt) );

      }

   }




/*
   void nextwd_c ( ConstSpiceChar    * string,
                   SpiceInt            nexlen,
                   SpiceInt            reslen,
                   SpiceChar         * next,
                   SpiceChar         * rest   )
*/
void cspice_nextwd(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            string [DEFAULT_STR_LENGTH+1];
   SpiceChar            next   [DEFAULT_STR_LENGTH+1];
   SpiceChar            rest   [DEFAULT_STR_LENGTH+1];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "string",  MiceChar,     0, {0},   0},
      { "next",    MiceChar,     0, {0},   0},
      { "rest",    MiceChar,     0, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 1, 2 );

   memset( next, 0, default_str_size );
   memset( rest, 0, default_str_size );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], string, DEFAULT_STR_LENGTH);


   nextwd_c ( string, DEFAULT_STR_LENGTH, DEFAULT_STR_LENGTH, next, rest );
   CHECK_CALL_FAILURE(SCALAR);

   plhs[0] = mxCreateString(next);
   plhs[1] = mxCreateString(rest);

   if ( (plhs[0] == NULL) || (plhs[1] == NULL) )
      {
      mexErrMsgTxt( "MICE(BUG): mxCreateString failed in cspice_nextwd" );
      }

   }




/*
   void              npedln_c ( SpiceDouble         a,
                                SpiceDouble         b,
                                SpiceDouble         c,
                                ConstSpiceDouble    linept[3],
                                ConstSpiceDouble    linedr[3],
                                SpiceDouble         pnear[3],
                                SpiceDouble       * dist      );
*/
void mice_npedln(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble    a;
   SpiceDouble    b;
   SpiceDouble    c;
   SpiceDouble  * linept;
   SpiceDouble  * linedr;
   SpiceDouble    pnear[3];
   SpiceDouble    dist;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "a",      MiceDouble, 0, {0}, 0},
      { "b",      MiceDouble, 0, {0}, 0},
      { "c",      MiceDouble, 0, {0}, 0},
      { "linept", MiceDouble, 1, {3}, 0},
      { "linedr", MiceDouble, 1, {3}, 0},
      { "npoint", MiceNear,   0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 5, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   a = S_DBL_ARGV(1);
   b = S_DBL_ARGV(2);
   c = S_DBL_ARGV(3);

   linept = A_DBL_ARGV(4);
   linedr = A_DBL_ARGV(5);

   npedln_c ( a, b, c, linept, linedr, pnear, &dist );
   CHECK_CALL_FAILURE(SCALAR);

   /*
   Copy the position and altitude values into the 0 structure element.
   */
   memcpy( mxGetPr( mxGetField(plhs[0],0,"pos" ) ),
           pnear,
           3*sizeof(SpiceDouble));

   mxDestroyArray( mxGetField( plhs[0], 0, "alt" ) );
   mxSetField( plhs[0], 0, "alt", mxCreateDoubleScalar(dist) );

   }




/*
   void              npelpt_c ( ConstSpiceDouble    point[3],
                                ConstSpiceEllipse * ellips,
                                SpiceDouble         pnear[3],
                                SpiceDouble       * dist      );
*/
void mice_npelpt(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble  * point;
   SpiceEllipse   ellips;

   SpiceDouble    pnear[3];
   SpiceDouble    dist;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "point",   MiceDouble,  1, {3}, 0},
      { "ellips",  MiceEllipse, 0, {0}, 0},
      { "npoint",  MiceNear,    0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   point = A_DBL_ARGV(1);

   memcpy( ellips.center,
           mxGetPr( mxGetField( prhs[2], 0,"center") ),
           3*sizeof(SpiceDouble)
         );

   memcpy( ellips.semiMajor,
           mxGetPr( mxGetField( prhs[2], 0,"semiMajor") ),
           3*sizeof(SpiceDouble)
         );

   memcpy( ellips.semiMinor,
           mxGetPr( mxGetField( prhs[2], 0,"semiMinor") ),
           3*sizeof(SpiceDouble)
         );

   npelpt_c ( point, &ellips, pnear, &dist);
   CHECK_CALL_FAILURE(SCALAR);

   /*
   Copy the position and altitude values into the 0 structure element.
   */
   memcpy( mxGetPr( mxGetField(plhs[0], 0,"pos" ) ),
           pnear,
           3*sizeof(SpiceDouble));

   mxDestroyArray( mxGetField( plhs[0], 0, "alt" ) );
   mxSetField( plhs[0], 0, "alt", mxCreateDoubleScalar(dist) );

   }




/*
   void              nplnpt_c ( ConstSpiceDouble    linpt  [3],
                                ConstSpiceDouble    lindir [3],
                                ConstSpiceDouble    point  [3],
                                SpiceDouble         pnear  [3],
                                SpiceDouble       * dist       );
*/
void mice_nplnpt(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble  * linpt;
   SpiceDouble  * lindir;
   SpiceDouble  * point;
   SpiceDouble    pnear[3];
   SpiceDouble    dist;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "linpt",  MiceDouble, 1, {3}, 0},
      { "lindir", MiceDouble, 1, {3}, 0},
      { "point",  MiceDouble, 1, {3}, 0},
      { "npoint", MiceNear,   0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   linpt  = A_DBL_ARGV(1);
   lindir = A_DBL_ARGV(2);
   point  = A_DBL_ARGV(3);

   nplnpt_c ( linpt, lindir, point, pnear, &dist );
   CHECK_CALL_FAILURE(SCALAR);

   /*
   Copy the position and altitude values into the 0 structure element.
   */
   memcpy( mxGetPr( mxGetField(plhs[0], 0, "pos" ) ),
           pnear,
           3*sizeof(SpiceDouble));

   mxDestroyArray( mxGetField( plhs[0], 0, "alt" ) );
   mxSetField( plhs[0], 0, "alt", mxCreateDoubleScalar(dist) );

   }




/*
   void nthwd_c  ( ConstSpiceChar    * string,
                   SpiceInt            nth,
                   SpiceInt            worlen,
                   SpiceChar         * word,
                   SpiceInt          * loc    )
*/
void cspice_nthwd(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            string [DEFAULT_STR_LENGTH+1];
   SpiceInt             nth;
   SpiceChar            word   [DEFAULT_STR_LENGTH+1];
   SpiceInt           * loc;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "string",  MiceChar,     0, {0},   0},
      { "nth",     MiceInt,      0, {0},   0},
      { "word",    MiceChar,     0, {0},   0},
      { "loc",     MiceInt,      0, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 2, 2 );

   memset( word, 0, default_str_size );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], string, DEFAULT_STR_LENGTH);

   nth = S_INT_ARGV(2);

   loc = A_INT_RET_ARGV(1);

   /*
   Convert `nth' to a C-style index.
   */
   nth--;


   nthwd_c ( string, nth, DEFAULT_STR_LENGTH, word, loc );
   CHECK_CALL_FAILURE(SCALAR);

   /*
   Convert `loc' to a Matlab-style index.
   */
   (*loc)++;

   plhs[0] = mxCreateString(word);

   if (plhs[0] == NULL)
      {
      mexErrMsgTxt( "MICE(BUG): mxCreateString failed in cspice_nthwd" );
      }

   }




/*
   void              nvc2pl_c ( ConstSpiceDouble    normal[3],
                                SpiceDouble         konst,
                                SpicePlane        * plane     )

*/
void cspice_nvc2pl(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * normal;
   SpiceDouble          konst;
   SpicePlane           plane;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "normal", MiceDouble, 1, {3}, 0},
      { "konst",  MiceDouble, 0, {0}, 0},
      { "plane",  MicePlane,  0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   normal = A_DBL_ARGV(1);
   konst  = S_DBL_ARGV(2);

   nvc2pl_c ( normal, konst,  &plane );
   CHECK_CALL_FAILURE( SCALAR );

   memcpy( mxGetPr( mxGetField( plhs[0], 0,"normal") ),
           plane.normal,
           3*sizeof(SpiceDouble)
         );

   memcpy( mxGetPr( mxGetField( plhs[0], 0,"constant") ),
           &(plane.constant),
           sizeof(SpiceDouble)
         );

   }




/*
   void              nvp2pl_c ( ConstSpiceDouble    normal[3],
                                ConstSpiceDouble    point[3],
                                SpicePlane        * plane     );

*/
void cspice_nvp2pl(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * normal;
   SpiceDouble        * point;
   SpicePlane           plane;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "normal", MiceDouble, 1, {3}, 0},
      { "point",  MiceDouble, 1, {3}, 0},
      { "plane",  MicePlane,  0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   normal = A_DBL_ARGV(1);
   point  = A_DBL_ARGV(2);

   nvp2pl_c ( normal, point,  &plane );
   CHECK_CALL_FAILURE( SCALAR );

   memcpy( mxGetPr( mxGetField( plhs[0], 0,"normal") ),
           plane.normal,
           3*sizeof(SpiceDouble)
         );

   memcpy( mxGetPr( mxGetField( plhs[0], 0,"constant") ),
           &(plane.constant),
           sizeof(SpiceDouble)
         );

   }




/*
   void occult_c ( ConstSpiceChar   * targ1,
                   ConstSpiceChar   * shape1,
                   ConstSpiceChar   * frame1,
                   ConstSpiceChar   * targ2,
                   ConstSpiceChar   * shape2,
                   ConstSpiceChar   * frame2,
                   ConstSpiceChar   * abcorr,
                   ConstSpiceChar   * obsrvr,
                   SpiceDouble        et,
                   SpiceInt         * ocltid )
*/
void cspice_occult(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            targ1  [DEFAULT_STR_LENGTH+1];
   SpiceChar            shape1 [DEFAULT_STR_LENGTH+1];
   SpiceChar            frame1 [DEFAULT_STR_LENGTH+1];
   SpiceChar            targ2  [DEFAULT_STR_LENGTH+1];
   SpiceChar            shape2 [DEFAULT_STR_LENGTH+1];
   SpiceChar            frame2 [DEFAULT_STR_LENGTH+1];
   SpiceChar            abcorr [DEFAULT_STR_LENGTH+1];
   SpiceChar            obsrvr [DEFAULT_STR_LENGTH+1];

   SpiceDouble        * et;
   SpiceDouble        * vec_et;

   mwIndex              i;
   SpiceInt           * ocltid;
   SpiceInt           * vec_ocltid;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "targ1",  MiceChar,   0, {0}, 0},
      { "shape1", MiceChar,   0, {0}, 0},
      { "frame1", MiceChar,   0, {0}, 0},
      { "targ2",  MiceChar,   0, {0}, 0},
      { "shape2", MiceChar,   0, {0}, 0},
      { "frame2", MiceChar,   0, {0}, 0},
      { "abcorr", MiceChar,   0, {0}, 0},
      { "obsrvr", MiceChar,   0, {0}, 0},
      { "et",     MiceDouble, 0, {0}, 1},
      { "ocltid", MiceInt,    0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 9, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], targ1,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], shape1, DEFAULT_STR_LENGTH);
   mxGetString(prhs[3], frame1, DEFAULT_STR_LENGTH);
   mxGetString(prhs[4], targ2,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[5], shape2, DEFAULT_STR_LENGTH);
   mxGetString(prhs[6], frame2, DEFAULT_STR_LENGTH);
   mxGetString(prhs[7], abcorr, DEFAULT_STR_LENGTH);
   mxGetString(prhs[8], obsrvr, DEFAULT_STR_LENGTH);

   vec_et     = A_DBL_ARGV(9);
   vec_ocltid = A_INT_RET_ARGV(0);

   et     = (vec_et);
   ocltid = (vec_ocltid);

   /*
   Check for vectorized arguments.
   */
   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         et     = (vec_et     + i*extra->offset[8]);
         ocltid = (vec_ocltid + i*extra->offset[9]);

         occult_c ( targ1,  shape1,  frame1,
                    targ2,  shape2,  frame2,
                    abcorr, obsrvr, *et,     ocltid );

         CHECK_CALL_FAILURE(i);

         }

      }
   else
      {

      occult_c ( targ1,  shape1,  frame1,
                 targ2,  shape2,  frame2,
                 abcorr, obsrvr, *et,     ocltid );

      CHECK_CALL_FAILURE(SCALAR);

      }

   }




/*
   void              oscelt_c ( ConstSpiceDouble    state[6],
                                SpiceDouble         et,
                                SpiceDouble         mu,
                                SpiceDouble         elts[8]  );
*/
void cspice_oscelt(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_state;
   SpiceDouble        * vec_et;
   SpiceDouble        * vec_elts;
   SpiceDouble        * state;
   SpiceDouble          et;
   SpiceDouble          mu;
   SpiceDouble        * elts;

   mwIndex              i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "state", MiceDouble, 1, {6}, 1},
      { "et",    MiceDouble, 0, {0}, 1},
      { "mu",    MiceDouble, 0, {0}, 0},
      { "elts",  MiceDouble, 1, {8}, 1},
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_state = A_DBL_ARGV(1);
   vec_et    = A_DBL_ARGV(2);
   mu        = S_DBL_ARGV(3);
   vec_elts  = A_DBL_RET_ARGV(0);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         state =  (vec_state + i*extra->offset[0]);
         et    = *(vec_et    + i*extra->offset[1]);
         elts  =  (vec_elts  + i*extra->offset[3]);

         oscelt_c(state, et, mu, elts);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {

      state =  (vec_state);
      et    = *(vec_et);
      elts  =  (vec_elts);

      oscelt_c(state, et, mu, elts);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void oscltx_c ( ConstSpiceDouble state [6],
                   SpiceDouble      et,
                   SpiceDouble      mu,
                   SpiceDouble      elts  [SPICE_OSCLTX_NELTS] )
*/
void cspice_oscltx(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * state;
   SpiceDouble          et;
   SpiceDouble          mu;
   SpiceDouble        * elts;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "state",   MiceDouble,   1, {6},                  0},
      { "et",      MiceDouble,   0, {0},                  0},
      { "mu",      MiceDouble,   0, {0},                  0},
      { "elts",    MiceDouble,   1, {SPICE_OSCLTX_NELTS}, 0},
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   state    = A_DBL_ARGV(1);
   et       = S_DBL_ARGV(2);
   mu       = S_DBL_ARGV(3);

   elts     = A_DBL_RET_ARGV(0);

   oscltx_c ( state, et, mu, elts );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              pckcov_c ( ConstSpiceChar    * pck,
                                SpiceInt            idcode,
                                SpiceCell         * cover   );

*/
void cspice_pckcov(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {
   SpiceChar           pck[DEFAULT_STR_LENGTH+1];
   mxChar            * mx_pck;

   mwIndex             i;
   SpiceInt            j;
   mwSize              sizearray[2];

   SpiceInt            card = 0;
   SpiceInt            size;
   SpiceInt            idcode;
   SpiceDouble       * cover_f;
   SpiceDouble       * cover;

   struct extra_dims * extra;
   struct argcheck ArgCheck[] =
      {
      { "pckfnm", MiceChar,   0, {0}, 1},
      { "idcode", MiceInt,    0, {0}, 0},
      { "room",   MiceInt,    0, {0}, 0},
      { "cover",  MiceIgnore, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   idcode = S_INT_ARGV(2);

   /*
   'size' defines the number of intervals for the workspace window,
   so double the value of size since an interval consists of
   two double precision values.
   */
   size   = S_INT_ARGV(3) * 2;

   cover  = (SpiceDouble*)
            mxMalloc( (size + SPICE_CELL_CTRLSZ)*sizeof(SpiceDouble)  );

   ssized_( ( integer * ) &size, ( double * ) cover );
   scardd_( ( integer * ) &card, ( double * ) cover );

   if (extra->count>1)
      {

      mx_pck = (mxChar *)mxGetChars(prhs[1]);

      for ( i=0; i<extra->count; i++)
         {

         /*
         Extract the string data, character by character, into
         CSPICE strings. The mx_str array stores the data in a column
         major format, we need to extract the data by rows.
         */
         for ( j=0; j<extra->offset[0]; j++)
            {
            pck[j] = (char)mx_pck[i + (extra->count*j)];
            }

         pck[extra->offset[0]] = '\0';

         pckcov_( ( char       * ) pck,
                  ( integer    * ) &idcode,
                  ( doublereal * ) (cover),
                  ( ftnlen       ) strlen(pck)   );

         /*
         Check for a failure signal. Free the memory assigned to 'cover'
         before signaling a Matlab error.
         */
         if ( failed_c())
            {
            mxFree( cover );

            /*
            The mice_fail call creates the error string then returns control
            to the MATLAB interpreter.
            */
            mice_fail(i);
            }

         }

      }
   else
      {
      mxGetString(prhs[1], pck, DEFAULT_STR_LENGTH);

      pckcov_(  ( char       * ) pck,
                ( integer    * ) &idcode,
                ( doublereal * ) (cover),
                ( ftnlen       ) strlen(pck)   );

      /*
      Check for a failure signal. Free the memory assigned to 'cover'
      before signaling a Matlab error.
      */
      if ( failed_c())
         {
         mxFree( cover );

         /*
         The mice_fail call creates the error string then returns control
         to the MATLAB interpreter.
         */
         mice_fail(SCALAR);
         }

      }

   /*
   Array element 6, index 5, contains the cell cardinality. Create an output
   array CARDx1.
   */
   sizearray[0] = cover[5];
   sizearray[1] = 1;

   plhs[0] = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
   cover_f = A_DBL_RET_ARGV(0);

   /*
   Copy the data contents of 'cover' to 'cover_f'. The set of window data
   starts at 'cover' array index SPICE_CELL_CTRLSZ and contains 'cover[5]'
   elements.
   */
   MOVED( cover + SPICE_CELL_CTRLSZ, cover[5], cover_f );
   mxFree( cover );

   }




/*
   void              pckfrm_c ( ConstSpiceChar    * pck,
                                SpiceCell         * ids );

*/
void cspice_pckfrm(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {
   SpiceChar           pck[DEFAULT_STR_LENGTH+1];
   mxChar            * mx_pck;

   mwIndex             i;
   SpiceInt            j;
   mwSize              sizearray[2];

   SpiceInt            card = 0;
   SpiceInt            size;
   SpiceInt          * ids_f;
   SpiceInt          * ids;

   struct extra_dims * extra;
   struct argcheck ArgCheck[] =
      {
      { "pckfnm", MiceChar,   0, {0}, 1},
      { "room",   MiceInt,    0, {0}, 0},
      { "ids",    MiceIgnore, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   size = S_INT_ARGV(2);
   ids  = (SpiceInt*)mxMalloc( (size + SPICE_CELL_CTRLSZ)*sizeof(SpiceInt)  );

   ssizei_( ( integer * ) &size, ( integer * ) ids   );
   scardi_( ( integer * ) &card, ( integer * ) ids   );

   if (extra->count>1)
      {

      mx_pck = (mxChar *)mxGetChars(prhs[1]);

      for ( i=0; i<extra->count; i++)
         {

         /*
         Extract the string data, character by character, into
         CSPICE strings. The mx_str array stores the data in a column
         major format, we need to extract the data by rows.
         */
         for ( j=0; j<extra->offset[0]; j++)
            {
            pck[j] = (char)mx_pck[i + (extra->count*j)];
            }

         pck[extra->offset[0]] = '\0';

         pckfrm_(  ( char       * ) pck,
                   ( integer    * ) (ids),
                   ( ftnlen       ) strlen(pck)   );

         /*
         Check for a failure signal. Free the memory assigned to 'ids'
         before signaling a Matlab error.
         */
         if ( failed_c())
            {
            mxFree( ids );

            /*
            The mice_fail call creates the error string then returns control
            to the MATLAB interpreter.
            */
            mice_fail(i);
            }

         }

      }
   else
      {
      mxGetString(prhs[1], pck, DEFAULT_STR_LENGTH);

      pckfrm_(  ( char       * ) pck,
                ( integer    * ) (ids),
                ( ftnlen       ) strlen(pck)   );

      /*
      Check for a failure signal. Free the memory assigned to 'ids'
      before signaling a Matlab error.
      */
      if ( failed_c())
         {
         mxFree( ids );

         /*
         The mice_fail call creates the error string then returns control
         to the MATLAB interpreter.
         */
         mice_fail(SCALAR);
         }

      }

   /*
   Array element 6, index 5, contains the cell cardinality. Create an output
   array CARDx1.
   */
   sizearray[0] = ids[5];
   sizearray[1] = 1;

   plhs[0] = mxCreateNumericArray( 2, sizearray, mxINT32_CLASS, mxREAL);
   ids_f   = A_INT_RET_ARGV(0);

   MOVEI( ids + SPICE_CELL_CTRLSZ, ids[5], ids_f );
   mxFree( ids );

   }




/*
   void              pcpool_c ( ConstSpiceChar   * name,
                                SpiceInt           n,
                                SpiceInt           lenvals,
                                const void        * cvals    );

*/
void cspice_pcpool(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   /*
   MAXCHR and MAXLEN defined in cspice_params.h.
   */
   SpiceChar            name[MAXLEN + 1];
   SpiceChar            str [MAXCHR + 1];
   SpiceChar         ** cvals = NULL;
   SpiceInt             cvals_len;
   SpiceInt             cvals_size;

   mxChar             * mx_str;

   SpiceInt             i;
   SpiceInt             j;
   SpiceInt             count;

   struct extra_dims  * extra;

   struct argcheck ArgCheck[] =
      {
      { "name",  MiceChar, 0, {0}, 0},
      { "cvals", MiceChar, 0, {0}, 1}
      };

   check_arg_num( nrhs, nlhs, 2, 0);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], name, MAXLEN);

   /*
   The following logic differs slightly from other string input arguments.
   A pcpool_c input may consist of an array of strings, where the array
   defines either a single string or an array or strings.

   Recall, extra->count == 0 for scalar inputs. A scalar string requires
   count as 1 (Is this a bug or design failure? EDW)
   */
   if (extra->count>1)
      {
      count = extra->count;
      }
   else
      {
      count = 1;
      }

   mx_str = (mxChar *)mxGetChars(prhs[2]);

   /*
   A string pcpool_c input string has at most MAXCHR characters
   so the maximum room needed is either extra->offset[i] if that
   value less than MAXCHAR or MAXCHAR + 1 (for \n).
   */
   if( extra->offset[1] > MAXCHR )
      {
      cvals_len  = MAXCHR + 1;
      }
   else
      {
      cvals_len  = extra->offset[1] + 1;
      }

   cvals_size = count;
   cvals      = alloc_SpiceString_C_array( cvals_len, cvals_size );

   CHECK_CALL_FAILURE( SCALAR );

   for ( i=0; i<count; i++)
      {

      /*
      Extract the string data, character by character, into
      CSPICE strings. The mx_str array stores the data in a column
      major format, we need to extract the data by rows.
      */
      for ( j=0; j<cvals_len - 1; j++)
         {
         str[j] = (char)mx_str[i + (count*j)];
         }

      str[cvals_len - 1] = '\0';

      strncpy( *cvals + i*cvals_len,
               str,
               cvals_len);
      }

   pcpool_c(name,cvals_size,cvals_len,*cvals);
   CHECK_CALL_FAILURE_MEM( 1, cvals );

   /* Clean up temporary variables */
   free_SpiceString_C_array ( 1, cvals );

   /*
   Confirm the code released all allocated memory.
   */
   MICE_ALLOC_CHECK;

   }




/*
   void              pdpool_c ( ConstSpiceChar    * name,
                                SpiceInt            n,
                                ConstSpiceDouble  * values );
*/
void cspice_pdpool(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            name [MAXLEN + 1];
   SpiceDouble        * values;

   SpiceInt             values_size;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "name",  MiceChar,   0, {0}, 0},
      { "values", MiceDouble, 1, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 2, 0);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], name, MAXLEN);

   values      = (SpiceDouble*)mxGetData(prhs[2]);
   values_size = mxGetNumberOfElements( prhs[2] );

   pdpool_c( name, values_size, values );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              pgrrec_c ( ConstSpiceChar    * body,
                                SpiceDouble         lon,
                                SpiceDouble         lat,
                                SpiceDouble         alt,
                                SpiceDouble         re,
                                SpiceDouble         f,
                                SpiceDouble         rectan[3] );
*/
void cspice_pgrrec(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            body       [DEFAULT_STR_LENGTH+1];
   SpiceDouble        * vec_lon;
   SpiceDouble        * vec_lat;
   SpiceDouble        * vec_alt;
   SpiceDouble        * vec_rectan;
   SpiceDouble          lon;
   SpiceDouble          lat;
   SpiceDouble          alt;
   SpiceDouble          re;
   SpiceDouble          f;
   SpiceDouble        * rectan;

   mwIndex              i;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "body",   MiceChar,   0, {0}, 0},
      { "lon",    MiceDouble, 0, {0}, 1},
      { "lat",    MiceDouble, 0, {0}, 1},
      { "alt",    MiceDouble, 0, {0}, 1},
      { "re",     MiceDouble, 0, {0}, 0},
      { "f",      MiceDouble, 0, {0}, 0},
      { "rectan", MiceDouble, 1, {3}, 1},
      };

   check_arg_num( nrhs, nlhs, 6, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString( prhs[1], body, DEFAULT_STR_LENGTH );
   vec_lon    = A_DBL_ARGV(2);
   vec_lat    = A_DBL_ARGV(3);
   vec_alt    = A_DBL_ARGV(4);
   re         = S_DBL_ARGV(5);
   f          = S_DBL_ARGV(6);
   vec_rectan = A_DBL_RET_ARGV(0);

   lon        = *(vec_lon);
   lat        = *(vec_lat);
   alt        = *(vec_alt);
   rectan     =  (vec_rectan);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         lon    = *(vec_lon    + i*extra->offset[1]);
         lat    = *(vec_lat    + i*extra->offset[2]);
         alt    = *(vec_alt    + i*extra->offset[3]);
         rectan =  (vec_rectan + i*extra->offset[6]);

         pgrrec_c(body, lon, lat, alt, re, f, rectan);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {

      pgrrec_c(body, lon, lat, alt, re, f, rectan);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   SpiceDouble       phaseq_c ( SpiceDouble       et,
                                ConstSpiceChar  * target,
                                ConstSpiceChar  * illumn,
                                ConstSpiceChar  * obsrvr,
                                ConstSpiceChar  * abcorr );

*/
void cspice_phaseq(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble          et;
   SpiceDouble        * vec_et;
   SpiceChar            target[DEFAULT_STR_LENGTH+1];
   SpiceChar            illumn[DEFAULT_STR_LENGTH+1];
   SpiceChar            obsrvr[DEFAULT_STR_LENGTH+1];
   SpiceChar            abcorr[DEFAULT_STR_LENGTH+1];
   SpiceDouble        * retval;
   SpiceDouble        * vec_retval;
   mwIndex              i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "et",     MiceDouble, 0, {0}, 1},
      { "target", MiceChar,   0, {0}, 0},
      { "illumn", MiceChar,   0, {0}, 0},
      { "obsrvr", MiceChar,   0, {0}, 0},
      { "abcorr", MiceChar,   0, {0}, 0},
      { "phaseq", MiceDouble, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 5, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_et = A_DBL_ARGV(1);

   mxGetString(prhs[2], target, DEFAULT_STR_LENGTH);
   mxGetString(prhs[3], illumn, DEFAULT_STR_LENGTH);
   mxGetString(prhs[4], obsrvr, DEFAULT_STR_LENGTH);
   mxGetString(prhs[5], abcorr, DEFAULT_STR_LENGTH);

   vec_retval = A_DBL_RET_ARGV(0);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         et     = *(vec_et     + i*extra->offset[0]);
         retval =  (vec_retval + i*extra->offset[5]);

         *retval = phaseq_c ( et, target, illumn, obsrvr, abcorr );
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {

      et     = *vec_et;
      retval = vec_retval;

      *retval =  phaseq_c ( et, target, illumn, obsrvr, abcorr );
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void              pipool_c ( ConstSpiceChar    * name,
                                SpiceInt            n,
                                ConstSpiceInt     * ivals );
*/
void cspice_pipool(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            name [MAXLEN + 1];
   SpiceInt           * ivals;

   SpiceInt             ivals_size;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "name",  MiceChar, 0, {0}, 0},
      { "ivals", MiceInt,  1, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 2, 0);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], name, MAXLEN);

   ivals      = (SpiceInt*)mxGetData(prhs[2]);
   ivals_size = mxGetNumberOfElements( prhs[2] );

   pipool_c( name, ivals_size, ivals );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   SpiceDouble       pi_c( void )
*/
void cspice_pi(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   check_arg_num( nrhs, nlhs, 0, 1 );

   /*
   Directly return the scalar value. This simple case needs no
   error checks.
   */
   plhs[0] = mxCreateDoubleScalar( pi_c() );

   }




/*
   void              pjelpl_c ( ConstSpiceEllipse * elin,
                                ConstSpicePlane   * plane,
                                SpiceEllipse      * elout  );
*/
void mice_pjelpl(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceEllipse   elin;
   SpicePlane     plane;
   SpiceEllipse   elout;


   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "elin",  MiceEllipse, 0, {0}, 0},
      { "plane", MicePlane,   0, {0}, 0},
      { "elout", MiceEllipse, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);


   /*
   Assemble an ellipse structure from the input arguments.
   */
   memcpy( elin.center,
           mxGetPr( mxGetField( prhs[1], 0,"center") ),
           3*sizeof(SpiceDouble)
         );

   memcpy( elin.semiMajor,
           mxGetPr( mxGetField( prhs[1], 0,"semiMajor") ),
           3*sizeof(SpiceDouble)
         );

   memcpy( elin.semiMinor,
           mxGetPr( mxGetField( prhs[1], 0,"semiMinor") ),
           3*sizeof(SpiceDouble)
         );


   /*
   Assemble a plane structure from the input arguments.
   */
   memcpy( plane.normal,
           mxGetPr( mxGetField( prhs[2], 0,"normal") ),
           3*sizeof(SpiceDouble)
         );

   plane.constant = *mxGetPr( mxGetField( prhs[2], 0,"constant") );


   pjelpl_c ( &elin, &plane, &elout  );
   CHECK_CALL_FAILURE(SCALAR);


   memcpy( mxGetPr( mxGetField( plhs[0], 0,"center") ),
           elout.center,
           3*sizeof(SpiceDouble)
         );

   memcpy( mxGetPr( mxGetField( plhs[0], 0,"semiMajor") ),
           elout.semiMajor,
           3*sizeof(SpiceDouble)
         );

   memcpy( mxGetPr( mxGetField( plhs[0], 0,"semiMinor") ),
           elout.semiMinor,
           3*sizeof(SpiceDouble)
         );

   }




/*
   void              pl2nvc_c ( ConstSpicePlane   * plane,
                                SpiceDouble         normal[3],
                                SpiceDouble       * konst     );
*/
void cspice_pl2nvc(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpicePlane           plane;
   SpiceDouble        * normal;
   SpiceDouble        * konst;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "plane",  MicePlane,  0, {0}, 0},
      { "normal", MiceDouble, 1, {3}, 0},
      { "konst",  MiceDouble, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 1, 2 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   /*
   Assemble a plane structure from the input arguments.
   */
   memcpy( plane.normal,
           mxGetPr( mxGetField( prhs[1], 0, "normal") ),
           3*sizeof(SpiceDouble)
         );

   plane.constant = *mxGetPr( mxGetField( prhs[1], 0, "constant") );

   normal = A_DBL_RET_ARGV(0);
   konst  = A_DBL_RET_ARGV(1);

   pl2nvc_c ( &plane, normal, konst );
   CHECK_CALL_FAILURE( SCALAR );

   }




/*
   void              pl2nvp_c ( ConstSpicePlane   * plane,
                                SpiceDouble         normal[3],
                                SpiceDouble         point[3]  );
*/
void cspice_pl2nvp(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpicePlane           plane;
   SpiceDouble        * normal;
   SpiceDouble        * point;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "plane",     MicePlane,  0, {0}, 0},
      { "normal",    MiceDouble, 1, {3}, 0},
      { "point",     MiceDouble, 1, {3}, 0},
      };

   check_arg_num( nrhs, nlhs, 1, 2 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   /*
   Assemble a plane structure from the input arguments.
   */
   memcpy( plane.normal,
           mxGetPr( mxGetField( prhs[1], 0,"normal") ),
           3*sizeof(SpiceDouble)
         );

   plane.constant = *mxGetPr( mxGetField( prhs[1], 0,"constant") );

   normal = A_DBL_RET_ARGV(0);
   point  = A_DBL_RET_ARGV(1);

   pl2nvp_c ( &plane, normal, point );
   CHECK_CALL_FAILURE( SCALAR );

   }




/*
   void              pl2psv_c ( ConstSpicePlane   * plane,
                                SpiceDouble         point[3],
                                SpiceDouble         span1[3],
                                SpiceDouble         span2[3]  );
*/
void cspice_pl2psv(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpicePlane           plane;
   SpiceDouble        * point;
   SpiceDouble        * span1;
   SpiceDouble        * span2;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "plane", MicePlane,  0, {0}, 0},
      { "point", MiceDouble, 1, {3}, 0},
      { "span1", MiceDouble, 1, {3}, 0},
      { "span2", MiceDouble, 1, {3}, 0},
      };

   check_arg_num( nrhs, nlhs, 1, 3 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   /*
   Assemble a plane structure from the input arguments.
   */
   memcpy( plane.normal,
           mxGetPr( mxGetField( prhs[1], 0,"normal") ),
           3*sizeof(SpiceDouble)
         );

   plane.constant = *mxGetPr( mxGetField( prhs[1], 0,"constant") );

   point = A_DBL_RET_ARGV(0);
   span1 = A_DBL_RET_ARGV(1);
   span2 = A_DBL_RET_ARGV(2);

   pl2psv_c ( &plane, point, span1, span2 );
   CHECK_CALL_FAILURE( SCALAR );

   }




/*
   SpiceDouble       pltar_c  ( SpiceInt           nv,
                                ConstSpiceDouble   vrtces [][3],
                                SpiceInt           np,
                                ConstSpiceInt      plates [][3]  );
*/
void cspice_pltar(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             nv = 0;
   SpiceDouble        * vrtces;
   SpiceInt             np = 0;
   SpiceInt           * plates;
   SpiceDouble        * pltar;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "vrtces", MiceDouble, 2, {3,0}, 0},
      { "plates", MiceInt,    2, {3,0}, 0},
      { "pltar",  MiceDouble, 0, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vrtces  = (SpiceDouble   *)mxGetData(prhs[1]);
   plates  = (SpiceInt      *)mxGetData(prhs[2]);

   nv    = mxGetNumberOfElements( prhs[1] )/3;
   np    = mxGetNumberOfElements( prhs[2] )/3;

   pltar = A_DBL_RET_ARGV(0);

   *pltar = pltar_c( nv,
                     (Nx3d)vrtces,
                     np,
                     (Nx3i)plates );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              pltexp_c ( ConstSpiceDouble   iverts[3][3],
                                SpiceDouble        delta,
                                SpiceDouble        overts[3][3] )
*/
void cspice_pltexp(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * iverts;
   SpiceDouble          delta;
   SpiceDouble        * overts;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "iverts", MiceDouble, 2, {3, 3}, 0},
      { "delta",  MiceDouble, 0, {0},    0},
      { "overts", MiceDouble, 2, {3, 3}, 0},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   iverts  = A_DBL_ARGV(1);
   delta   = S_DBL_ARGV(2);
   overts  = A_DBL_RET_ARGV(0);

   pltexp_c (iverts, delta, (SpiceDouble(*)[3])overts);
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              pltnp_c ( ConstSpiceDouble    point[3],
                               ConstSpiceDouble    v1   [3],
                               ConstSpiceDouble    v2   [3],
                               ConstSpiceDouble    v3   [3],
                               SpiceDouble         pnear[3],
                               SpiceDouble       * dist      )
*/
void cspice_pltnp(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * point;
   SpiceDouble        * v1;
   SpiceDouble        * v2;
   SpiceDouble        * v3;
   SpiceDouble        * pnear;
   SpiceDouble        * dist;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "point",  MiceDouble, 1, {3}, 0},
      { "v1",     MiceDouble, 1, {3}, 0},
      { "v2",     MiceDouble, 1, {3}, 0},
      { "v3",     MiceDouble, 1, {3}, 0},
      { "pnear",  MiceDouble, 1, {3}, 0},
      { "dist",   MiceDouble, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 4, 2 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   point = A_DBL_ARGV(1);
   v1    = A_DBL_ARGV(2);
   v2    = A_DBL_ARGV(3);
   v3    = A_DBL_ARGV(4);
   pnear = A_DBL_RET_ARGV(0);
   dist  = A_DBL_RET_ARGV(1);

   pltnp_c ( point, v1, v2, v3, pnear, dist );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              pltnrm_c ( ConstSpiceDouble    v1[3],
                                ConstSpiceDouble    v2[3],
                                ConstSpiceDouble    v3[3],
                                SpiceDouble         normal[3] )
*/
void cspice_pltnrm(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * v1;
   SpiceDouble        * v2;
   SpiceDouble        * v3;
   SpiceDouble        * normal;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "v1",     MiceDouble, 1, {3}, 0},
      { "v2",     MiceDouble, 1, {3}, 0},
      { "v3",     MiceDouble, 1, {3}, 0},
      { "normal", MiceDouble, 1, {3}, 0},
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);
   v1     = A_DBL_ARGV(1);
   v2     = A_DBL_ARGV(2);
   v3     = A_DBL_ARGV(3);
   normal = A_DBL_RET_ARGV(0);

   pltnrm_c ( v1, v2, v3, normal );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   SpiceDouble       pltvol_c  ( SpiceInt           nv,
                                 ConstSpiceDouble   vrtces [][3],
                                 SpiceInt           np,
                                 ConstSpiceInt      plates [][3]  );
*/
void cspice_pltvol(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             nv = 0;
   SpiceDouble        * vrtces;
   SpiceInt             np = 0;
   SpiceInt           * plates;
   SpiceDouble        * pltvol;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "vrtces", MiceDouble, 2, {3,0}, 0},
      { "plates", MiceInt,    2, {3,0}, 0},
      { "pltvol", MiceDouble, 0, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vrtces  = (SpiceDouble   *)mxGetData(prhs[1]);
   plates  = (SpiceInt      *)mxGetData(prhs[2]);

   nv    = mxGetNumberOfElements( prhs[1] )/3;
   np    = mxGetNumberOfElements( prhs[2] )/3;

   pltvol = A_DBL_RET_ARGV(0);

   *pltvol = pltvol_c( nv,
                       (Nx3d)vrtces,
                       np,
                       (Nx3i)plates );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void polyds_c ( ConstSpiceDouble    * coeffs,
                   SpiceInt              deg,
                   SpiceInt              nderiv,
                   SpiceDouble           t,
                   SpiceDouble         * p )
*/
void cspice_polyds(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   ConstSpiceDouble   * coeffs;
   SpiceInt             deg;
   SpiceInt             nderiv;
   SpiceDouble          t;

   SpiceInt             p_size;
   SpiceDouble        * ret_p;
   SpiceDouble        * p;

   SpiceInt             coelen;

   /* The message buffer to write an error message */
   char                 msg[1024];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "coeffs",  MiceDouble,   1, {0},   0},
      { "deg",     MiceInt,      0, {0},   0},
      { "nderiv",  MiceInt,      0, {0},   0},
      { "t",       MiceDouble,   0, {0},   0},
      { "p",       MiceIgnore,   1, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 4, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   coeffs   = A_DBL_ARGV(1);
   deg      = S_INT_ARGV(2);
   nderiv   = S_INT_ARGV(3);
   t        = S_DBL_ARGV(4);

   /*
   Check that `coeffs' has enough data.
   */
   coelen  = A_LEN_ARGV(1);

   if ( coelen < deg+1 )
   {
      sprintf( msg, "MICE(INSUFFICIENTDATA): `coeffs` does not have enough "
               "data: %ld elements required; only %ld provided.",
               (long)deg+1, (long)coelen );
      mexErrMsgTxt( msg );
   }

   /*
   Allocate the necessary memory for `ret_dpdxs'.
   mxMalloc returns to top level in case of error.
   */
   p_size = nderiv + 1;
   ret_p  = (SpiceDouble*) mxMalloc( p_size * sizeof(SpiceDouble) );

   polyds_c ( coeffs, deg, nderiv, t, ret_p );

   /*
   Check for a failure signal. Free the memory assigned to `ret_p'
   before signaling a Matlab error.
   */
   if ( failed_c())
      {
      mxFree( ret_p );

      /*
      The mice_fail call creates the error string then returns control
      to the MATLAB interpreter.
      */
      mice_fail(SCALAR);
      }

   /*
   Allocate the needed memory to return a vector of size `dpdxs_size'
   to MATLAB.
   */
   plhs[0] = mxCreateDoubleMatrix( p_size, 1, mxREAL );
   p       = A_DBL_RET_ARGV(0);
   MOVED( ret_p, p_size, p );
   mxFree( ret_p );

   }




/*
   void prop2b_c ( SpiceDouble         gm,
                   ConstSpiceDouble    pvinit[6],
                   SpiceDouble         dt,
                   SpiceDouble         pvprop[6] )
*/
void cspice_prop2b(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble          gm;
   SpiceDouble        * pvinit;
   SpiceDouble          dt;
   SpiceDouble        * pvprop;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "gm",     MiceDouble,  0, {0}, 0},
      { "pvinit", MiceDouble,  1, {6}, 0},
      { "dt",     MiceDouble,  0, {0}, 0},
      { "pvprop", MiceDouble,  1, {6}, 0},
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   gm       = S_DBL_ARGV(1);
   pvinit   = A_DBL_ARGV(2);
   dt       = S_DBL_ARGV(3);

   pvprop   = A_DBL_RET_ARGV(0);

   prop2b_c ( gm, pvinit, dt, pvprop );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              psv2pl_c ( ConstSpiceDouble    point[3],
                                ConstSpiceDouble    span1[3],
                                ConstSpiceDouble    span2[3],
                                SpicePlane        * plane     );
*/
void cspice_psv2pl(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * point;
   SpiceDouble        * span1;
   SpiceDouble        * span2;
   SpicePlane           plane;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "point", MiceDouble, 1, {3}, 0},
      { "span1", MiceDouble, 1, {3}, 0},
      { "span2", MiceDouble, 1, {3}, 0},
      { "plane", MicePlane,  0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   point = A_DBL_ARGV(1);
   span1 = A_DBL_ARGV(2);
   span2 = A_DBL_ARGV(3);

   psv2pl_c ( point, span1, span2, &plane );
   CHECK_CALL_FAILURE( SCALAR );

   memcpy( mxGetPr( mxGetField( plhs[0], 0,"normal") ),
           plane.normal,
           3*sizeof(SpiceDouble)
         );

   memcpy( mxGetPr( mxGetField( plhs[0], 0,"constant") ),
           &(plane.constant),
           sizeof(SpiceDouble)
         );

   }




/*
   void              pxform_c ( ConstSpiceChar    * from,
                                ConstSpiceChar    * to,
                                SpiceDouble         et,
                                SpiceDouble         rotate[3][3] );
 */
void cspice_pxform(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_et;
   SpiceDouble        * vec_rotate;
   SpiceChar            from  [DEFAULT_STR_LENGTH+1];
   SpiceChar            to    [DEFAULT_STR_LENGTH+1];
   SpiceDouble          et;
   SpiceDouble        * rotate;
   SpiceDouble          xr[3][3];

   mwIndex              i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "from",   MiceChar,   0, {0},    0},
      { "to",     MiceChar,   0, {0},    0},
      { "et",     MiceDouble, 0, {0},    1},
      { "rotate", MiceDouble, 2, {3, 3}, 1},
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], from, DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], to,   DEFAULT_STR_LENGTH);

   vec_et     = A_DBL_ARGV(3);
   vec_rotate = A_DBL_RET_ARGV(0);
   et         = *(vec_et);
   rotate     =  (vec_rotate);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         et     = *(vec_et     + i*extra->offset[2]);
         rotate =  (vec_rotate + i*extra->offset[3]);

         pxform_c(from, to, et, (SpiceDouble(*)[3])xr);
         CHECK_CALL_FAILURE(i);

         xpose_c( xr, (SpiceDouble(*)[3])rotate );
         }

      }
   else
      {

      pxform_c(from, to, et, (SpiceDouble(*)[3])xr);
      CHECK_CALL_FAILURE(SCALAR);

      xpose_c( xr, (SpiceDouble(*)[3])rotate );
      }

   }




/*
   void              pxfrm2_c ( ConstSpiceChar    * from,
                                ConstSpiceChar    * to,
                                SpiceDouble         etfrom,
                                SpiceDouble         etto,
                                SpiceDouble         rotate[3][3] );
 */
void cspice_pxfrm2(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_etfrom;
   SpiceDouble        * vec_etto;
   SpiceDouble        * vec_rotate;
   SpiceChar            from  [DEFAULT_STR_LENGTH+1];
   SpiceChar            to    [DEFAULT_STR_LENGTH+1];
   SpiceDouble          etfrom;
   SpiceDouble          etto;
   SpiceDouble        * rotate;
   SpiceDouble          xr[3][3];

   mwIndex              i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
   /*                          dimension, shape, vectorized */
      {
      { "from",    MiceChar,   0, {0},    0},
      { "to",      MiceChar,   0, {0},    0},
      { "etfrom",  MiceDouble, 0, {0},    1},
      { "etto",    MiceDouble, 0, {0},    1},
      { "rotate",  MiceDouble, 2, {3, 3}, 1},
      };

   /* check_arg_num checks to see if the number of input and output
      arguments specified by the user are correct. */

   check_arg_num( nrhs, nlhs, 4, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   /* extra-> offset corresponds to argcheck table from[0]*/

   mxGetString(prhs[1], from, DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], to,   DEFAULT_STR_LENGTH);

    /* From function inputs.  Function is [0]*/
   vec_etfrom   = A_DBL_ARGV(3);
   vec_etto     = A_DBL_ARGV(4);
   vec_rotate   = A_DBL_RET_ARGV(0);
   etfrom       = *(vec_etfrom);
   etto         = *(vec_etto);
   rotate       =  (vec_rotate);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         etfrom = *(vec_etfrom + i*extra->offset[2]);
         etto   = *(vec_etto   + i*extra->offset[3]);
         rotate =  (vec_rotate + i*extra->offset[4]);

         pxfrm2_c(from, to, etfrom, etto, (SpiceDouble(*)[3])xr);
         CHECK_CALL_FAILURE(i);

         xpose_c( xr, (SpiceDouble(*)[3])rotate );
         }

      }
   else
      {

      pxfrm2_c(from, to, etfrom, etto, (SpiceDouble(*)[3])xr);
      CHECK_CALL_FAILURE(SCALAR);

      xpose_c( xr, (SpiceDouble(*)[3])rotate );
      }

   }




/*
   void        q2m_c( ConstSpiceDouble  q[4],
                      SpiceDouble       r[3][3] )
*/
void cspice_q2m(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_q;
   SpiceDouble        * vec_r;
   SpiceDouble        * q;
   SpiceDouble        * r;
   SpiceDouble          xr[3][3];

   mwIndex              i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "q", MiceDouble, 1, {4},    1},
      { "r", MiceDouble, 2, {3, 3}, 1},
      };

   check_arg_num( nrhs, nlhs, 1, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_q = A_DBL_ARGV(1);
   vec_r = A_DBL_RET_ARGV(0);
   q     = vec_q;
   r     = vec_r;

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         q =  (vec_q+i*extra->offset[0]);
         r =  (vec_r+i*extra->offset[1]);

         q2m_c(q, (SpiceDouble(*)[3])xr);
         CHECK_CALL_FAILURE(i);

         xpose_c( xr, (SpiceDouble(*)[3])r );
         }

      }
   else
      {

      q2m_c(q, (SpiceDouble(*)[3])xr);
      CHECK_CALL_FAILURE(SCALAR);

      xpose_c( xr, (SpiceDouble(*)[3])r );
      }

   }




/*
   void qderiv_c ( SpiceInt            ndim,
                   ConstSpiceDouble    f0     [],
                   ConstSpiceDouble    f2     [],
                   SpiceDouble         delta,
                   SpiceDouble         dfdt   [] )
*/
void cspice_qderiv(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             ndim;
   ConstSpiceDouble   * f0;
   ConstSpiceDouble   * f2;
   SpiceDouble          delta;
   SpiceDouble        * dfdt;
   SpiceDouble        * ret_dfdt;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "f0",      MiceDouble,   1, {0},   0},
      { "f2",      MiceDouble,   1, {0},   0},
      { "delta",   MiceDouble,   0, {0},   0},
      { "dfdt",    MiceIgnore,   0, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   ndim     = mxGetNumberOfElements(prhs[1]);
   f0       = (ConstSpiceDouble*)mxGetData(prhs[1]);

   if( ndim !=  (SpiceInt)mxGetNumberOfElements( prhs[2] ) )
      {
      mexErrMsgTxt( "MICE(INVALIDSIZE): Array `f2` must have the same "
                             "measure of vectorization as `f0`" );
      }
   f2       = (ConstSpiceDouble*)mxGetData(prhs[2]);

   delta    = S_DBL_ARGV(3);

   ret_dfdt = (SpiceDouble*) mxMalloc( ndim * sizeof(SpiceDouble) );

   qderiv_c ( ndim, f0, f2, delta, ret_dfdt );

   /*
   Check for a failure signal. Free the memory assigned to `ret_dfdt'
   before signaling a Matlab error.
   */
   if ( failed_c())
      {
      mxFree( ret_dfdt );

      /*
      The mice_fail call creates the error string then returns control
      to the MATLAB interpreter.
      */
      mice_fail(SCALAR);
      }

   /*
   Allocate the needed memory to return a vector of size `ndim'
   to MATLAB.
   */
   plhs[0]  = mxCreateDoubleMatrix( ndim, 1, mxREAL );
   dfdt     = A_DBL_RET_ARGV(0);
   MOVED( ret_dfdt, ndim, dfdt );
   mxFree( ret_dfdt );

   }




/*
   void qdq2av_c ( ConstSpiceDouble    q  [4],
                   ConstSpiceDouble    dq [4],
                   SpiceDouble         av [3]  )
*/
void cspice_qdq2av(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * q;
   SpiceDouble        * dq;
   SpiceDouble        * av;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "q",  MiceDouble,  1, {4}, 0},
      { "dq", MiceDouble,  1, {4}, 0},
      { "av", MiceDouble,  1, {3}, 0},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   q        = A_DBL_ARGV(1);
   dq       = A_DBL_ARGV(2);

   av       = A_DBL_RET_ARGV(0);

   qdq2av_c ( q, dq, av );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void qxq_c ( ConstSpiceDouble    q1   [4],
                ConstSpiceDouble    q2   [4],
                SpiceDouble         qout [4]  )
*/
void cspice_qxq(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * q1;
   SpiceDouble        * q2;
   SpiceDouble        * qout;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "q1",   MiceDouble,  1, {4}, 0},
      { "q2",   MiceDouble,  1, {4}, 0},
      { "qout", MiceDouble,  1, {4}, 0},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   q1       = A_DBL_ARGV(1);
   q2       = A_DBL_ARGV(2);

   qout     = A_DBL_RET_ARGV(0);

   qxq_c ( q1, q2, qout );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              rav2xf_c ( ConstSpiceDouble     rot   [3][3],
                                ConstSpiceDouble     av    [3],
                                SpiceDouble          xform [6][6]  );
*/
void cspice_rav2xf(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {
   SpiceDouble  * vec_rot;
   SpiceDouble  * vec_av;
   SpiceDouble  * vec_xform;
   SpiceDouble  * rot;
   SpiceDouble  * av;
   SpiceDouble  * xform;
   SpiceDouble    xr[3][3];
   SpiceDouble    xf[6][6];

   mwIndex        i;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "rot",   MiceDouble, 2, {3,3}, 1},
      { "av",    MiceDouble, 1, {3},   1},
      { "xform", MiceDouble, 2, {6,6}, 1},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_rot   = A_DBL_ARGV(1);
   vec_av    = A_DBL_ARGV(2);
   vec_xform = A_DBL_RET_ARGV(0);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         rot   = (vec_rot    + i*extra->offset[0]);
         av    = (vec_av     + i*extra->offset[1]);
         xform = (vec_xform  + i*extra->offset[2]);

         xpose_c( rot, (SpiceDouble(*)[3])xr );

         rav2xf_c( xr, av, (SpiceDouble(*)[6])xf);
         CHECK_CALL_FAILURE(i);

         xpose6_c( xf, (SpiceDouble(*)[6])xform  );
         }

      }
   else
      {

      rot   = (vec_rot);
      av    = (vec_av);
      xform = (vec_xform);

      xpose_c( rot, (SpiceDouble(*)[3])xr );

      rav2xf_c( xr, av, (SpiceDouble(*)[6])xf);
      CHECK_CALL_FAILURE(SCALAR);

      xpose6_c( xf, (SpiceDouble(*)[6])xform  );
      }

   }




/*
   void              raxisa_c( ConstSpiceDouble     matrix[3][3],
                               SpiceDouble          axis  [3],
                               SpiceDouble        * angle       );

*/
void cspice_raxisa(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble  * matrix;
   SpiceDouble  * axis;
   SpiceDouble  * angle;
   SpiceDouble    xr[3][3];

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "r",     MiceDouble, 2, {3, 3}, 0},
      { "axis",  MiceDouble, 1, {3},    0},
      { "angle", MiceDouble, 0, {0},    0},
      };

   check_arg_num( nrhs, nlhs, 1, 2 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   matrix = A_DBL_ARGV(1);
   axis   = A_DBL_RET_ARGV(0);
   angle  = A_DBL_RET_ARGV(1);

   xpose_c( matrix, (SpiceDouble(*)[3])xr );
   raxisa_c( xr, axis, angle );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              radrec_c ( SpiceDouble         range,
                                SpiceDouble         ra,
                                SpiceDouble         dec,
                                SpiceDouble         rectan[3] );
*/
void cspice_radrec(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_range;
   SpiceDouble        * vec_ra;
   SpiceDouble        * vec_dec;
   SpiceDouble        * vec_rectan;
   SpiceDouble          range;
   SpiceDouble          ra;
   SpiceDouble          dec;
   SpiceDouble        * rectan;

   mwIndex              i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "range",   MiceDouble, 0, {0}, 1},
      { "ra",      MiceDouble, 0, {0}, 1},
      { "dec",     MiceDouble, 0, {0}, 1},
      { "rectan",  MiceDouble, 1, {3}, 1},
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_range  = A_DBL_ARGV(1);
   vec_ra     = A_DBL_ARGV(2);
   vec_dec    = A_DBL_ARGV(3);
   vec_rectan = A_DBL_RET_ARGV(0);
   range      = *(vec_range);
   ra         = *(vec_ra);
   dec        = *(vec_dec);
   rectan     =  (vec_rectan);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         range  = *(vec_range  + i*extra->offset[0]);
         ra     = *(vec_ra     + i*extra->offset[1]);
         dec    = *(vec_dec    + i*extra->offset[2]);
         rectan =  (vec_rectan + i*extra->offset[3]);

         radrec_c( range, ra, dec, rectan);
         CHECK_CALL_FAILURE(i);

         }

      }
   else
      {

      radrec_c( range, ra, dec, rectan);
      CHECK_CALL_FAILURE(SCALAR);

      }

   }




/*
   void recazl_c ( ConstSpiceDouble    rectan [3],
                   SpiceBoolean        azccw,
                   SpiceBoolean        elplsz,
                   SpiceDouble       * range,
                   SpiceDouble       * az,
                   SpiceDouble       * el         )
*/
void cspice_recazl(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * rectan;
   SpiceBoolean         azccw;
   SpiceBoolean         elplsz;
   SpiceDouble        * range;
   SpiceDouble        * az;
   SpiceDouble        * el;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "rectan",  MiceDouble,   1, {3},   0},
      { "azccw",   MiceInt,      0, {0},   0},
      { "elplsz",  MiceInt,      0, {0},   0},
      { "range",   MiceDouble,   0, {0},   0},
      { "az",      MiceDouble,   0, {0},   0},
      { "el",      MiceDouble,   0, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 3, 3 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   rectan   = A_DBL_ARGV(1);

   azccw    = *(SpiceBoolean*)mxGetData(prhs[2]);
   elplsz   = *(SpiceBoolean*)mxGetData(prhs[3]);

   range    = A_DBL_RET_ARGV(0);
   az       = A_DBL_RET_ARGV(1);
   el       = A_DBL_RET_ARGV(2);

   recazl_c ( rectan, azccw, elplsz, range, az, el );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              reccyl_c ( ConstSpiceDouble    rectan[3],
                                SpiceDouble       * r,
                                SpiceDouble       * clon,
                                SpiceDouble       * z         );
*/
void cspice_reccyl(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble       * vec_rectan;
   SpiceDouble       * vec_r;
   SpiceDouble       * vec_clon;
   SpiceDouble       * vec_z;
   SpiceDouble       * rectan;
   SpiceDouble       * r;
   SpiceDouble       * clon;
   SpiceDouble       * z;

   mwIndex             i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "rectan", MiceDouble, 1, {3}, 1},
      { "r",      MiceDouble, 0, {0}, 1},
      { "clon",   MiceDouble, 0, {0}, 1},
      { "z",      MiceDouble, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 1, 3 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_rectan = A_DBL_ARGV(1);
   vec_r      = A_DBL_RET_ARGV(0);
   vec_clon   = A_DBL_RET_ARGV(1);
   vec_z      = A_DBL_RET_ARGV(2);
   rectan     = vec_rectan;
   r          = vec_r;
   clon       = vec_clon;
   z          = vec_z;

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         rectan =  (vec_rectan + i*extra->offset[0]);
         r      =  (vec_r      + i*extra->offset[1]);
         clon   =  (vec_clon   + i*extra->offset[2]);
         z      =  (vec_z      + i*extra->offset[3]);

         reccyl_c(rectan, r, clon, z);
         CHECK_CALL_FAILURE(i);

         }

      }
   else
      {

      reccyl_c(rectan, r, clon, z);
      CHECK_CALL_FAILURE(SCALAR);

      }

   }




/*
   void              recgeo_c ( ConstSpiceDouble    rectan[3],
                                SpiceDouble         re,
                                SpiceDouble         f,
                                SpiceDouble       * lon,
                                SpiceDouble       * lat,
                                SpiceDouble       * alt );
*/
void cspice_recgeo(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble   * vec_rectan;
   SpiceDouble   * vec_lon;
   SpiceDouble   * vec_lat;
   SpiceDouble   * vec_alt;
   SpiceDouble   * rectan;
   SpiceDouble     re;
   SpiceDouble     f;
   SpiceDouble   * lon;
   SpiceDouble   * lat;
   SpiceDouble   * alt;

   mwIndex         i;

   struct extra_dims * extra;
   struct argcheck ArgCheck[] =
      {
      { "rectan", MiceDouble, 1, {3}, 1},
      { "re",     MiceDouble, 0, {0}, 0},
      { "f",      MiceDouble, 0, {0}, 0},
      { "lon",    MiceDouble, 0, {0}, 1},
      { "lat",    MiceDouble, 0, {0}, 1},
      { "alt",    MiceDouble, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 3, 3 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_rectan = A_DBL_ARGV(1);
   vec_lon    = A_DBL_RET_ARGV(0);
   vec_lat    = A_DBL_RET_ARGV(1);
   vec_alt    = A_DBL_RET_ARGV(2);
   re         = S_DBL_ARGV(2);
   f          = S_DBL_ARGV(3);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         rectan =  (vec_rectan + i*extra->offset[0]);
         lon    =  (vec_lon    + i*extra->offset[3]);
         lat    =  (vec_lat    + i*extra->offset[4]);
         alt    =  (vec_alt    + i*extra->offset[5]);

         recgeo_c(rectan, re, f, lon, lat, alt);
         CHECK_CALL_FAILURE(i);

         }

      }
   else
      {

      rectan = vec_rectan;
      lon    = vec_lon;
      lat    = vec_lat;
      alt    = vec_alt;

      recgeo_c(rectan, re, f, lon, lat, alt);
      CHECK_CALL_FAILURE(SCALAR);

      }

   }




/*
   void              reclat_c ( ConstSpiceDouble    rectan[3],
                                SpiceDouble       * radius,
                                SpiceDouble       * lon,
                                SpiceDouble       * lat  );
*/
void cspice_reclat(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_rectan;
   SpiceDouble        * vec_radius;
   SpiceDouble        * vec_lon;
   SpiceDouble        * vec_lat;
   SpiceDouble        * rectan;
   SpiceDouble        * radius;
   SpiceDouble        * lon;
   SpiceDouble        * lat;

   mwIndex              i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "rectan", MiceDouble, 1, {3}, 1},
      { "radius", MiceDouble, 0, {0}, 1},
      { "lon",    MiceDouble, 0, {0}, 1},
      { "lat",    MiceDouble, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 1, 3 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_rectan = A_DBL_ARGV(1);
   vec_radius = A_DBL_RET_ARGV(0);
   vec_lon    = A_DBL_RET_ARGV(1);
   vec_lat    = A_DBL_RET_ARGV(2);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         rectan =  (vec_rectan + i*extra->offset[0]);
         radius =  (vec_radius + i*extra->offset[1]);
         lon    =  (vec_lon    + i*extra->offset[2]);
         lat    =  (vec_lat    + i*extra->offset[3]);

         reclat_c(rectan, radius, lon, lat);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {

      rectan = vec_rectan;
      radius = vec_radius;
      lon    = vec_lon;
      lat    = vec_lat;

      reclat_c(rectan, radius, lon, lat);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void              recpgr_c ( ConstSpiceChar    * body,
                                SpiceDouble         rectan[3],
                                SpiceDouble         re,
                                SpiceDouble         f,
                                SpiceDouble       * lon,
                                SpiceDouble       * lat,
                                SpiceDouble       * alt       );
*/
void cspice_recpgr(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            body       [DEFAULT_STR_LENGTH+1];
   SpiceDouble        * vec_rectan;
   SpiceDouble        * vec_lon;
   SpiceDouble        * vec_lat;
   SpiceDouble        * vec_alt;
   SpiceDouble        * rectan;
   SpiceDouble          re;
   SpiceDouble          f;
   SpiceDouble        * lon;
   SpiceDouble        * lat;
   SpiceDouble        * alt;

   mwIndex              i;

   struct extra_dims * extra;
   struct argcheck ArgCheck[] =
      {
      { "body",   MiceChar,   0, {0}, 0},
      { "rectan", MiceDouble, 1, {3}, 1},
      { "re",     MiceDouble, 0, {0}, 0},
      { "f",      MiceDouble, 0, {0}, 0},
      { "lon",    MiceDouble, 0, {0}, 1},
      { "lat",    MiceDouble, 0, {0}, 1},
      { "alt",    MiceDouble, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 4, 3 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString( prhs[1], body, DEFAULT_STR_LENGTH );
   vec_rectan = A_DBL_ARGV(2);
   re         = S_DBL_ARGV(3);
   f          = S_DBL_ARGV(4);

   vec_lon    = A_DBL_RET_ARGV(0);
   vec_lat    = A_DBL_RET_ARGV(1);
   vec_alt    = A_DBL_RET_ARGV(2);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         rectan =  (vec_rectan + i*extra->offset[1]);
         lon    =  (vec_lon    + i*extra->offset[4]);
         lat    =  (vec_lat    + i*extra->offset[5]);
         alt    =  (vec_alt    + i*extra->offset[6]);

         recpgr_c(body, rectan, re, f, lon, lat, alt);
         CHECK_CALL_FAILURE(i);

         }

      }
   else
      {

      rectan = vec_rectan;
      lon    = vec_lon;
      lat    = vec_lat;
      alt    = vec_alt;

      recpgr_c(body, rectan, re, f, lon, lat, alt);
      CHECK_CALL_FAILURE(SCALAR);

      }

   }





/*
   void              recrad_c ( ConstSpiceDouble    rectan[3],
                                SpiceDouble       * radius,
                                SpiceDouble       * ra,
                                SpiceDouble       * dec  );
*/
void cspice_recrad(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_rectan;
   SpiceDouble        * vec_range;
   SpiceDouble        * vec_ra;
   SpiceDouble        * vec_dec;
   SpiceDouble        * rectan;
   SpiceDouble        * range;
   SpiceDouble        * ra;
   SpiceDouble        * dec;

   mwIndex              i;

   struct extra_dims  * extra;

   struct argcheck ArgCheck[] =
      {
      { "rectan", MiceDouble, 1, {3}, 1},
      { "range",  MiceDouble, 0, {0}, 1},
      { "ra",     MiceDouble, 0, {0}, 1},
      { "dec",    MiceDouble, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 1, 3 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_rectan = A_DBL_ARGV(1);
   vec_range  =  A_DBL_RET_ARGV(0);
   vec_ra     =  A_DBL_RET_ARGV(1);
   vec_dec    =  A_DBL_RET_ARGV(2);
   rectan     =  vec_rectan;
   range      =  vec_range;
   ra         =  vec_ra;
   dec        =  vec_dec;

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         rectan =  (vec_rectan + i*extra->offset[0]);
         range  =  (vec_range  + i*extra->offset[1]);
         ra     =  (vec_ra     + i*extra->offset[2]);
         dec    =  (vec_dec    + i*extra->offset[3]);

         recrad_c(rectan, range, ra, dec);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {

      recrad_c(rectan, range, ra, dec);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void              recsph_c ( ConstSpiceDouble    rectan[3],
                                SpiceDouble       * r,
                                SpiceDouble       * colat,
                                SpiceDouble       * slon );
*/
void cspice_recsph(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_rectan;
   SpiceDouble        * vec_r;
   SpiceDouble        * vec_colat;
   SpiceDouble        * vec_slon;
   SpiceDouble        * rectan;
   SpiceDouble        * r;
   SpiceDouble        * colat;
   SpiceDouble        * slon;

   mwIndex              i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "rectan", MiceDouble, 1, {3}, 1},
      { "r",      MiceDouble, 0, {0}, 1},
      { "colat",  MiceDouble, 0, {0}, 1},
      { "slon",   MiceDouble, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 1, 3 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_rectan = A_DBL_ARGV(1);
   vec_r      = A_DBL_RET_ARGV(0);
   vec_colat  = A_DBL_RET_ARGV(1);
   vec_slon   = A_DBL_RET_ARGV(2);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         rectan =  (vec_rectan + i*extra->offset[0]);
         r      =  (vec_r      + i*extra->offset[1]);
         colat  =  (vec_colat  + i*extra->offset[2]);
         slon   =  (vec_slon   + i*extra->offset[3]);

         recsph_c(rectan, r, colat, slon);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {

      rectan = vec_rectan;
      r      = vec_r;
      colat  = vec_colat;
      slon   = vec_slon;

      recsph_c(rectan, r, colat, slon);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void repmc_c ( ConstSpiceChar    * in,
                  ConstSpiceChar    * marker,
                  ConstSpiceChar    * value,
                  SpiceInt            outlen,
                  SpiceChar         * out    )
*/
void cspice_repmc(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            in     [DEFAULT_STR_LENGTH+1];
   SpiceChar            marker [DEFAULT_STR_LENGTH+1];
   SpiceChar            value  [DEFAULT_STR_LENGTH+1];
   SpiceChar            out    [DEFAULT_STR_LENGTH+1];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "in",      MiceChar,     0, {0},   0},
      { "marker",  MiceChar,     0, {0},   0},
      { "value",   MiceChar,     0, {0},   0},
      { "out",     MiceChar,     0, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   memset( out, 0, default_str_size );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], in, DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], marker, DEFAULT_STR_LENGTH);
   mxGetString(prhs[3], value, DEFAULT_STR_LENGTH);


   repmc_c ( in, marker, value, DEFAULT_STR_LENGTH, out );
   CHECK_CALL_FAILURE(SCALAR);

   plhs[0] = mxCreateString(out);

   if (plhs[0] == NULL)
      {
      mexErrMsgTxt( "MICE(BUG): mxCreateString failed in cspice_repmc" );
      }

   }




/*
   void repmct_c ( ConstSpiceChar   * in,
                   ConstSpiceChar   * marker,
                   SpiceInt           value,
                   SpiceChar          rtcase,
                   SpiceInt           outlen,
                   SpiceChar        * out      )
*/
void cspice_repmct(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            in     [DEFAULT_STR_LENGTH+1];
   SpiceChar            marker [DEFAULT_STR_LENGTH+1];
   SpiceInt             value;
   SpiceChar            rtcase [2];
   SpiceChar            out    [DEFAULT_STR_LENGTH+1];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "in",      MiceChar,     0, {0},   0},
      { "marker",  MiceChar,     0, {0},   0},
      { "value",   MiceInt,      0, {0},   0},
      { "rtcase",  MiceChar,     0, {0},   0},
      { "out",     MiceChar,     0, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 4, 1 );

   memset( out, 0, default_str_size );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], in, DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], marker, DEFAULT_STR_LENGTH);

   value    = S_INT_ARGV(3);

   mxGetString(prhs[4], rtcase, 2);


   repmct_c ( in,                   marker,             value,
              (SpiceChar)rtcase[0], DEFAULT_STR_LENGTH, out );
   CHECK_CALL_FAILURE(SCALAR);

   plhs[0] = mxCreateString(out);

   if (plhs[0] == NULL)
      {
      mexErrMsgTxt( "MICE(BUG): mxCreateString failed in cspice_repmct" );
      }

   }




/*
   void repmd_c ( ConstSpiceChar     * in,
                  ConstSpiceChar     * marker,
                  SpiceDouble          value,
                  SpiceInt             sigdig,
                  SpiceInt             outlen,
                  SpiceChar          * out     )
*/
void cspice_repmd(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            in     [DEFAULT_STR_LENGTH+1];
   SpiceChar            marker [DEFAULT_STR_LENGTH+1];
   SpiceDouble          value;
   SpiceInt             sigdig;
   SpiceChar            out    [DEFAULT_STR_LENGTH+1];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "in",      MiceChar,     0, {0},   0},
      { "marker",  MiceChar,     0, {0},   0},
      { "value",   MiceDouble,   0, {0},   0},
      { "sigdig",  MiceInt,      0, {0},   0},
      { "out",     MiceChar,     0, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 4, 1 );

   memset( out, 0, default_str_size );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], in, DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], marker, DEFAULT_STR_LENGTH);

   value    = S_DBL_ARGV(3);
   sigdig   = S_INT_ARGV(4);


   repmd_c ( in, marker, value, sigdig, DEFAULT_STR_LENGTH, out );
   CHECK_CALL_FAILURE(SCALAR);

   plhs[0] = mxCreateString(out);

   if (plhs[0] == NULL)
      {
      mexErrMsgTxt( "MICE(BUG): mxCreateString failed in cspice_repmd" );
      }

   }




/*
   void repmf_c ( ConstSpiceChar     * in,
                  ConstSpiceChar     * marker,
                  SpiceDouble          value,
                  SpiceInt             sigdig,
                  SpiceChar            format,
                  SpiceInt             outlen,
                  SpiceChar          * out )
*/
void cspice_repmf(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            in     [DEFAULT_STR_LENGTH+1];
   SpiceChar            marker [DEFAULT_STR_LENGTH+1];
   SpiceDouble          value;
   SpiceInt             sigdig;
   SpiceChar            format [2];
   SpiceChar            out    [DEFAULT_STR_LENGTH+1];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "in",      MiceChar,     0, {0},   0},
      { "marker",  MiceChar,     0, {0},   0},
      { "value",   MiceDouble,   0, {0},   0},
      { "sigdig",  MiceInt,      0, {0},   0},
      { "format",  MiceChar,     0, {0},   0},
      { "out",     MiceChar,     0, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 5, 1 );

   memset( out, 0, default_str_size );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], in, DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], marker, DEFAULT_STR_LENGTH);

   value    = S_DBL_ARGV(3);
   sigdig   = S_INT_ARGV(4);

   mxGetString(prhs[5], format, 2);


   repmf_c ( in,                   marker,             value, sigdig,
             (SpiceChar)format[0], DEFAULT_STR_LENGTH, out );
   CHECK_CALL_FAILURE(SCALAR);

   plhs[0] = mxCreateString(out);

   if (plhs[0] == NULL)
      {
      mexErrMsgTxt( "MICE(BUG): mxCreateString failed in cspice_repmf" );
      }

   }




/*
   void repmi_c ( ConstSpiceChar     * in,
                  ConstSpiceChar     * marker,
                  SpiceInt             value,
                  SpiceInt             outlen,
                  SpiceChar          * out     )
*/
void cspice_repmi(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            in     [DEFAULT_STR_LENGTH+1];
   SpiceChar            marker [DEFAULT_STR_LENGTH+1];
   SpiceInt             value;
   SpiceChar            out    [DEFAULT_STR_LENGTH+1];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "in",      MiceChar,     0, {0},   0},
      { "marker",  MiceChar,     0, {0},   0},
      { "value",   MiceInt,      0, {0},   0},
      { "out",     MiceChar,     0, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   memset( out, 0, default_str_size );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], in, DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], marker, DEFAULT_STR_LENGTH);

   value    = S_INT_ARGV(3);


   repmi_c ( in, marker, value, DEFAULT_STR_LENGTH, out );
   CHECK_CALL_FAILURE(SCALAR);

   plhs[0] = mxCreateString(out);

   if (plhs[0] == NULL)
      {
      mexErrMsgTxt( "MICE(BUG): mxCreateString failed in cspice_repmi" );
      }

   }




/*
   void repml_c  ( ConstSpiceChar    * in,
                   ConstSpiceChar    * marker,
                   SpiceBoolean        value,
                   SpiceChar           rtcase,
                   SpiceInt            outlen,
                   SpiceChar         * out    )
*/
void cspice_repml(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            in     [DEFAULT_STR_LENGTH+1];
   SpiceChar            marker [DEFAULT_STR_LENGTH+1];
   SpiceBoolean         value;
   SpiceChar            rtcase [2];
   SpiceChar            out    [DEFAULT_STR_LENGTH+1];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "in",      MiceChar,     0, {0},   0},
      { "marker",  MiceChar,     0, {0},   0},
      { "value",   MiceInt,      0, {0},   0},
      { "rtcase",  MiceChar,     0, {0},   0},
      { "out",     MiceChar,     0, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 4, 1 );

   memset( out, 0, default_str_size );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], in, DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], marker, DEFAULT_STR_LENGTH);

   value    = *(SpiceBoolean*)mxGetData(prhs[3]);

   mxGetString(prhs[4], rtcase, 2);


   repml_c ( in,                   marker,             value,
             (SpiceChar)rtcase[0], DEFAULT_STR_LENGTH, out );
   CHECK_CALL_FAILURE(SCALAR);

   plhs[0] = mxCreateString(out);

   if (plhs[0] == NULL)
      {
      mexErrMsgTxt( "MICE(BUG): mxCreateString failed in cspice_repml" );
      }

   }




/*
   void repmot_c ( ConstSpiceChar   * in,
                   ConstSpiceChar   * marker,
                   SpiceInt           value,
                   SpiceChar          rtcase,
                   SpiceInt           outlen,
                   SpiceChar        * out      )
*/
void cspice_repmot(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            in     [DEFAULT_STR_LENGTH+1];
   SpiceChar            marker [DEFAULT_STR_LENGTH+1];
   SpiceInt             value;
   SpiceChar            rtcase [2];
   SpiceChar            out    [DEFAULT_STR_LENGTH+1];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "in",      MiceChar,     0, {0},   0},
      { "marker",  MiceChar,     0, {0},   0},
      { "value",   MiceInt,      0, {0},   0},
      { "rtcase",  MiceChar,     0, {0},   0},
      { "out",     MiceChar,     0, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 4, 1 );

   memset( out, 0, default_str_size );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], in, DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], marker, DEFAULT_STR_LENGTH);

   value    = S_INT_ARGV(3);

   mxGetString(prhs[4], rtcase, 2);


   repmot_c ( in,                   marker,             value,
              (SpiceChar)rtcase[0], DEFAULT_STR_LENGTH, out );
   CHECK_CALL_FAILURE(SCALAR);

   plhs[0] = mxCreateString(out);

   if (plhs[0] == NULL)
      {
      mexErrMsgTxt( "MICE(BUG): mxCreateString failed in cspice_repmot" );
      }

   }




/*
   void rotvec_c ( ConstSpiceDouble  v1    [3],
                   SpiceDouble       angle,
                   SpiceInt          iaxis,
                   SpiceDouble       vout  [3] )
*/
void cspice_rotvec(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * v1;
   SpiceDouble          angle;
   SpiceInt             iaxis;
   SpiceDouble        * vout;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "v1",    MiceDouble,  1, {3}, 0},
      { "angle", MiceDouble,  0, {0}, 0},
      { "iaxis", MiceInt,     0, {0}, 0},
      { "vout",  MiceDouble,  1, {3}, 0},
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   v1       = A_DBL_ARGV(1);
   angle    = S_DBL_ARGV(2);
   iaxis    = S_INT_ARGV(3);

   vout     = A_DBL_RET_ARGV(0);

   rotvec_c ( v1, angle, iaxis, vout );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   SpiceDouble rpd_c( void )
*/
void cspice_rpd(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   check_arg_num( nrhs, nlhs, 0, 1 );

   /*
   Directly return the scalar value. This simple case needs no
   error checks.
   */
   plhs[0] = mxCreateDoubleScalar( rpd_c() );

   }




/*
   void              rotate_c ( SpiceDouble         angle,
                                SpiceInt            iaxis,
                                SpiceDouble         mout[3][3] );
*/
void cspice_rotate(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_angle;
   SpiceDouble        * vec_mout;
   SpiceDouble          angle;
   SpiceInt             iaxis;
   SpiceDouble        * mout;
   SpiceDouble          xr[3][3];

   mwIndex        i;

   struct extra_dims *extra;

   struct argcheck ArgCheck[] =
      {
      { "angle", MiceDouble, 0, {0},    1},
      { "iaxis", MiceInt,    0, {0},    0},
      { "mout",  MiceDouble, 2, {3, 3}, 1},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_angle = A_DBL_ARGV(1);
   vec_mout  = A_DBL_RET_ARGV(0);
   iaxis     =  S_INT_ARGV(2);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         angle = *(vec_angle + i*extra->offset[0]);
         mout  =  (vec_mout  + i*extra->offset[2]);

         rotate_c(angle, iaxis, (SpiceDouble(*)[3])xr);
         CHECK_CALL_FAILURE(i);

         xpose_c( xr, (SpiceDouble(*)[3])mout);
         }

      }
   else
      {

      angle = *vec_angle;
      mout  = vec_mout;

      rotate_c(angle, iaxis, (SpiceDouble(*)[3])xr);
      CHECK_CALL_FAILURE(SCALAR);

      xpose_c( xr, (SpiceDouble(*)[3])mout);
      }

   }




/*
   void              rotmat_c ( ConstSpiceDouble    m1[3][3],
                                SpiceDouble         angle,
                                SpiceInt            iaxis,
                                SpiceDouble         mout[3][3] );
*/
void cspice_rotmat(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * m1;
   SpiceDouble          angle;
   SpiceInt             iaxis;
   SpiceDouble        * mout;
   SpiceDouble          xr[3][3];
   SpiceDouble          yr[3][3];

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "m1",    MiceDouble, 2, {3, 3}, 0},
      { "angle", MiceDouble, 0, {0},    0},
      { "iaxis", MiceInt,    0, {0},    0},
      { "mout",  MiceDouble, 2, {3, 3}, 0},
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   m1    = A_DBL_ARGV(1);
   angle = S_DBL_ARGV(2);
   iaxis = S_INT_ARGV(3);
   mout  = A_DBL_RET_ARGV(0);

   xpose_c( m1, (SpiceDouble(*)[3])yr);

   rotmat_c(yr, angle, iaxis, (SpiceDouble(*)[3])xr);
   CHECK_CALL_FAILURE(SCALAR);

   xpose_c( xr, (SpiceDouble(*)[3])mout);

   }




/*
   void              saelgv_c ( ConstSpiceDouble    vec1  [3],
                                ConstSpiceDouble    vec2  [3],
                                SpiceDouble         smajor[3],
                                SpiceDouble         sminor[3]  );
*/
void cspice_saelgv(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec1;
   SpiceDouble        * vec2;
   SpiceDouble        * smajor;
   SpiceDouble        * sminor;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "vec1",   MiceDouble,  1, {3}, 0},
      { "vec2",   MiceDouble,  1, {3}, 0},
      { "smajor", MiceDouble,  1, {3}, 0},
      { "sminor", MiceDouble,  1, {3}, 0},
      };

   check_arg_num( nrhs, nlhs, 2, 2 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec1   = A_DBL_ARGV(1);
   vec2   = A_DBL_ARGV(2);
   smajor = A_DBL_RET_ARGV(0);
   sminor = A_DBL_RET_ARGV(1);

   saelgv_c ( vec1, vec2, smajor, sminor );
   CHECK_CALL_FAILURE( SCALAR );

   }




/*
   void              scdecd_c ( SpiceInt            sc,
                                SpiceDouble         sclkdp,
                                SpiceInt            sclklen,
                                SpiceChar         * sclkch   );
*/
void cspice_scdecd(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {
   SpiceInt            sc;
   SpiceDouble         sclkdp;
   SpiceDouble       * vec_sclkdp;
   SpiceChar        ** cval;
   SpiceChar        ** array;
   SpiceChar           sclkch[DEFAULT_STR_LENGTH+1];

   mwIndex             i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "sc",     MiceInt,    0, {0}, 0},
      { "sclkdp", MiceDouble, 0, {0}, 1},
      { "sclkch", MiceChar,   0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   sc         = S_INT_ARGV(1);
   vec_sclkdp = A_DBL_ARGV(2);

   if (extra->count>1)
      {

      /*
      Allocate needed memory for intermediate operations.
      */
      cval  = (SpiceChar**)alloc_SpiceString_C_array(DEFAULT_STR_LENGTH,
                                                     extra->count );
      array = (SpiceChar**)alloc_SpiceString_Pointer_array(extra->count);

      /*
      Test for a SPICE error signal, if found, display an error message to
      the user then return to the MATLAB application.
      */
      CHECK_CALL_FAILURE_MEM1(SCALAR, 1, cval, array);

      for (i=0;i<extra->count;i++)
         {

         sclkdp = *(vec_sclkdp+i*extra->offset[1]);

         /*
         Copy the ith string pointer to the array of pointers,
         use this pointer for the call output.
         */
         array[i] = *cval + i*default_str_size;

         scdecd_c(sc, sclkdp, DEFAULT_STR_LENGTH, array[i]);
         CHECK_CALL_FAILURE_MEM1(i, 1, cval, array);
         }

      /*
      I think this functions as a copy, creating needed memory to plhs.
      */
      plhs[0] = mxCreateCharMatrixFromStrings( extra->count,
                                               (const char **)array);

      free_SpiceString_C_array ( 1, cval );
      free_SpiceMemory( array );
      }
   else
      {

      sclkdp = *(vec_sclkdp);

      scdecd_c(sc, sclkdp, DEFAULT_STR_LENGTH, sclkch);
      CHECK_CALL_FAILURE(SCALAR);

      plhs[0] = mxCreateString( sclkch );
      if ( plhs[0] == NULL )
         {
         mexErrMsgTxt( "MICE(BUG): mxCreateString failed in cspice_scdecd" );
         }

      }

   /*
   Confirm the code released all allocated memory.
   */
   MICE_ALLOC_CHECK;

   }




/*
   void              sce2c_c  ( SpiceInt            sc,
                                SpiceDouble         et,
                                SpiceDouble       * sclkdp   );
*/
void cspice_sce2c(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt            sc;
   SpiceDouble         et;
   SpiceDouble       * vec_et;
   SpiceDouble       * sclkdp;
   SpiceDouble       * vec_sclkdp;

   mwIndex             i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "sc",     MiceInt,    0, {0}, 0},
      { "et",     MiceDouble, 0, {0}, 1},
      { "sclkdp", MiceDouble, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   sc         = S_INT_ARGV(1);
   vec_et     = A_DBL_ARGV(2);
   vec_sclkdp = A_DBL_RET_ARGV(0);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         et     = *(vec_et+i*extra->offset[1]);
         sclkdp =  (vec_sclkdp+i*extra->offset[2]);

         sce2c_c(sc, et, sclkdp);
         CHECK_CALL_FAILURE(i);

         }

      }
   else
      {

      et     = *(vec_et);
      sclkdp =  (vec_sclkdp);

      sce2c_c(sc, et, sclkdp);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void              sce2s_c  ( SpiceInt            sc,
                                SpiceDouble         et,
                                SpiceInt            sclklen,
                                SpiceChar         * sclkch   );
*/
void cspice_sce2s(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt            sc;
   SpiceDouble         et;
   SpiceDouble       * vec_et;
   SpiceChar        ** cval;
   SpiceChar        ** array;
   SpiceChar           sclkch[DEFAULT_STR_LENGTH+1];

   mwIndex             i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "sc",     MiceInt,    0, {0}, 0},
      { "et",     MiceDouble, 0, {0}, 1},
      { "sclkch", MiceChar,   0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   sc     = S_INT_ARGV(1);
   vec_et = A_DBL_ARGV(2);

   if (extra->count>1)
      {

      /*
      Allocate needed memory for intermediate operations.
      */
      cval  = (SpiceChar**)alloc_SpiceString_C_array(DEFAULT_STR_LENGTH,
                                                     extra->count );
      array = (SpiceChar**)alloc_SpiceString_Pointer_array(extra->count);

      /*
      Test for a SPICE error signal, if found, display an error message to
      the user then return to the MATLAB application.
      */
      CHECK_CALL_FAILURE_MEM1(SCALAR, 1, cval, array);

      for (i=0;i<extra->count;i++)
         {

         et = *(vec_et+i*extra->offset[1]);

         /*
         Copy the ith string pointer to the array of pointers,
         use this pointer for the call output.
         */
         array[i] = *cval + i*default_str_size;

         sce2s_c(sc, et, DEFAULT_STR_LENGTH, array[i]);
         CHECK_CALL_FAILURE_MEM1(i, 1, cval, array);
         }

      /*
      I think this functions as a copy, creating needed memory to plhs.
      */
      plhs[0] = mxCreateCharMatrixFromStrings( extra->count,
                                               (const char **)array);

      free_SpiceString_C_array ( 1, cval );
      free_SpiceMemory( array );
      }
   else
      {

      et = *(vec_et);

      sce2s_c(sc, et, DEFAULT_STR_LENGTH, sclkch);
      CHECK_CALL_FAILURE(SCALAR);

      plhs[0] = mxCreateString( sclkch );
      if ( plhs[0] == NULL )
         {
         mexErrMsgTxt( "MICE(BUG): mxCreateString failed in cspice_scdecd" );
         }

      }

   /*
   Confirm the code released all allocated memory.
   */
   MICE_ALLOC_CHECK;

   }




/*
   void              scencd_c ( SpiceInt            sc,
                                ConstSpiceChar    * sclkch,
                                SpiceDouble       * sclkdp   );
*/
void cspice_scencd(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             sc;
   SpiceChar            sclkch[DEFAULT_STR_LENGTH+1];
   mxChar             * mx_sclkch;
   SpiceDouble        * sclkdp;
   SpiceDouble        * vec_sclkdp;

   mwIndex              i;
   SpiceInt             j;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "sc",     MiceInt,    0, {0}, 0},
      { "sclkch", MiceChar,   0, {0}, 1},
      { "sclkdp", MiceDouble, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   sc         = S_INT_ARGV(1);
   vec_sclkdp = A_DBL_RET_ARGV(0);

   if (extra->count>1)
      {

      mx_sclkch = (mxChar *)mxGetChars(prhs[2]);

      for (i=0;i<extra->count;i++)
         {

         /*
         Extract the string data, character by character, into
         CSPICE strings. The mx_str array stores the data in a column
         major format, we need to extract the data by rows.
         */
         for (j=0;j<extra->offset[1];j++)
            {
            sclkch[j] = (char)mx_sclkch[i + (extra->count*j)];
            }

         sclkch[extra->offset[1]] = '\0';
         sclkdp                   = (vec_sclkdp+i*extra->offset[2]);

         scencd_c(sc, sclkch, sclkdp);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {

      mxGetString(prhs[2], sclkch, DEFAULT_STR_LENGTH);

      sclkdp = vec_sclkdp;

      scencd_c(sc, sclkch, sclkdp);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void scfmt_c  ( SpiceInt            sc,
                   SpiceDouble         ticks,
                   SpiceInt            clklen,
                   SpiceChar         * clkstr )
*/
void cspice_scfmt(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             sc;
   SpiceDouble          ticks;
   SpiceChar            clkstr [DEFAULT_STR_LENGTH+1];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "sc",      MiceInt,      0, {0},   0},
      { "ticks",   MiceDouble,   0, {0},   0},
      { "clkstr",  MiceChar,     0, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   memset( clkstr, 0, default_str_size );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   sc       = S_INT_ARGV(1);
   ticks    = S_DBL_ARGV(2);


   scfmt_c ( sc, ticks, DEFAULT_STR_LENGTH, clkstr );
   CHECK_CALL_FAILURE(SCALAR);

   plhs[0] = mxCreateString(clkstr);

   if (plhs[0] == NULL)
      {
      mexErrMsgTxt( "MICE(BUG): mxCreateString failed in cspice_scfmt" );
      }

   }




/*
   void scpart_c ( SpiceInt            sc,
                   SpiceInt          * nparts,
                   SpiceDouble         pstart [],
                   SpiceDouble         pstop  [] )
*/
void cspice_scpart(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             sc;
   SpiceInt             nparts;
   SpiceDouble        * pstart;
   SpiceDouble        * pstop;
   SpiceDouble          ret_pstart [SPICE_SCLK_MXPART];
   SpiceDouble          ret_pstop  [SPICE_SCLK_MXPART];


   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "sc",      MiceInt,      0, {0},   0},
      { "pstart",  MiceDouble,   1, {0},   0},
      { "pstop",   MiceDouble,   1, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 1, 2 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   sc       = S_INT_ARGV(1);

   scpart_c ( sc, &nparts, ret_pstart, ret_pstop );
   CHECK_CALL_FAILURE(SCALAR);

   /*
   Allocate the needed memory to return

      pstart
      pstop

   vectors of size `nparts' to MATLAB.
   */
   plhs[0]  = mxCreateDoubleMatrix( nparts, 1, mxREAL );
   plhs[1]  = mxCreateDoubleMatrix( nparts, 1, mxREAL );

   pstart   = A_DBL_RET_ARGV(0);
   pstop    = A_DBL_RET_ARGV(1);

   MOVED( ret_pstart, nparts, pstart );
   MOVED( ret_pstop,  nparts, pstop  );

   }




/*
   void              scs2e_c  ( SpiceInt            sc,
                                ConstSpiceChar    * sclkch,
                                SpiceDouble       * et      );
*/
void cspice_scs2e(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             sc;
   SpiceChar            sclkch[DEFAULT_STR_LENGTH+1];
   mxChar             * mx_sclkch;
   SpiceDouble        * vec_et;
   SpiceDouble        * et;

   mwIndex              i;
   SpiceInt             j;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "sc",     MiceInt,    0, {0}, 0},
      { "sclkch", MiceChar,   0, {0}, 1},
      { "et",     MiceDouble, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   sc     = S_INT_ARGV(1);
   vec_et = A_DBL_RET_ARGV(0);

   if (extra->count>1)
      {

      mx_sclkch = (mxChar *)mxGetChars(prhs[2]);

      for (i=0;i<extra->count;i++)
         {

         /*
         Extract the string data, character by character, into
         CSPICE strings. The mx_str array stores the data in a column
         major format, we need to extract the data by rows.
         */
         for (j=0;j<extra->offset[1];j++)
            {
            sclkch[j] = (char)mx_sclkch[i + (extra->count*j)];
            }

         sclkch[extra->offset[1]] = '\0';
         et                       =  (vec_et+i*extra->offset[2]);

         scs2e_c(sc, sclkch, et);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {

      mxGetString(prhs[2], sclkch, DEFAULT_STR_LENGTH);

      et = (vec_et);

      scs2e_c(sc, sclkch, et);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void sct2e_c( SpiceInt       sc,
                  SpiceDouble    sclkdp,
                  SpiceDouble  * et     )
*/
void cspice_sct2e(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             sc;
   SpiceDouble          sclkdp;
   SpiceDouble        * vec_sclkdp;
   SpiceDouble        * et;
   SpiceDouble        * vec_et;

   mwIndex              i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "sc",     MiceInt,    0, {0}, 0},
      { "sclkdp", MiceDouble, 0, {0}, 1},
      { "et",     MiceDouble, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   sc         = S_INT_ARGV(1);
   vec_sclkdp = A_DBL_ARGV(2);
   vec_et     = A_DBL_RET_ARGV(0);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         sclkdp = *(vec_sclkdp + i*extra->offset[1]);
         et     =  (vec_et     + i*extra->offset[2]);

         sct2e_c(sc, sclkdp, et);
         CHECK_CALL_FAILURE(i);

         }

      }
   else
      {

      sclkdp = *(vec_sclkdp);
      et     =  (vec_et);

      sct2e_c(sc, sclkdp, et);
      CHECK_CALL_FAILURE(SCALAR);

      }

   }




/*

   void              sctiks_c ( SpiceInt            sc,
                                ConstSpiceChar    * clkstr,
                                SpiceDouble       * ticks   );
*/
void cspice_sctiks(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             sc;
   SpiceChar            clkstr[DEFAULT_STR_LENGTH+1];
   mxChar             * mx_clkstr;
   SpiceDouble        * ticks;
   SpiceDouble        * vec_ticks;

   mwIndex              i;
   SpiceInt             j;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "sc",     MiceInt,   0, {0}, 0},
      { "clkstr", MiceChar,  0, {0}, 1},
      { "ticks", MiceDouble, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   sc         = S_INT_ARGV(1);
   vec_ticks = A_DBL_RET_ARGV(0);

   if (extra->count>1)
      {

      mx_clkstr = (mxChar *)mxGetChars(prhs[2]);

      for (i=0;i<extra->count;i++)
         {

         /*
         Extract the string data, character by character, into
         CSPICE strings. The mx_str array stores the data in a column
         major format, we need to extract the data by rows.
         */
         for (j=0;j<extra->offset[1];j++)
            {
            clkstr[j] = (char)mx_clkstr[i + (extra->count*j)];
            }

         clkstr[extra->offset[1]] = '\0';
         ticks                   = (vec_ticks+i*extra->offset[2]);

         sctiks_c(sc, clkstr, ticks);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {

      mxGetString(prhs[2], clkstr, DEFAULT_STR_LENGTH);

      ticks = vec_ticks;

      sctiks_c(sc, clkstr, ticks);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   SpiceDouble spd_c( void )
*/
void cspice_spd(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   check_arg_num( nrhs, nlhs, 0, 1 );

   /*
   Directly return the scalar value. This simple case needs no
   error checks.
   */
   plhs[0] = mxCreateDoubleScalar( spd_c() );

   }




/*
   void sphcyl_c( SpiceDouble      radius,
                   SpiceDouble     colat,
                   SpiceDouble     slon,
                   SpiceDouble   * r,
                   SpiceDouble   * clon,
                   SpiceDouble   * z )
*/
void cspice_sphcyl(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble         * vec_radius;
   SpiceDouble         * vec_colat;
   SpiceDouble         * vec_slon;
   SpiceDouble         * vec_r;
   SpiceDouble         * vec_clon;
   SpiceDouble         * vec_z;
   SpiceDouble           radius;
   SpiceDouble           colat;
   SpiceDouble           slon;
   SpiceDouble         * r;
   SpiceDouble         * clon;
   SpiceDouble         * z;

   mwIndex               i;

   struct extra_dims   * extra;
   struct argcheck ArgCheck[] =
      {
      { "radius", MiceDouble, 0, {0}, 1},
      { "colat",  MiceDouble, 0, {0}, 1},
      { "slon",   MiceDouble, 0, {0}, 1},
      { "r",      MiceDouble, 0, {0}, 1},
      { "clon",   MiceDouble, 0, {0}, 1},
      { "z",      MiceDouble, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 3, 3 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_radius = A_DBL_ARGV(1);
   vec_colat  = A_DBL_ARGV(2);
   vec_slon   = A_DBL_ARGV(3);
   vec_r      = A_DBL_RET_ARGV(0);
   vec_clon   = A_DBL_RET_ARGV(1);
   vec_z      = A_DBL_RET_ARGV(2);
   radius     = *vec_radius;
   colat      = *vec_colat;
   slon       = *vec_slon;
   r          =  vec_r;
   clon       =  vec_clon;
   z          =  vec_z;

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         radius = *(vec_radius + i*extra->offset[0]);
         colat  = *(vec_colat  + i*extra->offset[1]);
         slon   = *(vec_slon   + i*extra->offset[2]);
         r      =  (vec_r      + i*extra->offset[3]);
         clon   =  (vec_clon   + i*extra->offset[4]);
         z      =  (vec_z      + i*extra->offset[5]);

         sphcyl_c(radius, colat, slon, r, clon, z);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {

      sphcyl_c(radius, colat, slon, r, clon, z);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void              sincpt_c ( ConstSpiceChar    * method,
                                ConstSpiceChar    * target,
                                SpiceDouble         et,
                                ConstSpiceChar    * fixref,
                                ConstSpiceChar    * abcorr,
                                ConstSpiceChar    * obsrvr,
                                ConstSpiceChar    * dref,
                                ConstSpiceDouble    dvec   [3],
                                SpiceDouble         spoint [3],
                                SpiceDouble       * trgepc,
                                SpiceDouble         srfvec [3],
                                SpiceBoolean      * found         );
*/
void mice_sincpt(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            method[DEFAULT_STR_LENGTH+1];
   SpiceChar            target[DEFAULT_STR_LENGTH+1];
   SpiceChar            fixref[DEFAULT_STR_LENGTH+1];
   SpiceChar            abcorr[DEFAULT_STR_LENGTH+1];
   SpiceChar            obsrvr[DEFAULT_STR_LENGTH+1];
   SpiceChar            dref  [DEFAULT_STR_LENGTH+1];
   SpiceDouble          et;
   SpiceDouble        * dvec;
   SpiceDouble          spoint[3];
   SpiceDouble          trgepc;
   SpiceDouble          srfvec[3];
   SpiceBoolean         found;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "method", MiceChar,    0, {0}, 0},
      { "target", MiceChar,    0, {0}, 0},
      { "et",     MiceDouble,  0, {0}, 0},
      { "fixref", MiceChar,    0, {0}, 0},
      { "abcorr", MiceChar,    0, {0}, 0},
      { "obsrvr", MiceChar,    0, {0}, 0},
      { "dref",   MiceChar,    0, {0}, 0},
      { "dvec",   MiceDouble,  1, {3}, 0},
      { "sincpt", MiceSurf_PS, 0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 8,1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], method, DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], target, DEFAULT_STR_LENGTH);

   et = S_DBL_ARGV(3);

   mxGetString(prhs[4], fixref, DEFAULT_STR_LENGTH);
   mxGetString(prhs[5], abcorr, DEFAULT_STR_LENGTH);
   mxGetString(prhs[6], obsrvr, DEFAULT_STR_LENGTH);
   mxGetString(prhs[7], dref,   DEFAULT_STR_LENGTH);

   dvec   = A_DBL_ARGV(8);

   sincpt_c (  method,
               target,
               et,
               fixref,
               abcorr,
               obsrvr,
               dref,
               dvec,
               spoint,
               &trgepc,
               srfvec,
               &found );

   CHECK_CALL_FAILURE(SCALAR);

   memcpy( mxGetPr( mxGetField(plhs[0],0,"spoint" ) ),
              spoint,
              3*sizeof(SpiceDouble));

   mxDestroyArray( mxGetField( plhs[0], 0, "trgepc" ) );
   mxSetField( plhs[0], 0, "trgepc", mxCreateDoubleScalar(trgepc));

   memcpy( mxGetPr( mxGetField(plhs[0],0,"srfvec" ) ),
              srfvec,
              3*sizeof(SpiceDouble));

   mxDestroyArray( mxGetField( plhs[0], 0, "found" ) );
   mxSetField( plhs[0], 0, "found",
               mxCreateLogicalScalar(found ? true: false));

   }




/*
   void  sphlat_c( SpiceDouble     r,
                   SpiceDouble     colat,
                   SpiceDouble     slon,
                   SpiceDouble   * radius,
                   SpiceDouble   * lon,
                   SpiceDouble   * lat )
*/
void cspice_sphlat(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_r;
   SpiceDouble        * vec_colat;
   SpiceDouble        * vec_slon;
   SpiceDouble        * vec_radius;
   SpiceDouble        * vec_lon;
   SpiceDouble        * vec_lat;
   SpiceDouble          r;
   SpiceDouble          colat;
   SpiceDouble          slon;
   SpiceDouble        * radius;
   SpiceDouble        * lon;
   SpiceDouble        * lat;

   mwIndex              i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "r",      MiceDouble, 0, {0}, 1},
      { "colat",  MiceDouble, 0, {0}, 1},
      { "slon",   MiceDouble, 0, {0}, 1},
      { "radius", MiceDouble, 0, {0}, 1},
      { "lon",    MiceDouble, 0, {0}, 1},
      { "lat",    MiceDouble, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 3, 3 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_r      = A_DBL_ARGV(1);
   vec_colat  = A_DBL_ARGV(2);
   vec_slon   = A_DBL_ARGV(3);
   vec_radius = A_DBL_RET_ARGV(0);
   vec_lon    = A_DBL_RET_ARGV(1);
   vec_lat    = A_DBL_RET_ARGV(2);
   r          = *(vec_r);
   colat      = *(vec_colat);
   slon       = *(vec_slon);
   radius     =  (vec_radius);
   lon        =  (vec_lon);
   lat        =  (vec_lat);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         r      = *(vec_r      + i*extra->offset[0]);
         colat  = *(vec_colat  + i*extra->offset[1]);
         slon   = *(vec_slon   + i*extra->offset[2]);
         radius =  (vec_radius + i*extra->offset[3]);
         lon    =  (vec_lon    + i*extra->offset[4]);
         lat    =  (vec_lat    + i*extra->offset[5]);

         sphlat_c(r, colat, slon, radius, lon, lat);
         CHECK_CALL_FAILURE(i);
         }
      }
   else
      {

      sphlat_c(r, colat, slon, radius, lon, lat);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void sphrec_c( SpiceDouble     r,
                   SpiceDouble    colat,
                   SpiceDouble    slon,
                   SpiceDouble    rectan[3] )
*/
void cspice_sphrec(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble    * vec_r;
   SpiceDouble    * vec_colat;
   SpiceDouble    * vec_slon;
   SpiceDouble    * vec_rectan;
   SpiceDouble      r;
   SpiceDouble      colat;
   SpiceDouble      slon;
   SpiceDouble    * rectan;

   mwIndex          i;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "r",      MiceDouble, 0, {0}, 1},
      { "colat",  MiceDouble, 0, {0}, 1},
      { "slon",   MiceDouble, 0, {0}, 1},
      { "rectan", MiceDouble, 1, {3}, 1},
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_r      = A_DBL_ARGV(1);
   vec_colat  = A_DBL_ARGV(2);
   vec_slon   = A_DBL_ARGV(3);
   vec_rectan = A_DBL_RET_ARGV(0);

   r          = *vec_r;
   colat      = *vec_colat;
   slon       = *vec_slon;
   rectan     =  vec_rectan;

   if (extra->count>1)
      {
      for (i=0;i<extra->count;i++)
         {
         r      = *(vec_r      + i*extra->offset[0]);
         colat  = *(vec_colat  + i*extra->offset[1]);
         slon   = *(vec_slon   + i*extra->offset[2]);
         rectan =  (vec_rectan + i*extra->offset[3]);

         sphrec_c(r, colat, slon, rectan);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {

      sphrec_c(r, colat, slon, rectan);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void spkapo_c ( SpiceInt               targ,
                   SpiceDouble            et,
                   ConstSpiceChar       * ref,
                   ConstSpiceDouble       sobs[6],
                   ConstSpiceChar       * abcorr,
                   SpiceDouble            ptarg[3],
                   SpiceDouble          * lt        )
*/
void mice_spkapo(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             targ;
   SpiceDouble          et;
   SpiceChar            ref    [DEFAULT_STR_LENGTH+1];
   SpiceDouble        * sobs;
   SpiceChar            abcorr [DEFAULT_STR_LENGTH+1];
   SpiceDouble          ptarg[3];
   SpiceDouble          lt;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "targ",   MiceInt,     0, {0}, 0},
      { "et",     MiceDouble,  0, {0}, 0},
      { "ref",    MiceChar,    0, {0}, 0},
      { "sobs",   MiceDouble,  1, {6}, 0},
      { "abcorr", MiceChar,    0, {0}, 0},
      { "ptarg",  MicePos,     0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 5, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   targ     = S_INT_ARGV(1);
   et       = S_DBL_ARGV(2);

   mxGetString(prhs[3], ref, DEFAULT_STR_LENGTH);

   sobs     = A_DBL_ARGV(4);

   mxGetString(prhs[5], abcorr, DEFAULT_STR_LENGTH);


   spkapo_c ( targ, et, ref, sobs, abcorr, ptarg, &lt );
   CHECK_CALL_FAILURE(SCALAR);

   /*
   Copy the position vector and the light time value into the return structure.
   */
   memcpy( mxGetPr( mxGetField(plhs[0],0,"pos") ),
           ptarg,
           3*sizeof(SpiceDouble));

   mxDestroyArray( mxGetField( plhs[0], 0, "lt" ) );
   mxSetField( plhs[0], 0, "lt", mxCreateDoubleScalar(lt) );

   }




/*
   void              spkcls_c ( SpiceInt            handle );
*/
void cspice_spkcls(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             handle;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle", MiceInt, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 1, 0);

   extra  = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle = S_INT_ARGV(1);

   spkcls_c( handle );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              spkcov_c ( ConstSpiceChar    * spk,
                                SpiceInt            idcode,
                                SpiceCell         * cover   );

*/
void cspice_spkcov(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {
   SpiceChar           spk[DEFAULT_STR_LENGTH+1];
   mxChar            * mx_spk;

   mwIndex             i;
   SpiceInt            j;
   mwSize              sizearray[2];

   SpiceInt            card = 0;
   SpiceInt            size;
   SpiceInt            idcode;
   SpiceDouble       * cover_f;
   SpiceDouble       * cover;

   struct extra_dims * extra;
   struct argcheck ArgCheck[] =
      {
      { "spkfnm", MiceChar,   0, {0}, 1},
      { "idcode", MiceInt,    0, {0}, 0},
      { "room",   MiceInt,    0, {0}, 0},
      { "cover",  MiceIgnore, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   idcode = S_INT_ARGV(2);

   /*
   'size' defines the number of intervals for the workspace window,
   so double the value of size since an interval consists of
   two double precision values.
   */
   size   = S_INT_ARGV(3) * 2;

   cover  = (SpiceDouble*)
            mxMalloc( (size + SPICE_CELL_CTRLSZ)*sizeof(SpiceDouble)  );

   ssized_( ( integer * ) &size, ( double * ) cover );
   scardd_( ( integer * ) &card, ( double * ) cover );

   if (extra->count>1)
      {

      mx_spk = (mxChar *)mxGetChars(prhs[1]);

      for ( i=0; i<extra->count; i++)
         {

         /*
         Extract the string data, character by character, into
         CSPICE strings. The mx_str array stores the data in a column
         major format, we need to extract the data by rows.
         */
         for ( j=0; j<extra->offset[0]; j++)
            {
            spk[j] = (char)mx_spk[i + (extra->count*j)];
            }

         spk[extra->offset[0]] = '\0';

         spkcov_( ( char       * ) spk,
                  ( integer    * ) &idcode,
                  ( doublereal * ) (cover),
                  ( ftnlen       ) strlen(spk)   );

         /*
         Check for a failure signal. Free the memory assigned to 'cover'
         before signaling a Matlab error.
         */
         if ( failed_c())
            {
            mxFree( cover );

            /*
            The mice_fail call creates the error string then returns control
            to the MATLAB interpreter.
            */
            mice_fail(i);
            }

         }

      }
   else
      {
      mxGetString(prhs[1], spk, DEFAULT_STR_LENGTH);

      spkcov_(  ( char       * ) spk,
                ( integer    * ) &idcode,
                ( doublereal * ) (cover),
                ( ftnlen       ) strlen(spk)   );

      /*
      Check for a failure signal. Free the memory assigned to 'cover'
      before signaling a Matlab error.
      */
      if ( failed_c())
         {
         mxFree( cover );

         /*
         The mice_fail call creates the error string then returns control
         to the MATLAB interpreter.
         */
         mice_fail(SCALAR);
         }

      }

   /*
   Array element 6, index 5, contains the cell cardinality. Create an output
   array CARDx1.
   */
   sizearray[0] = cover[5];
   sizearray[1] = 1;

   plhs[0] = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
   cover_f = A_DBL_RET_ARGV(0);

   /*
   Copy the data contents of 'cover' to 'cover_f'. The set of window data
   starts at 'cover' array index SPICE_CELL_CTRLSZ and contains 'cover[5]'
   elements.
   */
   MOVED( cover + SPICE_CELL_CTRLSZ, cover[5], cover_f );
   mxFree( cover );

   }




/*
   void              spkcpo_c ( ConstSpiceChar    * target,
                                SpiceDouble         et,
                                ConstSpiceChar    * outref,
                                ConstSpiceChar    * refloc,
                                ConstSpiceChar    * abcorr,
                                ConstSpiceDouble    obspos [3],
                                ConstSpiceChar    * obsctr,
                                ConstSpiceChar    * obsref,
                                SpiceDouble         state  [6],
                                SpiceDouble       * lt          );
*/
void mice_spkcpo(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar             target [DEFAULT_STR_LENGTH+1];
   SpiceDouble           et;
   SpiceChar             outref [DEFAULT_STR_LENGTH+1];
   SpiceChar             refloc [DEFAULT_STR_LENGTH+1];
   SpiceChar             abcorr [DEFAULT_STR_LENGTH+1];
   SpiceDouble         * obspos;
   SpiceChar             obsctr [DEFAULT_STR_LENGTH+1];
   SpiceChar             obsref [DEFAULT_STR_LENGTH+1];
   SpiceDouble           state [6];
   SpiceDouble           lt;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "target",   MiceChar,   0, { 0 },    0},
      { "et",       MiceDouble, 0, { 0 },    0},
      { "outref",   MiceChar,   0, { 0 },    0},
      { "refloc",   MiceChar,   0, { 0 },    0},
      { "abcorr",   MiceChar,   0, { 0 },    0},
      { "obspos",   MiceDouble, 1, { 3 },    0},
      { "obsctr",   MiceChar,   0, { 0 },    0},
      { "obsref",   MiceChar,   0, { 0 },    0},
      { "state",    MiceState,  0, { 0 },    0},
      };

   check_arg_num( nrhs, nlhs, 8, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], target, DEFAULT_STR_LENGTH);

   et     = S_DBL_ARGV(2);

   mxGetString(prhs[3], outref, DEFAULT_STR_LENGTH);
   mxGetString(prhs[4], refloc, DEFAULT_STR_LENGTH);
   mxGetString(prhs[5], abcorr, DEFAULT_STR_LENGTH);

   obspos = A_DBL_ARGV( 6 );

   mxGetString(prhs[7], obsctr, DEFAULT_STR_LENGTH);
   mxGetString(prhs[8], obsref, DEFAULT_STR_LENGTH);

   (void) spkcpo_c ( target,
                     et,
                     outref,
                     refloc,
                     abcorr,
                     obspos,
                     obsctr,
                     obsref,
                     state,
                     &lt );
   CHECK_CALL_FAILURE(SCALAR);

   /*
   Copy the state vector and the light time value into the return structure.
   */
   memcpy( mxGetPr( mxGetField(plhs[0],0,"state") ),
           state,
           6*sizeof(SpiceDouble));

   mxDestroyArray( mxGetField( plhs[0], 0, "lt" ) );
   mxSetField( plhs[0], 0, "lt", mxCreateDoubleScalar(lt) );

   }




/*
   void              spkcpt_c ( ConstSpiceDouble       trgpos [3],
                                ConstSpiceChar       * trgctr,
                                ConstSpiceChar       * trgref,
                                SpiceDouble            et,
                                ConstSpiceChar       * outref,
                                ConstSpiceChar       * refloc,
                                ConstSpiceChar       * abcorr,
                                ConstSpiceChar       * obsrvr,
                                SpiceDouble          * state,
                                SpiceDouble          * lt        )
*/
void mice_spkcpt(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble         * trgpos;
   SpiceChar             trgctr [DEFAULT_STR_LENGTH+1];
   SpiceChar             trgref [DEFAULT_STR_LENGTH+1];
   SpiceDouble           et;
   SpiceChar             outref [DEFAULT_STR_LENGTH+1];
   SpiceChar             refloc [DEFAULT_STR_LENGTH+1];
   SpiceChar             abcorr [DEFAULT_STR_LENGTH+1];
   SpiceChar             obsrvr [DEFAULT_STR_LENGTH+1];
   SpiceDouble           state [6];
   SpiceDouble           lt;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "trgpos",   MiceDouble, 1, { 3 },    0},
      { "trgctr",   MiceChar,   0, { 0 },    0},
      { "trgref",   MiceChar,   0, { 0 },    0},
      { "et",       MiceDouble, 0, { 0 },    0},
      { "outref",   MiceChar,   0, { 0 },    0},
      { "refloc",   MiceChar,   0, { 0 },    0},
      { "abcorr",   MiceChar,   0, { 0 },    0},
      { "obsrvr",   MiceChar,   0, { 0 },    0},
      { "state",    MiceState,  0, { 0 },    0},
      };

   check_arg_num( nrhs, nlhs, 8, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   trgpos = A_DBL_ARGV( 1 );

   mxGetString(prhs[2], trgctr, DEFAULT_STR_LENGTH);
   mxGetString(prhs[3], trgref, DEFAULT_STR_LENGTH);

   et     = S_DBL_ARGV(4);

   mxGetString(prhs[5], outref, DEFAULT_STR_LENGTH);
   mxGetString(prhs[6], refloc, DEFAULT_STR_LENGTH);
   mxGetString(prhs[7], abcorr, DEFAULT_STR_LENGTH);
   mxGetString(prhs[8], obsrvr, DEFAULT_STR_LENGTH);

   (void) spkcpt_c ( trgpos,
                     trgctr,
                     trgref,
                     et,
                     outref,
                     refloc,
                     abcorr,
                     obsrvr,
                     state,
                     &lt );
   CHECK_CALL_FAILURE(SCALAR);

   /*
   Copy the state vector and the lighttime value into the return structure.
   */
   memcpy( mxGetPr( mxGetField(plhs[0],0,"state") ),
           state,
           6*sizeof(SpiceDouble));

   mxDestroyArray( mxGetField( plhs[0], 0, "lt" ) );
   mxSetField( plhs[0], 0, "lt", mxCreateDoubleScalar(lt) );

   }




/*
   void              spkcvo_c ( ConstSpiceChar    * target,
                                SpiceDouble         et,
                                ConstSpiceChar    * outref,
                                ConstSpiceChar    * refloc,
                                ConstSpiceChar    * abcorr,
                                ConstSpiceDouble    obssta [6],
                                SpiceDouble         obsepc,
                                ConstSpiceChar    * obsctr,
                                ConstSpiceChar    * obsref,
                                SpiceDouble         state  [6],
                                SpiceDouble       * lt         );
*/
void mice_spkcvo(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar             target [DEFAULT_STR_LENGTH+1];
   SpiceDouble           et;
   SpiceChar             outref [DEFAULT_STR_LENGTH+1];
   SpiceChar             refloc [DEFAULT_STR_LENGTH+1];
   SpiceChar             abcorr [DEFAULT_STR_LENGTH+1];
   SpiceDouble         * obssta;
   SpiceDouble           obsepc;
   SpiceChar             obsctr [DEFAULT_STR_LENGTH+1];
   SpiceChar             obsref [DEFAULT_STR_LENGTH+1];
   SpiceDouble           state [6];
   SpiceDouble           lt;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "target",   MiceChar,   0, { 0 },    0},
      { "et",       MiceDouble, 0, { 0 },    0},
      { "outref",   MiceChar,   0, { 0 },    0},
      { "refloc",   MiceChar,   0, { 0 },    0},
      { "abcorr",   MiceChar,   0, { 0 },    0},
      { "obssta",   MiceDouble, 1, { 6 },    0},
      { "obsepc",   MiceDouble, 0, { 0 },    0},
      { "obsctr",   MiceChar,   0, { 0 },    0},
      { "obsref",   MiceChar,   0, { 0 },    0},
      { "state",    MiceState,  0, { 0 },    0},
      };

   check_arg_num( nrhs, nlhs, 9, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], target, DEFAULT_STR_LENGTH);

   et     = S_DBL_ARGV(2);

   mxGetString(prhs[3], outref, DEFAULT_STR_LENGTH);
   mxGetString(prhs[4], refloc, DEFAULT_STR_LENGTH);
   mxGetString(prhs[5], abcorr, DEFAULT_STR_LENGTH);

   obssta = A_DBL_ARGV(6);
   obsepc = S_DBL_ARGV(7);

   mxGetString(prhs[8], obsctr, DEFAULT_STR_LENGTH);
   mxGetString(prhs[9], obsref, DEFAULT_STR_LENGTH);

   (void) spkcvo_c ( target,
                     et,
                     outref,
                     refloc,
                     abcorr,
                     obssta,
                     obsepc,
                     obsctr,
                     obsref,
                     state,
                     &lt);
   CHECK_CALL_FAILURE(SCALAR);

   /*
   Copy the state vector and the lighttime value into the return structure.
   */
   memcpy( mxGetPr( mxGetField(plhs[0],0,"state") ),
           state,
           6*sizeof(SpiceDouble));

   mxDestroyArray( mxGetField( plhs[0], 0, "lt" ) );
   mxSetField( plhs[0], 0, "lt", mxCreateDoubleScalar(lt) );

   }




/*
   void              spkcvt_c ( ConstSpiceDouble       trgsta [6],
                                SpiceDouble            trgepc,
                                ConstSpiceChar       * trgctr,
                                ConstSpiceChar       * trgref,
                                SpiceDouble            et,
                                ConstSpiceChar       * outref,
                                ConstSpiceChar       * refloc,
                                ConstSpiceChar       * abcorr,
                                ConstSpiceChar       * obsrvr,
                                SpiceDouble          * state,
                                SpiceDouble          * lt        )
*/
void mice_spkcvt(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble         * trgsta;
   SpiceDouble           trgepc;
   SpiceChar             trgctr [DEFAULT_STR_LENGTH+1];
   SpiceChar             trgref [DEFAULT_STR_LENGTH+1];
   SpiceDouble           et;
   SpiceChar             outref [DEFAULT_STR_LENGTH+1];
   SpiceChar             refloc [DEFAULT_STR_LENGTH+1];
   SpiceChar             abcorr [DEFAULT_STR_LENGTH+1];
   SpiceChar             obsrvr [DEFAULT_STR_LENGTH+1];
   SpiceDouble           state [6];
   SpiceDouble           lt;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "trgsta",   MiceDouble, 1, { 6 },    0},
      { "trgepc",   MiceDouble, 0, { 0 },    0},
      { "trgctr",   MiceChar,   0, { 0 },    0},
      { "trgref",   MiceChar,   0, { 0 },    0},
      { "et",       MiceDouble, 0, { 0 },    0},
      { "outref",   MiceChar,   0, { 0 },    0},
      { "refloc",   MiceChar,   0, { 0 },    0},
      { "abcorr",   MiceChar,   0, { 0 },    0},
      { "obsrvr",   MiceChar,   0, { 0 },    0},
      { "state",    MiceState,  0, { 0 },    0},
      };

   check_arg_num( nrhs, nlhs, 9, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   trgsta = A_DBL_ARGV(1);
   trgepc = S_DBL_ARGV(2);

   mxGetString(prhs[3], trgctr, DEFAULT_STR_LENGTH);
   mxGetString(prhs[4], trgref, DEFAULT_STR_LENGTH);

   et     = S_DBL_ARGV(5);

   mxGetString(prhs[6], outref, DEFAULT_STR_LENGTH);
   mxGetString(prhs[7], refloc, DEFAULT_STR_LENGTH);
   mxGetString(prhs[8], abcorr, DEFAULT_STR_LENGTH);
   mxGetString(prhs[9], obsrvr, DEFAULT_STR_LENGTH);

   (void) spkcvt_c ( trgsta,
                     trgepc,
                     trgctr,
                     trgref,
                     et,
                     outref,
                     refloc,
                     abcorr,
                     obsrvr,
                     state,
                     &lt  );
   CHECK_CALL_FAILURE(SCALAR);

   /*
   Copy the state vector and the lighttime value into the return structure.
   */
   memcpy( mxGetPr( mxGetField(plhs[0],0,"state") ),
           state,
           6*sizeof(SpiceDouble));

   mxDestroyArray( mxGetField( plhs[0], 0, "lt" ) );
   mxSetField( plhs[0], 0, "lt", mxCreateDoubleScalar(lt) );

   }




/*
   void spkez_c ( SpiceInt            targ,
                  SpiceDouble         et,
                  ConstSpiceChar     *ref,
                  ConstSpiceChar     *abcorr,
                  SpiceInt            obs,
                  SpiceDouble         starg[6],
                  SpiceDouble        *lt        )
*/
void mice_spkez(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             targ;
   SpiceDouble          et;
   SpiceChar            ref    [DEFAULT_STR_LENGTH+1];
   SpiceChar            abcorr [DEFAULT_STR_LENGTH+1];
   SpiceInt             obs;
   SpiceDouble          starg[6];
   SpiceDouble          lt;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "targ",    MiceInt,      0, {0},   0},
      { "et",      MiceDouble,   0, {0},   0},
      { "ref",     MiceChar,     0, {0},   0},
      { "abcorr",  MiceChar,     0, {0},   0},
      { "obs",     MiceInt,      0, {0},   0},
      { "starg",   MiceState,    0, {0},   1},
      };

   check_arg_num( nrhs, nlhs, 5, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   targ     = S_INT_ARGV(1);
   et       = S_DBL_ARGV(2);

   mxGetString(prhs[3], ref, DEFAULT_STR_LENGTH);
   mxGetString(prhs[4], abcorr, DEFAULT_STR_LENGTH);

   obs      = S_INT_ARGV(5);


   spkez_c ( targ, et, ref, abcorr, obs, starg, &lt );
   CHECK_CALL_FAILURE(SCALAR);

   /*
   Copy the state vector and the light time value into the return structure.
   */
   memcpy( mxGetPr( mxGetField(plhs[0],0,"state") ),
           starg,
           6*sizeof(SpiceDouble));

   mxDestroyArray( mxGetField( plhs[0], 0, "lt" ) );
   mxSetField( plhs[0], 0, "lt", mxCreateDoubleScalar(lt) );

   }




/*
   void spkezr_c(  ConstSpiceChar     *targ,
                   SpiceDouble         et,
                   ConstSpiceChar     *ref,
                   ConstSpiceChar     *abcorr,
                   ConstSpiceChar     *obs,
                   SpiceDouble         starg[6],
                   SpiceDouble        *lt        )
*/
void mice_spkezr(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_et;
   SpiceChar            targ  [DEFAULT_STR_LENGTH+1];
   SpiceChar            ref   [DEFAULT_STR_LENGTH+1];
   SpiceChar            abcorr[DEFAULT_STR_LENGTH+1];
   SpiceChar            obs   [DEFAULT_STR_LENGTH+1];
   SpiceDouble          et;
   SpiceDouble          starg[6];
   SpiceDouble          lt;

   mwIndex              i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "targ",   MiceChar,   0, {0}, 0},
      { "et",     MiceDouble, 0, {0}, 1},
      { "ref",    MiceChar,   0, {0}, 0},
      { "abcorr", MiceChar,   0, {0}, 0},
      { "obs",    MiceChar,   0, {0}, 0},
      { "starg",  MiceState,  0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 5, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], targ, DEFAULT_STR_LENGTH);

   vec_et = A_DBL_ARGV(2);
   et     = *(vec_et);

   mxGetString(prhs[3], ref,    DEFAULT_STR_LENGTH);
   mxGetString(prhs[4], abcorr, DEFAULT_STR_LENGTH);
   mxGetString(prhs[5], obs,    DEFAULT_STR_LENGTH);

   /*
   Check for vectorized arguments.
   */
   if (extra->count>1)
      {

      /*
      Something input as a N-vector, extract the input values
      (vectorized or not) then execute the routine for each
      set of inputs.
      */
      for (i=0;i<extra->count;i++)
         {

         et = *(vec_et + i*extra->offset[1]);

         spkezr_c(targ, et, ref, abcorr, obs, starg, &lt);
         CHECK_CALL_FAILURE(i);

         /*
         Copy the state and light time values into the ith structure
         element.
         */
         memcpy( mxGetPr( mxGetField(plhs[0],i, "state") ),
                 starg,
                 6*sizeof(SpiceDouble));

         mxDestroyArray( mxGetField( plhs[0], i, "lt" ) );
         mxSetField( plhs[0], i, "lt", mxCreateDoubleScalar(lt) );

         }

      }
   else
      {

      spkezr_c(targ, et, ref, abcorr, obs, starg, &lt);
      CHECK_CALL_FAILURE(SCALAR);

      /*
      Copy the state vector and the lighttime value into the return structure.
      */
      memcpy( mxGetPr( mxGetField(plhs[0],0, "state") ),
              starg,
              6*sizeof(SpiceDouble));

      mxDestroyArray( mxGetField( plhs[0], 0, "lt" ) );
      mxSetField( plhs[0], 0, "lt", mxCreateDoubleScalar(lt) );

      }

   }




/*
   void spkgeo_c ( SpiceInt          targ,
                   SpiceDouble       et,
                   ConstSpiceChar  * ref,
                   SpiceInt          obs,
                   SpiceDouble       state[6],
                   SpiceDouble     * lt       )
*/
void mice_spkgeo(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             targ;
   SpiceDouble          et;
   SpiceChar            ref    [DEFAULT_STR_LENGTH+1];
   SpiceInt             obs;
   SpiceDouble          state[6];
   SpiceDouble          lt;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "targ",  MiceInt,     0, {0}, 0},
      { "et",    MiceDouble,  0, {0}, 0},
      { "ref",   MiceChar,    0, {0}, 0},
      { "obs",   MiceInt,     0, {0}, 0},
      { "state", MiceState,   0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 4, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   targ     = S_INT_ARGV(1);
   et       = S_DBL_ARGV(2);

   mxGetString(prhs[3], ref, DEFAULT_STR_LENGTH);

   obs      = S_INT_ARGV(4);


   spkgeo_c ( targ, et, ref, obs, state, &lt );
   CHECK_CALL_FAILURE(SCALAR);

   /*
   Copy the state vector and the light time value into the return structure.
   */
   memcpy( mxGetPr( mxGetField(plhs[0],0,"state") ),
           state,
           6*sizeof(SpiceDouble));

   mxDestroyArray( mxGetField( plhs[0], 0, "lt" ) );
   mxSetField( plhs[0], 0, "lt", mxCreateDoubleScalar(lt) );

   }




/*
   void spklef_c ( ConstSpiceChar * fname,
                   SpiceInt       * handle )
*/
void cspice_spklef(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            fname  [DEFAULT_STR_LENGTH+1];
   SpiceInt           * handle;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "fname",   MiceChar,  0, {0},   0},
      { "handle",  MiceInt,   0, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 1, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], fname, DEFAULT_STR_LENGTH);

   handle   = A_INT_RET_ARGV(0);

   spklef_c ( fname, handle );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              spkobj_c ( ConstSpiceChar    * spk,
                                SpiceCell         * ids );

*/
void cspice_spkobj(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {
   SpiceChar           spk[DEFAULT_STR_LENGTH+1];
   mxChar            * mx_spk;

   mwIndex             i;
   SpiceInt            j;
   mwSize              sizearray[2];

   SpiceInt            card = 0;
   SpiceInt            size;
   SpiceInt          * ids_f;
   SpiceInt          * ids;

   struct extra_dims * extra;
   struct argcheck ArgCheck[] =
      {
      { "spkfnm", MiceChar,   0, {0}, 1},
      { "room",   MiceInt,    0, {0}, 0},
      { "ids",    MiceIgnore, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   size = S_INT_ARGV(2);
   ids  = (SpiceInt*)mxMalloc( (size + SPICE_CELL_CTRLSZ)*sizeof(SpiceInt)  );

   ssizei_( ( integer * ) &size, ( integer * ) ids   );
   scardi_( ( integer * ) &card, ( integer * ) ids   );

   if (extra->count>1)
      {

      mx_spk = (mxChar *)mxGetChars(prhs[1]);

      for ( i=0; i<extra->count; i++)
         {

         /*
         Extract the string data, character by character, into
         CSPICE strings. The mx_str array stores the data in a column
         major format, we need to extract the data by rows.
         */
         for ( j=0; j<extra->offset[0]; j++)
            {
            spk[j] = (char)mx_spk[i + (extra->count*j)];
            }

         spk[extra->offset[0]] = '\0';

         spkobj_(  ( char       * ) spk,
                   ( integer    * ) (ids),
                   ( ftnlen       ) strlen(spk)   );

         /*
         Check for a failure signal. Free the memory assigned to 'ids'
         before signaling a Matlab error.
         */
         if ( failed_c())
            {
            mxFree( ids );

            /*
            The mice_fail call creates the error string then returns control
            to the MATLAB interpreter.
            */
            mice_fail(i);
            }

         }

      }
   else
      {
      mxGetString(prhs[1], spk, DEFAULT_STR_LENGTH);

      spkobj_(  ( char       * ) spk,
                ( integer    * ) (ids),
                ( ftnlen       ) strlen(spk)   );

      /*
      Check for a failure signal. Free the memory assigned to 'ids'
      before signaling a Matlab error.
      */
      if ( failed_c())
         {
         mxFree( ids );

         /*
         The mice_fail call creates the error string then returns control
         to the MATLAB interpreter.
         */
         mice_fail(SCALAR);
         }

      }

   /*
   Array element 6, index 5, contains the cell cardinality. Create an output
   array CARDx1.
   */
   sizearray[0] = ids[5];
   sizearray[1] = 1;

   plhs[0] = mxCreateNumericArray( 2, sizearray, mxINT32_CLASS, mxREAL);
   ids_f   = A_INT_RET_ARGV(0);

   MOVEI( ids + SPICE_CELL_CTRLSZ, ids[5], ids_f );
   mxFree( ids );

   }




/*
   void              spkopn_c ( ConstSpiceChar    * name,
                                ConstSpiceChar    * ifname,
                                SpiceInt            ncomch,
                                SpiceInt          * handle  );
*/
void cspice_spkopn(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            fname [DEFAULT_STR_LENGTH+1];
   SpiceChar            ifname[DEFAULT_STR_LENGTH+1];
   SpiceInt             ncomch;
   SpiceInt           * handle;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "fname",  MiceChar, 0, {0}, 0},
      { "ifname", MiceChar, 0, {0}, 0},
      { "ncomch", MiceInt,  0, {0}, 0},
      { "handle", MiceInt,  0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 3, 1);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], fname,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], ifname, DEFAULT_STR_LENGTH);

   ncomch = S_INT_ARGV(3);
   handle = A_INT_RET_ARGV(0);

   spkopn_c( fname, ifname, ncomch, handle );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              spkpos_c ( ConstSpiceChar    * targ,
                                SpiceDouble         et,
                                ConstSpiceChar    * ref,
                                ConstSpiceChar    * abcorr,
                                ConstSpiceChar    * obs,
                                SpiceDouble         ptarg[3],
                                SpiceDouble       * lt        );
*/
void mice_spkpos(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_et;
   SpiceChar            targ  [DEFAULT_STR_LENGTH+1];
   SpiceChar            ref   [DEFAULT_STR_LENGTH+1];
   SpiceChar            abcorr[DEFAULT_STR_LENGTH+1];
   SpiceChar            obs   [DEFAULT_STR_LENGTH+1];
   SpiceDouble          et;
   SpiceDouble          ptarg[3];
   SpiceDouble          lt;

   mwIndex              i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "targ",   MiceChar,   0, {0}, 0},
      { "et",     MiceDouble, 0, {0}, 1},
      { "ref",    MiceChar,   0, {0}, 0},
      { "abcorr", MiceChar,   0, {0}, 0},
      { "obs",    MiceChar,   0, {0}, 0},
      { "ptarg",  MicePos,    0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 5, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], targ, DEFAULT_STR_LENGTH);

   vec_et = A_DBL_ARGV(2);
   et     = *(vec_et);

   mxGetString(prhs[3], ref,    DEFAULT_STR_LENGTH);
   mxGetString(prhs[4], abcorr, DEFAULT_STR_LENGTH);
   mxGetString(prhs[5], obs,    DEFAULT_STR_LENGTH);

   /*
   Check for vectorized arguments.
   */
   if (extra->count>1)
      {

      /*
      Something input as a N-vector, extract the input values
      (vectorized or not) then execute the routine for each
      set of inputs.
      */
      for (i=0;i<extra->count;i++)
         {

         et    = *(vec_et + i*extra->offset[1]);

         /*
         Call the routine for this iteration.
         */
         spkpos_c(targ, et, ref, abcorr, obs, ptarg, &lt);
         CHECK_CALL_FAILURE(i);

         /*
         Copy the position and light time values into the ith structure
         element.
         */
         memcpy( mxGetPr( mxGetField(plhs[0],i,"pos") ),
                 ptarg,
                 3*sizeof(SpiceDouble));

         mxDestroyArray( mxGetField( plhs[0], i, "lt" ) );
         mxSetField( plhs[0], i, "lt", mxCreateDoubleScalar(lt) );

         }

      }
   else
      {

      spkpos_c(targ, et, ref, abcorr, obs, ptarg, &lt);
      CHECK_CALL_FAILURE(SCALAR);

      /*
      Copy the position and the light time value into the return structure.
      */
      memcpy( mxGetPr( mxGetField(plhs[0],0, "pos") ),
              ptarg,
              3*sizeof(SpiceDouble));

      mxDestroyArray( mxGetField( plhs[0], 0, "lt" ) );
      mxSetField( plhs[0], 0, "lt", mxCreateDoubleScalar(lt) );

      }

   }




/*
   void              spkpvn_c ( SpiceInt            handle,
                                ConstSpiceDouble    descr [5],
                                SpiceDouble         et,
                                SpiceInt          * ref,
                                SpiceDouble         state [6],
                                SpiceInt          * center    );
*/
void mice_spkpvn(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt               handle;
   SpiceDouble          * descr;
   SpiceDouble            et;
   SpiceInt               ref;
   SpiceDouble            state  [6];
   SpiceInt               center;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle", MiceInt,    0, {0}, 0},
      { "descr",  MiceDouble, 1, {5}, 0},
      { "et",     MiceDouble, 0, {0}, 0},
      { "spkpvn", MicePVN,    0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle = S_INT_ARGV(1);
   descr  = A_DBL_ARGV(2);
   et     = S_DBL_ARGV(3);

   (void) spkpvn_c ( handle,
                     descr,
                     et,
                     &ref,
                     state,
                     &center );
   CHECK_CALL_FAILURE(SCALAR);

   mxDestroyArray( mxGetField( plhs[0], 0, "ref" ) );
   mxSetField( plhs[0], 0, "ref", zzmice_CreateIntScalar(ref) );

   memcpy( mxGetPr( mxGetField(plhs[0],0,"state" ) ),
           state,
           6*sizeof(SpiceDouble));

   mxDestroyArray( mxGetField( plhs[0], 0, "center" ) );
   mxSetField( plhs[0], 0, "center", zzmice_CreateIntScalar(center) );

   }




/*
   void              spksfs_c ( SpiceInt            body,
                                SpiceDouble         et,
                                SpiceInt            idlen,
                                SpiceInt          * handle,
                                SpiceDouble         descr [5],
                                SpiceChar         * ident,
                                SpiceBoolean      * found  );
*/
void mice_spksfs(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt              body;
   SpiceDouble           et;
   SpiceInt              idlen;
   SpiceInt              handle;
   SpiceDouble           descr [5];
   SpiceChar             ident [SIDLEN+1];
   SpiceBoolean          found;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "body",   MiceInt,    0, { 0 },    0},
      { "et",     MiceDouble, 0, { 0 },    0},
      { "spksfs", MiceSFS,    0, { 0 },    0},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   body   = S_INT_ARGV(1);
   et     = S_DBL_ARGV(2);

   idlen  = SIDLEN;

   (void) spksfs_c ( body,
                     et,
                     idlen,
                     &handle,
                     descr,
                     ident,
                     &found  );

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   /*
   Copy the output values into the return structure.
   */
   mxDestroyArray( mxGetField( plhs[0], 0, "handle" ) );
   mxSetField( plhs[0], 0, "handle", zzmice_CreateIntScalar(handle) );

   memcpy( mxGetPr( mxGetField(plhs[0],0,"descr") ),
           descr,
           5*sizeof(SpiceDouble));

   mxDestroyArray( mxGetField( plhs[0], 0, "ident" ) );
   mxSetField( plhs[0], 0, "ident", mxCreateString(ident) );

   mxDestroyArray( mxGetField( plhs[0], 0, "found" ) );
   mxSetField( plhs[0], 0, "found",
               mxCreateLogicalScalar(found ? true: false));

   }




/*
   void spkssb_c ( SpiceInt           targ,
                   SpiceDouble        et,
                   ConstSpiceChar   * ref,
                   SpiceDouble        starg[6] )
*/
void cspice_spkssb(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             targ;
   SpiceDouble          et;
   SpiceChar            ref    [DEFAULT_STR_LENGTH+1];
   SpiceDouble        * starg;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "targ",  MiceInt,     0, {0}, 0},
      { "et",    MiceDouble,  0, {0}, 0},
      { "ref",   MiceChar,    0, {0}, 0},
      { "starg", MiceDouble,  1, {6}, 0},
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   targ     = S_INT_ARGV(1);
   et       = S_DBL_ARGV(2);

   mxGetString(prhs[3], ref, DEFAULT_STR_LENGTH);

   starg    = A_DBL_RET_ARGV(0);

   spkssb_c ( targ, et, ref, starg );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void spkuef_c ( SpiceInt handle )
*/
void cspice_spkuef(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             handle;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle",  MiceInt,      0, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 1, 0 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle   = S_INT_ARGV(1);


   spkuef_c ( handle );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              spkw08_c ( SpiceInt             handle,
                                SpiceInt             body,
                                SpiceInt             center,
                                ConstSpiceChar     * frame,
                                SpiceDouble          first,
                                SpiceDouble          last,
                                ConstSpiceChar     * segid,
                                SpiceInt             degree,
                                SpiceInt             n,
                                ConstSpiceDouble     states[][6],
                                SpiceDouble          begtim,
                                SpiceDouble          step         );
*/
void cspice_spkw08(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             handle;
   SpiceInt             body;
   SpiceInt             center;
   SpiceChar            frame   [DEFAULT_STR_LENGTH+1];
   SpiceDouble          first;
   SpiceDouble          last;
   SpiceChar            segid   [DEFAULT_STR_LENGTH+1];
   SpiceInt             degree;
   SpiceInt             n;
   ConstSpiceDouble   * states;
   SpiceDouble          begtim;
   SpiceDouble          step;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle",  MiceInt,    0, { 0 },    0},
      { "body",    MiceInt,    0, { 0 },    0},
      { "center",  MiceInt,    0, { 0 },    0},
      { "frame",   MiceChar,   0, { 0 },    0},
      { "first",   MiceDouble, 0, { 0 },    0},
      { "last",    MiceDouble, 0, { 0 },    0},
      { "segid",   MiceChar,   0, { 0 },    0},
      { "degree",  MiceInt,    0, { 0 },    0},
      { "states",  MiceDouble, 2, { 6, 0 }, 0},
      { "begtim",  MiceDouble, 0, { 0 },    0},
      { "step",    MiceDouble, 0, { 0 },    0},
      };

   check_arg_num( nrhs, nlhs, 11, 0);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   /*
   Number of state sets = number of elements in array divided by six;
   we expect a 6xN array.
   */
   n = mxGetNumberOfElements( prhs[9]) / 6;

   handle  = S_INT_ARGV(1);
   body    = S_INT_ARGV(2);
   center  = S_INT_ARGV(3);

   mxGetString(prhs[4], frame, DEFAULT_STR_LENGTH);

   first   = S_DBL_ARGV(5);
   last    = S_DBL_ARGV(6);

   mxGetString(prhs[7], segid, DEFAULT_STR_LENGTH);

   degree  = S_INT_ARGV(8);

   states  = (ConstSpiceDouble*)mxGetData(prhs[9]);

   begtim  = S_DBL_ARGV(10);
   step    = S_DBL_ARGV(11);

   spkw08_c ( handle,
              body,
              center,
              frame,
              first,
              last,
              segid,
              degree,
              n,
              (Nx6d)states,
              begtim,
              step );

   CHECK_CALL_FAILURE( SCALAR );

   }




/*
   void spkw09_c ( SpiceInt             handle,
                   SpiceInt             body,
                   SpiceInt             center,
                   ConstSpiceChar     * frame,
                   SpiceDouble          first,
                   SpiceDouble          last,
                   ConstSpiceChar     * segid,
                   SpiceInt             degree,
                   SpiceInt             n,
                   ConstSpiceDouble     states[][6],
                   ConstSpiceDouble     epochs[]     )
*/
void cspice_spkw09(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             handle;
   SpiceInt             body;
   SpiceInt             center;
   SpiceChar            frame  [DEFAULT_STR_LENGTH+1];
   SpiceDouble          first;
   SpiceDouble          last;
   SpiceChar            segid  [DEFAULT_STR_LENGTH+1];
   SpiceInt             degree;
   SpiceInt             n;
   ConstSpiceDouble   * states;
   ConstSpiceDouble   * epochs;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle", MiceInt,     0, {0},   0},
      { "body",   MiceInt,     0, {0},   0},
      { "center", MiceInt,     0, {0},   0},
      { "frame",  MiceChar,    0, {0},   0},
      { "first",  MiceDouble,  0, {0},   0},
      { "last",   MiceDouble,  0, {0},   0},
      { "segid",  MiceChar,    0, {0},   0},
      { "degree", MiceInt,     0, {0},   0},
      { "states", MiceDouble,  2, {6,0}, 0},
      { "epochs", MiceDouble,  1, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 10, 0 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle   = S_INT_ARGV(1);
   body     = S_INT_ARGV(2);
   center   = S_INT_ARGV(3);

   mxGetString(prhs[4], frame, DEFAULT_STR_LENGTH);

   first    = S_DBL_ARGV(5);
   last     = S_DBL_ARGV(6);

   mxGetString(prhs[7], segid, DEFAULT_STR_LENGTH);

   degree   = S_INT_ARGV(8);

   n        = mxGetNumberOfElements(prhs[9]) / 6;
   states   = (ConstSpiceDouble*)mxGetData(prhs[9]);

   if( n !=  (SpiceInt)mxGetNumberOfElements( prhs[10] ) )
      {
      mexErrMsgTxt( "MICE(INVALIDSIZE): Array `epochs` must have the same "
                            "measure of vectorization as `states`" );
      }
   epochs   = (ConstSpiceDouble*)mxGetData(prhs[10]);


   spkw09_c ( handle, body, center, frame, first, last,
              segid, degree, n, (Nx6d)states, epochs );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void spkw10_c ( SpiceInt           handle,
                   SpiceInt           body,
                   SpiceInt           center,
                   ConstSpiceChar   * frame,
                   SpiceDouble        first,
                   SpiceDouble        last,
                   ConstSpiceChar   * segid,
                   ConstSpiceDouble   consts [8],
                   SpiceInt           n,
                   ConstSpiceDouble   elems  [],
                   ConstSpiceDouble   epochs []      )
*/
void cspice_spkw10(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             handle;
   SpiceInt             body;
   SpiceInt             center;
   SpiceChar            frame  [DEFAULT_STR_LENGTH+1];
   SpiceDouble          first;
   SpiceDouble          last;
   SpiceChar            segid  [DEFAULT_STR_LENGTH+1];
   SpiceDouble        * consts;
   SpiceInt             n;
   ConstSpiceDouble   * elems;
   ConstSpiceDouble   * epochs;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle",  MiceInt,      0, { 0 },    0},
      { "body",    MiceInt,      0, { 0 },    0},
      { "center",  MiceInt,      0, { 0 },    0},
      { "frame",   MiceChar,     0, { 0 },    0},
      { "first",   MiceDouble,   0, { 0 },    0},
      { "last",    MiceDouble,   0, { 0 },    0},
      { "segid",   MiceChar,     0, { 0 },    0},
      { "consts",  MiceDouble,   1, { 8 },    0},
      { "n"     ,  MiceInt   ,   0, { 0 },    0},
      { "elems",   MiceDouble,   1, { 0 },    0},
      { "epochs",  MiceDouble,   1, { 0 },    0},
      };

   check_arg_num( nrhs, nlhs, 11, 0 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle   = S_INT_ARGV(1);
   body     = S_INT_ARGV(2);
   center   = S_INT_ARGV(3);

   mxGetString(prhs[4], frame, DEFAULT_STR_LENGTH);

   first    = S_DBL_ARGV(5);
   last     = S_DBL_ARGV(6);

   mxGetString(prhs[7], segid, DEFAULT_STR_LENGTH);

   consts   = A_DBL_ARGV(8);

   n        = S_INT_ARGV(9);

   if( 10*n !=  (SpiceInt)mxGetNumberOfElements( prhs[10] ) )
      {
      mexErrMsgTxt( "MICE(INVALIDSIZE): Array `elems`  must have "
                    "measure `10*n'" );
      }
   elems    = (ConstSpiceDouble*)mxGetData(prhs[10]);

   if( n !=  (SpiceInt)mxGetNumberOfElements( prhs[11] ) )
      {
      mexErrMsgTxt( "MICE(INVALIDSIZE): Array `epochs`  must have "
                    "measure `n'" );
      }
   epochs   = (ConstSpiceDouble*)mxGetData(prhs[11]);


   spkw10_c ( handle, body,   center, frame, first,  last,
              segid,  consts, n,      elems, epochs );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void spkw13_c ( SpiceInt             handle,
                   SpiceInt             body,
                   SpiceInt             center,
                   ConstSpiceChar     * frame,
                   SpiceDouble          first,
                   SpiceDouble          last,
                   ConstSpiceChar     * segid,
                   SpiceInt             degree,
                   SpiceInt             n,
                   ConstSpiceDouble     states[][6],
                   ConstSpiceDouble     epochs[]     )
*/
void cspice_spkw13(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             handle;
   SpiceInt             body;
   SpiceInt             center;
   SpiceChar            frame  [DEFAULT_STR_LENGTH+1];
   SpiceDouble          first;
   SpiceDouble          last;
   SpiceChar            segid  [DEFAULT_STR_LENGTH+1];
   SpiceInt             degree;
   SpiceInt             n;
   ConstSpiceDouble   * states;
   ConstSpiceDouble   * epochs;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle",  MiceInt,      0, {0},   0},
      { "body",    MiceInt,      0, {0},   0},
      { "center",  MiceInt,      0, {0},   0},
      { "frame",   MiceChar,     0, {0},   0},
      { "first",   MiceDouble,   0, {0},   0},
      { "last",    MiceDouble,   0, {0},   0},
      { "segid",   MiceChar,     0, {0},   0},
      { "degree",  MiceInt,      0, {0},   0},
      { "states",  MiceDouble,   2, {6,0}, 0},
      { "epochs",  MiceDouble,   1, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 10, 0 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle   = S_INT_ARGV(1);
   body     = S_INT_ARGV(2);
   center   = S_INT_ARGV(3);

   mxGetString(prhs[4], frame, DEFAULT_STR_LENGTH);

   first    = S_DBL_ARGV(5);
   last     = S_DBL_ARGV(6);

   mxGetString(prhs[7], segid, DEFAULT_STR_LENGTH);

   degree   = S_INT_ARGV(8);

   n        = mxGetNumberOfElements(prhs[9]) / 6;
   states   = (ConstSpiceDouble*)mxGetData(prhs[9]);

   if( n !=  (SpiceInt)mxGetNumberOfElements( prhs[10] ) )
      {
      mexErrMsgTxt( "MICE(INVALIDSIZE): Array `epochs` must have the same "
                             "measure of vectorization as `states`" );
      }
   epochs   = (ConstSpiceDouble*)mxGetData(prhs[10]);


   spkw13_c ( handle, body, center, frame, first, last,
              segid, degree, n, (Nx6d)states, epochs );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              srfc2s_c ( SpiceInt        code,
                                SpiceInt        bodyid,
                                SpiceInt        srflen,
                                SpiceChar     * srfstr,
                                SpiceBoolean  * isname )
*/
void mice_srfc2s(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             code;
   SpiceInt             bodyid;
   SpiceChar            srfstr [DEFAULT_STR_LENGTH+1];
   SpiceBoolean         isname;


   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "code",   MiceInt,    0, {0}, 0},
      { "bodyid", MiceInt,    0, {0}, 0},
      { "srfc2s", MiceNameID, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   memset( srfstr, 0, default_str_size );

   extra    = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   code     = S_INT_ARGV(1);
   bodyid   = S_INT_ARGV(2);

   srfc2s_c ( code, bodyid, DEFAULT_STR_LENGTH, srfstr, &isname );
   CHECK_CALL_FAILURE(SCALAR);

   mxDestroyArray( mxGetField( plhs[0], 0, "name" ) );
   mxSetField(plhs[0], 0, "name", mxCreateString(srfstr)   );

   mxDestroyArray( mxGetField( plhs[0], 0, "code" ) );
   mxSetField( plhs[0], 0,"code", zzmice_CreateIntScalar(0)  );

   mxDestroyArray( mxGetField( plhs[0], 0, "found" ) );
   mxSetField( plhs[0], 0, "found",
                  mxCreateLogicalScalar(isname ? true: false));

   }




/*
   void              srfcss_c ( SpiceInt             code,
                                ConstSpiceChar     * bodstr,
                                SpiceInt             srflen,
                                SpiceChar          * srfstr,
                                SpiceBoolean       * isname  );
*/
void mice_srfcss(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             code;
   SpiceChar            bodstr [DEFAULT_STR_LENGTH+1];
   SpiceChar            srfstr [DEFAULT_STR_LENGTH+1];
   SpiceBoolean         isname;


   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "code",   MiceInt,    0, {0}, 0},
      { "bodstr", MiceChar,   0, {0}, 0},
      { "srfcss", MiceNameID, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   memset( srfstr, 0, default_str_size );

   extra    = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   code     = S_INT_ARGV(1);
   mxGetString(prhs[2], bodstr, DEFAULT_STR_LENGTH);

   srfcss_c ( code, bodstr, DEFAULT_STR_LENGTH, srfstr, &isname );

   CHECK_CALL_FAILURE(SCALAR);

   mxDestroyArray( mxGetField( plhs[0], 0, "name" ) );
   mxSetField(plhs[0], 0, "name", mxCreateString(srfstr)   );


   mxDestroyArray( mxGetField( plhs[0], 0, "code" ) );
   mxSetField( plhs[0], 0,"code", zzmice_CreateIntScalar(0)  );

   mxDestroyArray( mxGetField( plhs[0], 0, "found" ) );
   mxSetField( plhs[0], 0, "found",
                  mxCreateLogicalScalar(isname ? true: false));

   }




/*
   void              srfnrm_c ( ConstSpiceChar     * method,
                                ConstSpiceChar     * target,
                                SpiceDouble          et,
                                ConstSpiceChar     * fixref,
                                SpiceInt             npts,
                                ConstSpiceDouble     srfpts[][3],
                                SpiceDouble          normls[][3]  );
*/
void cspice_srfnrm(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            method [DEFAULT_STR_LENGTH+1];
   SpiceChar            target [DEFAULT_STR_LENGTH+1];
   SpiceDouble          et;
   SpiceChar            fixref [DEFAULT_STR_LENGTH+1];
   SpiceInt             npts;
   ConstSpiceDouble   * srfpts;
   SpiceDouble       (* normls)[3] = 0;

   SpiceDouble        * dvals_ret;

   mwSize               sizearray[2];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "method", MiceChar,   0, {0},   0},
      { "target", MiceChar,   0, {0},   0},
      { "et",     MiceDouble, 0, {0},   0},
      { "fixref", MiceChar,   0, {0},   0},
      { "srfpts", MiceDouble, 2, {3,0}, 0},
      { "normls", MiceIgnore, 0, {0},   0}
      };

   check_arg_num( nrhs, nlhs, 5, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], method, DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], target, DEFAULT_STR_LENGTH);
   mxGetString(prhs[4], fixref, DEFAULT_STR_LENGTH);

   et      = S_DBL_ARGV(3);

   srfpts  = (ConstSpiceDouble   *)mxGetData(prhs[5]);

   npts    = mxGetNumberOfElements( prhs[5] )/3;

   if ( npts > 0 )
      {
      normls  = (SpiceDouble (*)[3] )mxMalloc(3 * npts * sizeof(SpiceDouble) );
      memset( normls,  0, 3 * npts * sizeof(SpiceDouble) );

      srfnrm_c ( method,
                 target,
                 et,
                 fixref,
                 npts,
                 (Nx3d)srfpts,
                 normls );

      if ( failed_c() )
         {
         mxFree( normls );
         /*
         The mice_fail call creates the error string then returns control
         to the MATLAB interpreter.
         */
         mice_fail(SCALAR);
         }

      sizearray[0] = 3;
      sizearray[1] = npts;
      }
   else
      {
      sizearray[0] = 0;
      sizearray[1] = 0;
      }

   plhs[0]   = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
   dvals_ret = A_DBL_RET_ARGV(0);

   if ( npts > 0 )
      {
      MOVED( (SpiceDouble *)normls, 3*npts, dvals_ret );

      /*
      We allocated space for `npt' normals; deallocate this space now.
      */
      mxFree( normls );
      }

   }




/*
   void              srfrec_c ( SpiceInt      body,
                                SpiceDouble   lon,
                                SpiceDouble   lat,
                                SpiceDouble   rectan[3] )
*/
void cspice_srfrec(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             body;
   SpiceDouble        * vec_lon;
   SpiceDouble        * vec_lat;
   SpiceDouble        * vec_rectan;
   SpiceDouble          lon;
   SpiceDouble          lat;
   SpiceDouble        * rectan;

   mwIndex              i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "body",   MiceInt,    0, {0}, 0},
      { "lon",    MiceDouble, 0, {0}, 1},
      { "lat",    MiceDouble, 0, {0}, 1},
      { "rectan", MiceDouble, 1, {3}, 1},
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra = mice_checkargs(nlhs, plhs, nrhs, prhs, ArgCheck);

   body       = S_INT_ARGV(1);
   vec_lon    = A_DBL_ARGV(2);
   vec_lat    = A_DBL_ARGV(3);
   vec_rectan = A_DBL_RET_ARGV(0);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         lon    = *(vec_lon    + i*extra->offset[1]);
         lat    = *(vec_lat    + i*extra->offset[2]);
         rectan =  (vec_rectan + i*extra->offset[3]);

         srfrec_c (body, lon, lat, rectan);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {
      lon    = *(vec_lon);
      lat    = *(vec_lat);
      rectan =  (vec_rectan);

      srfrec_c (body, lon, lat, rectan);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void              srfs2c_c ( ConstSpiceChar     * srfstr,
                                ConstSpiceChar     * bodstr,
                                SpiceInt           * code,
                                SpiceBoolean       * found  );
*/
void mice_srfs2c(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            srfstr[DEFAULT_STR_LENGTH+1];
   SpiceChar            bodstr[DEFAULT_STR_LENGTH+1];
   SpiceInt             code;
   SpiceBoolean         found;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "srfstr", MiceChar,   0, {0}, 1},
      { "bodstr", MiceChar,   0, {0}, 1},
      { "srfs2c", MiceNameID, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   memset( srfstr, 0, default_str_size );
   memset( bodstr, 0, default_str_size );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], srfstr, DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], bodstr, DEFAULT_STR_LENGTH);

   srfs2c_c ( srfstr, bodstr, &code, &found );
   CHECK_CALL_FAILURE(SCALAR);

   mxDestroyArray( mxGetField( plhs[0], 0, "name" ) );
   mxSetField(plhs[0], 0, "name", mxCreateString("\0")   );

   mxDestroyArray( mxGetField( plhs[0], 0, "code" ) );
   mxSetField( plhs[0], 0,"code", zzmice_CreateIntScalar(code));

   mxDestroyArray( mxGetField( plhs[0], 0, "found" ) );
   mxSetField( plhs[0], 0, "found",
                  mxCreateLogicalScalar(found ? true: false));

   }




/*
   void              srfscc_c ( ConstSpiceChar     * srfstr,
                                SpiceInt             bodyid,
                                SpiceInt           * surfid,
                                SpiceBoolean       * found  );
*/
void mice_srfscc(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            srfstr [DEFAULT_STR_LENGTH+1];
   SpiceInt             bodyid;
   SpiceInt             surfid;
   SpiceBoolean         found;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "srfstr", MiceChar,   0, {0}, 1},
      { "bodyid", MiceInt,    0, {0}, 1},
      { "srfscc", MiceNameID, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   memset( srfstr, 0, default_str_size );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], srfstr, DEFAULT_STR_LENGTH);
   bodyid     = S_INT_ARGV(2);

   srfscc_c ( srfstr, bodyid, &surfid, &found );
   CHECK_CALL_FAILURE(SCALAR);

   mxDestroyArray( mxGetField( plhs[0], 0, "name" ) );
   mxSetField( plhs[0], 0, "name", mxCreateString("\0")   );

   mxDestroyArray( mxGetField( plhs[0], 0, "code" ) );
   mxSetField( plhs[0], 0, "code", zzmice_CreateIntScalar(surfid));

   mxDestroyArray( mxGetField( plhs[0], 0, "found" ) );
   mxSetField( plhs[0], 0, "found",
                  mxCreateLogicalScalar(found ? true: false));

   }




/*
   void              srfxpt_c(  ConstSpiceChar    * method,
                                ConstSpiceChar    * target,
                                SpiceDouble         et,
                                ConstSpiceChar    * abcorr,
                                ConstSpiceChar    * obsrvr,
                                ConstSpiceChar    * dref,
                                ConstSpiceDouble    dvec   [3],
                                SpiceDouble         spoint [3],
                                SpiceDouble       * dist,
                                SpiceDouble       * trgepc,
                                SpiceDouble         obspos [3],
                                SpiceBoolean      * found         );
*/
void mice_srfxpt(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_et;
   SpiceChar            method[DEFAULT_STR_LENGTH+1];
   SpiceChar            target[DEFAULT_STR_LENGTH+1];
   SpiceChar            abcorr[DEFAULT_STR_LENGTH+1];
   SpiceChar            obsrvr[DEFAULT_STR_LENGTH+1];
   SpiceChar            dref  [DEFAULT_STR_LENGTH+1];
   SpiceDouble          et;
   SpiceDouble        * dvec;
   SpiceDouble          spoint[3];
   SpiceDouble          dist;
   SpiceDouble          trgepc;
   SpiceDouble          obspos[3];
   SpiceBoolean         found;

   mwIndex              i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "method", MiceChar,   0, {0}, 0},
      { "target", MiceChar,   0, {0}, 0},
      { "et",     MiceDouble, 0, {0}, 1},
      { "abcorr", MiceChar,   0, {0}, 0},
      { "obsrvr", MiceChar,   0, {0}, 0},
      { "dref",   MiceChar,   0, {0}, 0},
      { "dvec",   MiceDouble, 1, {3}, 0},
      { "surf",   MiceSurf,   0, {0}, 1}
      };

   check_arg_num( nrhs, nlhs, 7, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], method, DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], target, DEFAULT_STR_LENGTH);

   vec_et = A_DBL_ARGV(3);

   mxGetString(prhs[4], abcorr, DEFAULT_STR_LENGTH);
   mxGetString(prhs[5], obsrvr, DEFAULT_STR_LENGTH);
   mxGetString(prhs[6], dref,   DEFAULT_STR_LENGTH);

   dvec = A_DBL_ARGV(7);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         et = *(vec_et + i*extra->offset[2]);

         srfxpt_c( method, target,   et,
                   abcorr, obsrvr, dref,
                   dvec,   spoint, &dist,
                   &trgepc, obspos, &found );
         CHECK_CALL_FAILURE(i);

         memcpy( mxGetPr( mxGetField(plhs[0],i,"spoint" ) ),
                 spoint,
                 3*sizeof(SpiceDouble));

         memcpy( mxGetPr( mxGetField(plhs[0],i,"obspos" ) ),
                 obspos,
                 3*sizeof(SpiceDouble));

         mxDestroyArray( mxGetField( plhs[0], i, "dist" ) );
         mxSetField( plhs[0], i, "dist", mxCreateDoubleScalar(dist) );

         mxDestroyArray( mxGetField( plhs[0], i, "trgepc" ) );
         mxSetField( plhs[0], i, "trgepc", mxCreateDoubleScalar(trgepc) );

         mxDestroyArray( mxGetField( plhs[0], i, "found" ) );
         mxSetField( plhs[0], i, "found",
                     mxCreateLogicalScalar(found ? true: false));
         }

      }
   else
      {

      et = *vec_et;

      srfxpt_c( method, target,     et,
                abcorr, obsrvr,   dref,
                dvec,   spoint,  &dist,
                &trgepc, obspos, &found );
      CHECK_CALL_FAILURE(SCALAR);

      memcpy( mxGetPr( mxGetField(plhs[0],0,"spoint" ) ),
              spoint,
              3*sizeof(SpiceDouble));

      memcpy( mxGetPr( mxGetField(plhs[0],0,"obspos" ) ),
              obspos,
              3*sizeof(SpiceDouble));

      mxDestroyArray( mxGetField( plhs[0], 0, "dist" ) );
      mxSetField( plhs[0], 0, "dist", mxCreateDoubleScalar(dist) );

      mxDestroyArray( mxGetField( plhs[0], 0, "trgepc" ) );
      mxSetField( plhs[0], 0, "trgepc", mxCreateDoubleScalar(trgepc) );

      mxDestroyArray( mxGetField( plhs[0], 0, "found" ) );
      mxSetField( plhs[0], 0, "found",
                  mxCreateLogicalScalar(found ? true: false));
      }

   }





/*
   void stelab_c ( ConstSpiceDouble   pobj[3],
                   ConstSpiceDouble   vobs[3],
                   SpiceDouble        appobj[3] )
*/
void cspice_stelab(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * pobj;
   SpiceDouble        * vobs;
   SpiceDouble        * appobj;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "pobj",   MiceDouble,  1, {3}, 0},
      { "vobs",   MiceDouble,  1, {3}, 0},
      { "appobj", MiceDouble,  1, {3}, 0},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   pobj     = A_DBL_ARGV(1);
   vobs     = A_DBL_ARGV(2);

   appobj   = A_DBL_RET_ARGV(0);

   stelab_c ( pobj, vobs, appobj );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void stlabx_c ( ConstSpiceDouble    pobj   [3],
                   ConstSpiceDouble    vobs   [3],
                   SpiceDouble         corpos [3] )
*/
void cspice_stlabx(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * pobj;
   SpiceDouble        * vobs;
   SpiceDouble        * corpos;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "pobj",    MiceDouble,   1, {3},   0},
      { "vobs",    MiceDouble,   1, {3},   0},
      { "corpos",  MiceDouble,   1, {3},   0},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   pobj     = A_DBL_ARGV(1);
   vobs     = A_DBL_ARGV(2);

   corpos   = A_DBL_RET_ARGV(0);

   stlabx_c ( pobj, vobs, corpos );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              str2et_c( ConstSpiceChar * timstr,
                               SpiceDouble    * et     )
*/
void cspice_str2et(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            timstr [DEFAULT_STR_LENGTH+1];
   mxChar             * mx_str;
   SpiceDouble        * et;
   SpiceDouble        * vec_et;

   mwIndex              i;
   SpiceInt             j;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "timstr", MiceChar,   0, {0}, 1},
      { "et",     MiceDouble, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 1, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_et = A_DBL_RET_ARGV(0);

   if (extra->count>1)
      {

      mx_str = (mxChar *)mxGetChars(prhs[1]);

      for ( i=0; i<extra->count; i++)
         {

         /*
         Extract the string data, character by character, into
         CSPICE strings. The mx_str array stores the data in a column
         major format, we need to extract the data by rows.
         */
         for ( j=0; j<extra->offset[0]; j++)
            {
            timstr[j] = (char)mx_str[i + (extra->count*j)];
            }

         timstr[extra->offset[0]] = '\0';
         et                    = (vec_et+i*extra->offset[1]);

         str2et_c(timstr, et);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {

      mxGetString(prhs[1], timstr, DEFAULT_STR_LENGTH);

      et = vec_et;

      str2et_c(timstr, et);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void              stpool_c ( ConstSpiceChar    * item,
                                SpiceInt            nth,
                                ConstSpiceChar    * contin,
                                SpiceInt            lenout,
                                SpiceChar         * string,
                                SpiceInt          * size,
                                SpiceBoolean      * found  );
*/
void cspice_stpool(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            item  [DEFAULT_STR_LENGTH+1];
   SpiceInt             nth;
   SpiceChar            contin[DEFAULT_STR_LENGTH+1];
   SpiceChar            stringx[DEFAULT_STR_LENGTH+1];
   SpiceInt             size;
   SpiceBoolean       * found;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "item",   MiceChar,    0, {0}, 0},
      { "nth",    MiceInt,     0, {0}, 0},
      { "contin", MiceChar,    0, {0}, 0},
      { "nthstr", MiceChar,    0, {0}, 0},
      { "found",  MiceBoolean, 0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 3, 2);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], item, DEFAULT_STR_LENGTH);

   /*
   MATLAB uses a base 1 array index convention, as is proper,
   C does not, which is weird. Subtract one off the 'nth' index.
   */
   nth = S_INT_ARGV(2) - 1;

   mxGetString(prhs[3], contin, DEFAULT_STR_LENGTH);

   found  = A_BOOL_RET_ARGV(1);

   stpool_c ( item,  nth, contin, DEFAULT_STR_LENGTH, stringx, &size, found );

   if( *found )
      {
      plhs[0] = mxCreateString( stringx );
      }
   else
      {
      plhs[0] = mxCreateString( "\0" );
      }

   if ( plhs[0] == NULL )
      {
      mexErrMsgTxt(
         "MICE(BUG): mxCreateString failed in cspice_stpool: plhs[0]" );
      }

   if ( size > DEFAULT_STR_LENGTH )
      {
      mexErrMsgTxt(
         "MICE(BUG): The Mice interface truncated the string value "
         "corresponding to the kernel variable." );
      }

   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              subpnt_c ( ConstSpiceChar       * method,
                                ConstSpiceChar       * target,
                                SpiceDouble            et,
                                ConstSpiceChar       * fixref,
                                ConstSpiceChar       * abcorr,
                                ConstSpiceChar       * obsrvr,
                                SpiceDouble            spoint [3],
                                SpiceDouble          * trgepc,
                                SpiceDouble            srfvec [3] )
*/
void mice_subpnt(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_et;
   SpiceChar            method[DEFAULT_STR_LENGTH+1];
   SpiceChar            target[DEFAULT_STR_LENGTH+1];
   SpiceDouble          et;
   SpiceChar            fixref[DEFAULT_STR_LENGTH+1];
   SpiceChar            abcorr[DEFAULT_STR_LENGTH+1];
   SpiceChar            obsrvr[DEFAULT_STR_LENGTH+1];
   SpiceDouble          spoint[3];
   SpiceDouble          trgepc;
   SpiceDouble          srfvec[3];

   mwIndex              i;

   struct extra_dims  * extra;

   struct argcheck ArgCheck[] =
      {
      { "method", MiceChar,   0, {0}, 0},
      { "target", MiceChar,   0, {0}, 0},
      { "et",     MiceDouble, 0, {0}, 1},
      { "fixref", MiceChar,   0, {0}, 0},
      { "abcorr", MiceChar,   0, {0}, 0},
      { "obsrvr", MiceChar,   0, {0}, 0},
      { "subpnt", MiceSub_PS, 0, {0}, 1}
      };

   check_arg_num( nrhs, nlhs, 6, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], method, DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], target, DEFAULT_STR_LENGTH);

   vec_et = A_DBL_ARGV(3);
   et     = *(vec_et);

   mxGetString(prhs[4], fixref, DEFAULT_STR_LENGTH);
   mxGetString(prhs[5], abcorr, DEFAULT_STR_LENGTH);
   mxGetString(prhs[6], obsrvr, DEFAULT_STR_LENGTH);

   /*
   Check for vectorized arguments.
   */
   if (extra->count>1)
      {

      /*
      Something input as a N-vector, extract the input values
      (vectorized or not) then execute the routine for each
      set of inputs.
      */
      for (i=0;i<extra->count;i++)
         {

         et = *(vec_et + i*extra->offset[2]);

         subpnt_c ( method,
                    target,
                    et,
                    fixref,
                    abcorr,
                    obsrvr,
                    spoint,
                    &trgepc,
                    srfvec );

         CHECK_CALL_FAILURE(i);

         /*
         Copy 'spoint', 'trgepc', and 'srfvec' into the ith structure.
         */
         memcpy( mxGetPr( mxGetField(plhs[0],i,"spoint" ) ),
                 spoint,
                 3*sizeof(SpiceDouble));

         mxDestroyArray( mxGetField( plhs[0], i, "trgepc" ) );
         mxSetField( plhs[0], i, "trgepc", mxCreateDoubleScalar(trgepc) );

         memcpy( mxGetPr( mxGetField(plhs[0],i,"srfvec" ) ),
                 srfvec,
                 3*sizeof(SpiceDouble));

         }

      }
   else
      {

      subpnt_c ( method,
                 target,
                 et,
                 fixref,
                 abcorr,
                 obsrvr,
                 spoint,
                 &trgepc,
                 srfvec );

      CHECK_CALL_FAILURE(SCALAR);

      /*
      Copy 'spoint', 'trgepc', and 'srfvec' into the return structure.
      */
      memcpy( mxGetPr( mxGetField(plhs[0],0,"spoint" ) ),
              spoint,
              3*sizeof(SpiceDouble));

      mxDestroyArray( mxGetField( plhs[0], 0, "trgepc" ) );
      mxSetField( plhs[0], 0, "trgepc", mxCreateDoubleScalar(trgepc) );

      memcpy( mxGetPr( mxGetField(plhs[0],0,"srfvec" ) ),
              srfvec,
              3*sizeof(SpiceDouble));
      }

   }




/*
   void subpt_pl02 ( SpiceInt               handle,
                     ConstSpiceDLADescr   * dladsc,
                     ConstSpiceChar       * method,
                     ConstSpiceChar       * target,
                     SpiceDouble            et,
                     ConstSpiceChar       * abcorr,
                     ConstSpiceChar       * obsrvr,
                     SpiceDouble            spoint [3],
                     SpiceDouble          * alt,
                     SpiceInt             * plateID     )

*/
void cspice_subpt_pl02(int nlhs, mxArray *plhs[], int nrhs,
                       const mxArray *prhs[])
   {
   SpiceInt             handle;
   SpiceDLADescr        local_dladsc;
   SpiceInt           * dladsc;
   SpiceChar            method[DEFAULT_STR_LENGTH+1];
   SpiceChar            target[DEFAULT_STR_LENGTH+1];
   SpiceDouble          et;
   SpiceChar            abcorr[DEFAULT_STR_LENGTH+1];
   SpiceChar            obsrvr[DEFAULT_STR_LENGTH+1];
   SpiceDouble        * spoint;
   SpiceDouble        * alt;
   SpiceInt           * plateID;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle",  MiceInt,     0, {0},                0},
      { "dladsc",  MiceInt,     1, {SPICE_DLA_DSCSIZ}, 0},
      { "method",  MiceChar,    0, {0},                0},
      { "target",  MiceChar,    0, {0},                0},
      { "et",      MiceDouble,  0, {0},                0},
      { "abcorr",  MiceChar,    0, {0},                0},
      { "obsrvr",  MiceChar,    0, {0},                0},
      { "spoint",  MiceDouble,  1, {3},                0},
      { "alt",     MiceDouble,  0, {0},                0},
      { "plateID", MiceInt,     1, {1},                0}
      };

   check_arg_num( nrhs, nlhs, 7, 3 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle  = S_INT_ARGV(1);
   dladsc  = A_INT_ARGV(2);

   local_dladsc.bwdptr = dladsc[SPICE_DLA_BWDIDX];
   local_dladsc.fwdptr = dladsc[SPICE_DLA_FWDIDX];
   local_dladsc.ibase  = dladsc[SPICE_DLA_IBSIDX];
   local_dladsc.isize  = dladsc[SPICE_DLA_ISZIDX];
   local_dladsc.dbase  = dladsc[SPICE_DLA_DBSIDX];
   local_dladsc.dsize  = dladsc[SPICE_DLA_DSZIDX];
   local_dladsc.cbase  = dladsc[SPICE_DLA_CBSIDX];
   local_dladsc.csize  = dladsc[SPICE_DLA_CSZIDX];

   mxGetString(prhs[3], method, DEFAULT_STR_LENGTH);
   mxGetString(prhs[4], target, DEFAULT_STR_LENGTH);

   et = S_DBL_ARGV(5);

   mxGetString(prhs[6], abcorr, DEFAULT_STR_LENGTH);
   mxGetString(prhs[7], obsrvr, DEFAULT_STR_LENGTH);

   spoint  = A_DBL_RET_ARGV(0);
   alt     = A_DBL_RET_ARGV(1);
   plateID = A_INT_RET_ARGV(2);

   subpt_pl02 ( handle, &local_dladsc, method, target, et,
                abcorr, obsrvr,        spoint, alt,    plateID );

   CHECK_CALL_FAILURE(SCALAR);
   }




/*
   void              subpt_c ( ConstSpiceChar       * method,
                               ConstSpiceChar       * target,
                               SpiceDouble            et,
                               ConstSpiceChar       * abcorr,
                               ConstSpiceChar       * obsrvr,
                               SpiceDouble            spoint [3],
                               SpiceDouble          * alt         )
*/
void mice_subpt(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_et;
   SpiceChar            method[DEFAULT_STR_LENGTH+1];
   SpiceChar            target[DEFAULT_STR_LENGTH+1];
   SpiceChar            abcorr[DEFAULT_STR_LENGTH+1];
   SpiceChar            obsrvr[DEFAULT_STR_LENGTH+1];
   SpiceDouble          et;
   SpiceDouble          spoint[3];
   SpiceDouble          alt;

   mwIndex              i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "method", MiceChar,   0, {0}, 0},
      { "target", MiceChar,   0, {0}, 0},
      { "et",     MiceDouble, 0, {0}, 1},
      { "abcorr", MiceChar,   0, {0}, 0},
      { "obsrvr", MiceChar,   0, {0}, 0},
      { "spoint", MiceNear,    0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 5, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], method, DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], target, DEFAULT_STR_LENGTH);

   vec_et = A_DBL_ARGV(3);
   et     = *(vec_et);

   mxGetString(prhs[4], abcorr, DEFAULT_STR_LENGTH);
   mxGetString(prhs[5], obsrvr, DEFAULT_STR_LENGTH);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         et = *(vec_et + i*extra->offset[2]);

         subpt_c(method, target, et, abcorr, obsrvr, spoint, &alt);
         CHECK_CALL_FAILURE(i);

         /*
         Copy the position and altitude values into the ith
         structure element.
         */
         memcpy( mxGetPr( mxGetField(plhs[0],i,"pos" ) ),
                 spoint,
                 3*sizeof(SpiceDouble));

         mxDestroyArray( mxGetField( plhs[0], i, "alt" ) );
         mxSetField( plhs[0], i, "alt", mxCreateDoubleScalar(alt) );

        }

     }
   else
      {

      subpt_c(method, target, et, abcorr, obsrvr, spoint, &alt);
      CHECK_CALL_FAILURE(SCALAR);

      /*
      Copy the position and altitude values into the 0 structure element.
      */
      memcpy( mxGetPr( mxGetField(plhs[0],0,"pos" ) ),
              spoint,
              3*sizeof(SpiceDouble));

      mxDestroyArray( mxGetField( plhs[0], 0, "alt" ) );
      mxSetField( plhs[0], 0, "alt", mxCreateDoubleScalar(alt) );

      }

   }




/*
   void              subslr_c ( ConstSpiceChar       * method,
                                ConstSpiceChar       * target,
                                SpiceDouble            et,
                                ConstSpiceChar       * fixref,
                                ConstSpiceChar       * abcorr,
                                ConstSpiceChar       * obsrvr,
                                SpiceDouble            spoint [3],
                                SpiceDouble          * trgepc,
                                SpiceDouble            srfvec [3] )
*/
void mice_subslr(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_et;
   SpiceChar            method[DEFAULT_STR_LENGTH+1];
   SpiceChar            target[DEFAULT_STR_LENGTH+1];
   SpiceDouble          et;
   SpiceChar            fixref[DEFAULT_STR_LENGTH+1];
   SpiceChar            abcorr[DEFAULT_STR_LENGTH+1];
   SpiceChar            obsrvr[DEFAULT_STR_LENGTH+1];
   SpiceDouble          spoint[3];
   SpiceDouble          trgepc;
   SpiceDouble          srfvec[3];

   mwIndex              i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "method", MiceChar,   0, {0}, 0},
      { "target", MiceChar,   0, {0}, 0},
      { "et",     MiceDouble, 0, {0}, 1},
      { "fixref", MiceChar,   0, {0}, 0},
      { "abcorr", MiceChar,   0, {0}, 0},
      { "obsrvr", MiceChar,   0, {0}, 0},
      { "subslr", MiceSub_PS, 0, {0}, 1}
      };

   check_arg_num( nrhs, nlhs, 6, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], method, DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], target, DEFAULT_STR_LENGTH);

   vec_et = A_DBL_ARGV(3);
   et     = *(vec_et);

   mxGetString(prhs[4], fixref, DEFAULT_STR_LENGTH);
   mxGetString(prhs[5], abcorr, DEFAULT_STR_LENGTH);
   mxGetString(prhs[6], obsrvr, DEFAULT_STR_LENGTH);

   /*
   Check for vectorized arguments.
   */
   if (extra->count>1)
      {

      /*
      Something input as a N-vector, extract the input values
      (vectorized or not) then execute the routine for each
      set of inputs.
      */
      for (i=0;i<extra->count;i++)
         {

         et = *(vec_et + i*extra->offset[2]);

         subslr_c ( method,
                    target,
                    et,
                    fixref,
                    abcorr,
                    obsrvr,
                    spoint,
                    &trgepc,
                    srfvec );

         CHECK_CALL_FAILURE(i);

         /*
         Copy 'spoint', 'trgepc', and 'srfvec' into the ith structure.
         */
         memcpy( mxGetPr( mxGetField(plhs[0],i,"spoint" ) ),
                 spoint,
                 3*sizeof(SpiceDouble));

         mxDestroyArray( mxGetField( plhs[0], i, "trgepc" ) );
         mxSetField( plhs[0], i, "trgepc", mxCreateDoubleScalar(trgepc) );

         memcpy( mxGetPr( mxGetField(plhs[0],i,"srfvec" ) ),
                 srfvec,
                 3*sizeof(SpiceDouble));
         }

      }
   else
      {

      subslr_c ( method,
                 target,
                 et,
                 fixref,
                 abcorr,
                 obsrvr,
                 spoint,
                 &trgepc,
                 srfvec );

      CHECK_CALL_FAILURE(SCALAR);

      /*
      Copy 'spoint', 'trgepc', and 'srfvec' into the return structure.
      */
      memcpy( mxGetPr( mxGetField(plhs[0],0,"spoint" ) ),
              spoint,
              3*sizeof(SpiceDouble));

      mxDestroyArray( mxGetField( plhs[0], 0, "trgepc" ) );
      mxSetField( plhs[0], 0, "trgepc", mxCreateDoubleScalar(trgepc) );

      memcpy( mxGetPr( mxGetField(plhs[0],0,"srfvec" ) ),
              srfvec,
              3*sizeof(SpiceDouble));
      }

   }




/*
   void              subsol_c ( ConstSpiceChar    * method,
                                ConstSpiceChar    * target,
                                SpiceDouble         et,
                                ConstSpiceChar    * abcorr,
                                ConstSpiceChar    * obsrvr,
                                SpiceDouble         spoint[3] );
*/
void cspice_subsol(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_et;
   SpiceDouble        * vec_spoint;
   SpiceChar            method[DEFAULT_STR_LENGTH+1];
   SpiceChar            target[DEFAULT_STR_LENGTH+1];
   SpiceChar            abcorr[DEFAULT_STR_LENGTH+1];
   SpiceChar            obsrvr[DEFAULT_STR_LENGTH+1];
   SpiceDouble          et;
   SpiceDouble        * spoint;

   mwIndex              i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "method", MiceChar,   0, {0}, 0},
      { "target", MiceChar,   0, {0}, 0},
      { "et",     MiceDouble, 0, {0}, 1},
      { "abcorr", MiceChar,   0, {0}, 0},
      { "obsrvr", MiceChar,   0, {0}, 0},
      { "spoint", MiceDouble, 1, {3}, 1},
      };

   check_arg_num( nrhs, nlhs, 5, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], method, DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], target, DEFAULT_STR_LENGTH);

   vec_et = A_DBL_ARGV(3);
   et     = *(vec_et);

   mxGetString(prhs[4], abcorr, DEFAULT_STR_LENGTH);
   mxGetString(prhs[5], obsrvr, DEFAULT_STR_LENGTH);

   vec_spoint = A_DBL_RET_ARGV(0);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         et     = *(vec_et     + i*extra->offset[2]);
         spoint =  (vec_spoint + i*extra->offset[5]);

         subsol_c(method, target, et, abcorr, obsrvr, spoint );
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {

      spoint = vec_spoint;

      subsol_c(method, target, et, abcorr, obsrvr, spoint );
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void subsol_pl02 ( SpiceInt               handle,
                      ConstSpiceDLADescr   * dladsc,
                      ConstSpiceChar       * method,
                      ConstSpiceChar       * target,
                      SpiceDouble            et,
                      ConstSpiceChar       * abcorr,
                      ConstSpiceChar       * obsrvr,
                      SpiceDouble            spoint [3],
                      SpiceDouble          * dist,
                      SpiceInt             * plateID     )

*/
void cspice_subsol_pl02(int nlhs, mxArray *plhs[], int nrhs,
                        const mxArray *prhs[])
   {
   SpiceInt             handle;
   SpiceDLADescr        local_dladsc;
   SpiceInt           * dladsc;
   SpiceChar            method[DEFAULT_STR_LENGTH+1];
   SpiceChar            target[DEFAULT_STR_LENGTH+1];
   SpiceDouble          et;
   SpiceChar            abcorr[DEFAULT_STR_LENGTH+1];
   SpiceChar            obsrvr[DEFAULT_STR_LENGTH+1];
   SpiceDouble        * spoint;
   SpiceDouble        * alt;
   SpiceInt           * plateID;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle",  MiceInt,     0, {0},                0},
      { "dladsc",  MiceInt,     1, {SPICE_DLA_DSCSIZ}, 0},
      { "method",  MiceChar,    0, {0},                0},
      { "target",  MiceChar,    0, {0},                0},
      { "et",      MiceDouble,  0, {0},                0},
      { "abcorr",  MiceChar,    0, {0},                0},
      { "obsrvr",  MiceChar,    0, {0},                0},
      { "spoint",  MiceDouble,  1, {3},                0},
      { "alt",     MiceDouble,  0, {0},                0},
      { "plateID", MiceInt,     1, {1},                0}

      };

   check_arg_num( nrhs, nlhs, 7, 3 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle  = S_INT_ARGV(1);
   dladsc  = A_INT_ARGV(2);

   local_dladsc.bwdptr = dladsc[SPICE_DLA_BWDIDX];
   local_dladsc.fwdptr = dladsc[SPICE_DLA_FWDIDX];
   local_dladsc.ibase  = dladsc[SPICE_DLA_IBSIDX];
   local_dladsc.isize  = dladsc[SPICE_DLA_ISZIDX];
   local_dladsc.dbase  = dladsc[SPICE_DLA_DBSIDX];
   local_dladsc.dsize  = dladsc[SPICE_DLA_DSZIDX];
   local_dladsc.cbase  = dladsc[SPICE_DLA_CBSIDX];
   local_dladsc.csize  = dladsc[SPICE_DLA_CSZIDX];\

   mxGetString(prhs[3], method, DEFAULT_STR_LENGTH);
   mxGetString(prhs[4], target, DEFAULT_STR_LENGTH);

   et = S_DBL_ARGV(5);

   mxGetString(prhs[6], abcorr, DEFAULT_STR_LENGTH);
   mxGetString(prhs[7], obsrvr, DEFAULT_STR_LENGTH);

   spoint  = A_DBL_RET_ARGV(0);
   alt     = A_DBL_RET_ARGV(1);
   plateID = A_INT_RET_ARGV(2);

   subsol_pl02 ( handle, &local_dladsc, method, target, et,
                 abcorr, obsrvr,        spoint, alt,    plateID );

   CHECK_CALL_FAILURE(SCALAR);
   }




/*
   void              surfnm_c( SpiceDouble        a,
                               SpiceDouble        b,
                               SpiceDouble        c,
                               ConstSpiceDouble   point[3],
                               SpiceDouble        normal[3] )
*/
void cspice_surfnm(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_point;
   SpiceDouble        * vec_normal;
   SpiceDouble          a;
   SpiceDouble          b;
   SpiceDouble          c;
   SpiceDouble        * point;
   SpiceDouble        * normal;

   mwIndex              i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "a",      MiceDouble, 0, {0}, 0},
      { "b",      MiceDouble, 0, {0}, 0},
      { "c",      MiceDouble, 0, {0}, 0},
      { "point",  MiceDouble, 1, {3}, 1},
      { "normal", MiceDouble, 1, {3}, 1},
      };

   check_arg_num( nrhs, nlhs, 4, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   a          = S_DBL_ARGV(1);
   b          = S_DBL_ARGV(2);
   c          = S_DBL_ARGV(3);
   vec_point  = A_DBL_ARGV(4);
   vec_normal = A_DBL_RET_ARGV(0);

   point      = (vec_point);
   normal     = (vec_normal);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         point  =  (vec_point  + i*extra->offset[3]);
         normal =  (vec_normal + i*extra->offset[4]);

         surfnm_c(a, b, c, point, normal);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {

      surfnm_c(a, b, c, point, normal);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void               surfpt_c ( ConstSpiceDouble   positn[3],
                                 ConstSpiceDouble   u[3],
                                 SpiceDouble        a,
                                 SpiceDouble        b,
                                 SpiceDouble        c,
                                 SpiceDouble        point[3],
                                 SpiceBoolean     * found     )
*/
void mice_surfpt(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {
   SpiceDouble        * positn;
   SpiceDouble        * u;
   SpiceDouble          a;
   SpiceDouble          b;
   SpiceDouble          c;
   SpiceDouble          point[3];
   SpiceBoolean         found;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "positn", MiceDouble,  1, {3}, 0},
      { "u",      MiceDouble,  1, {3}, 0},
      { "a",      MiceDouble,  0, {0}, 0},
      { "b",      MiceDouble,  0, {0}, 0},
      { "c",      MiceDouble,  0, {0}, 0},
      { "surfpt", MiceSurf_PS, 0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 5, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   /* extra-> offset corresponds to argcheck table from[0]*/
   positn  = A_DBL_ARGV(1);
   u       = A_DBL_ARGV(2);
   a       = S_DBL_ARGV(3);
   b       = S_DBL_ARGV(4);
   c       = S_DBL_ARGV(5);

   surfpt_c ( positn,
              u,
              a,
              b,
              c,
              point,
              &found );

   CHECK_CALL_FAILURE(SCALAR);

   memcpy( mxGetPr( mxGetField(plhs[0],0,"spoint" ) ),
           point,
           3*sizeof(SpiceDouble));

   mxDestroyArray( mxGetField( plhs[0], 0, "found" ) );
   mxSetField( plhs[0], 0, "found",
               mxCreateLogicalScalar(found ? true: false));

   }




/*
   void surfpv_c ( ConstSpiceDouble      stvrtx[6],
                   ConstSpiceDouble      stdir [6],
                   SpiceDouble           a,
                   SpiceDouble           b,
                   SpiceDouble           c,
                   SpiceDouble           stx   [6],
                   SpiceBoolean        * found      )
*/
void cspice_surfpv(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * stvrtx;
   SpiceDouble        * stdir;
   SpiceDouble          a;
   SpiceDouble          b;
   SpiceDouble          c;
   SpiceDouble        * stx;
   SpiceBoolean       * found;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "stvrtx",  MiceDouble,   1, {6},   0},
      { "stdir",   MiceDouble,   1, {6},   0},
      { "a",       MiceDouble,   0, {0},   0},
      { "b",       MiceDouble,   0, {0},   0},
      { "c",       MiceDouble,   0, {0},   0},
      { "stx",     MiceDouble,   1, {6},   0},
      { "found",   MiceBoolean,  0, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 5, 2 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   stvrtx   = A_DBL_ARGV(1);
   stdir    = A_DBL_ARGV(2);
   a        = S_DBL_ARGV(3);
   b        = S_DBL_ARGV(4);
   c        = S_DBL_ARGV(5);

   stx      = A_DBL_RET_ARGV(0);
   found    = A_BOOL_RET_ARGV(1);

   surfpv_c ( stvrtx, stdir, a, b, c, stx, found );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void szpool_c ( ConstSpiceChar * name,
                   SpiceInt       * n,
                   SpiceBoolean   * found )
*/
void cspice_szpool(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            name   [DEFAULT_STR_LENGTH+1];
   SpiceInt           * n;
   SpiceBoolean       * found;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "name",    MiceChar,     0, {0},   0},
      { "n",       MiceInt,      0, {0},   0},
      { "found",   MiceBoolean,  0, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 1, 2 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], name, DEFAULT_STR_LENGTH);

   n     = A_INT_RET_ARGV(0);
   found = A_BOOL_RET_ARGV(1);

   szpool_c ( name, n, found );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void tangpt_c ( ConstSpiceChar    * method,
                   ConstSpiceChar    * target,
                   SpiceDouble         et,
                   ConstSpiceChar    * fixref,
                   ConstSpiceChar    * abcorr,
                   ConstSpiceChar    * corloc,
                   ConstSpiceChar    * obsrvr,
                   ConstSpiceChar    * dref,
                   ConstSpiceDouble    dvec   [3],
                   SpiceDouble         tanpt  [3],
                   SpiceDouble       * alt,
                   SpiceDouble       * range,
                   SpiceDouble         srfpt  [3],
                   SpiceDouble       * trgepc,
                   SpiceDouble         srfvec [3] )
*/
void cspice_tangpt(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            method [DEFAULT_STR_LENGTH+1];
   SpiceChar            target [DEFAULT_STR_LENGTH+1];
   SpiceDouble          et;
   SpiceChar            fixref [DEFAULT_STR_LENGTH+1];
   SpiceChar            abcorr [DEFAULT_STR_LENGTH+1];
   SpiceChar            corloc [DEFAULT_STR_LENGTH+1];
   SpiceChar            obsrvr [DEFAULT_STR_LENGTH+1];
   SpiceChar            dref   [DEFAULT_STR_LENGTH+1];
   SpiceDouble        * dvec;
   SpiceDouble        * tanpt;
   SpiceDouble        * alt;
   SpiceDouble        * range;
   SpiceDouble        * srfpt;
   SpiceDouble        * trgepc;
   SpiceDouble        * srfvec;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "method",  MiceChar,     0, {0},   0},
      { "target",  MiceChar,     0, {0},   0},
      { "et",      MiceDouble,   0, {0},   0},
      { "fixref",  MiceChar,     0, {0},   0},
      { "abcorr",  MiceChar,     0, {0},   0},
      { "corloc",  MiceChar,     0, {0},   0},
      { "obsrvr",  MiceChar,     0, {0},   0},
      { "dref",    MiceChar,     0, {0},   0},
      { "dvec",    MiceDouble,   1, {3},   0},
      { "tanpt",   MiceDouble,   1, {3},   0},
      { "alt",     MiceDouble,   0, {0},   0},
      { "range",   MiceDouble,   0, {0},   0},
      { "srfpt",   MiceDouble,   1, {3},   0},
      { "trgepc",  MiceDouble,   0, {0},   0},
      { "srfvec",  MiceDouble,   1, {3},   0},
      };

   check_arg_num( nrhs, nlhs, 9, 6 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], method, DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], target, DEFAULT_STR_LENGTH);

   et       = S_DBL_ARGV(3);

   mxGetString(prhs[4], fixref, DEFAULT_STR_LENGTH);
   mxGetString(prhs[5], abcorr, DEFAULT_STR_LENGTH);
   mxGetString(prhs[6], corloc, DEFAULT_STR_LENGTH);
   mxGetString(prhs[7], obsrvr, DEFAULT_STR_LENGTH);
   mxGetString(prhs[8], dref, DEFAULT_STR_LENGTH);

   dvec     = A_DBL_ARGV(9);

   tanpt    = A_DBL_RET_ARGV(0);
   alt      = A_DBL_RET_ARGV(1);
   range    = A_DBL_RET_ARGV(2);
   srfpt    = A_DBL_RET_ARGV(3);
   trgepc   = A_DBL_RET_ARGV(4);
   srfvec   = A_DBL_RET_ARGV(5);

   tangpt_c ( method, target, et, fixref, abcorr, corloc, obsrvr, dref,
              dvec, tanpt, alt, range, srfpt, trgepc, srfvec );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
 void               sxform_c( ConstSpiceChar  * from,
                               ConstSpiceChar  * to,
                               SpiceDouble       et,
                               SpiceDouble       xform[6][6] )
 */
void cspice_sxform(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_et;
   SpiceDouble        * vec_xform;
   SpiceChar            from[DEFAULT_STR_LENGTH+1];
   SpiceChar            to  [DEFAULT_STR_LENGTH+1];
   SpiceDouble          et;
   SpiceDouble        * xform;
   SpiceDouble          xr[6][6];

   mwIndex              i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "from",  MiceChar,   0, {0},    0},
      { "to",    MiceChar,   0, {0},    0},
      { "et",    MiceDouble, 0, {0},    1},
      { "xform", MiceDouble, 2, {6, 6}, 1},
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], from, DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], to,   DEFAULT_STR_LENGTH);

   vec_et    = A_DBL_ARGV(3);
   vec_xform = A_DBL_RET_ARGV(0);
   et        = *vec_et;
   xform     =  vec_xform;

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         et    = *(vec_et    + i*extra->offset[2]);
         xform =  (vec_xform + i*extra->offset[3]);

         sxform_c(from, to, et, (SpiceDouble (*)[6])xr);
         CHECK_CALL_FAILURE(i);

         xpose6_c( xr, (SpiceDouble (*)[6])xform );
         }

      }
   else
      {

      sxform_c(from, to, et, (SpiceDouble (*)[6])xr);
      CHECK_CALL_FAILURE(SCALAR);

      xpose6_c( xr, (SpiceDouble (*)[6])xform );
      }

   }




/*
   void term_pl02 ( SpiceInt              handle,
                    ConstSpiceDLADescr  * dladsc,
                    ConstSpiceChar      * trmtyp,
                    ConstSpiceChar      * source,
                    ConstSpiceChar      * target,
                    SpiceDouble           et,
                    ConstSpiceChar      * fixfrm,
                    ConstSpiceChar      * abcorr,
                    ConstSpiceChar      * obsrvr,
                    SpiceInt              npoints,
                    SpiceDouble         * trgepc,
                    SpiceDouble           obspos   [3],
                    SpiceDouble           termpts  [][3],
                    SpiceInt              plateIDs []     )

 */
void cspice_term_pl02(int nlhs, mxArray *plhs[], int nrhs,
                      const mxArray *prhs[])
   {
   SpiceInt             handle;
   SpiceDLADescr        local_dladsc;
   SpiceInt           * dladsc;
   SpiceChar            trmtyp[DEFAULT_STR_LENGTH+1];
   SpiceChar            source[DEFAULT_STR_LENGTH+1];
   SpiceChar            target[DEFAULT_STR_LENGTH+1];
   SpiceDouble          et;
   SpiceChar            fixfrm[DEFAULT_STR_LENGTH+1];
   SpiceChar            abcorr[DEFAULT_STR_LENGTH+1];
   SpiceChar            obsrvr[DEFAULT_STR_LENGTH+1];
   SpiceInt             npoints;
   SpiceDouble        * trgepc;
   SpiceDouble        * obspos;
   SpiceDouble      ( * termpts )[3];
   SpiceInt           * plateIDs;

   mwSize               size_termpts [2];
   mwSize               size_plateIDs[2];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle",   MiceInt,     0, {0},                0},
      { "dladsc",   MiceInt,     1, {SPICE_DLA_DSCSIZ}, 0},
      { "trmtyp",   MiceChar,    0, {0},                0},
      { "source",   MiceChar,    0, {0},                0},
      { "target",   MiceChar,    0, {0},                0},
      { "et",       MiceDouble,  0, {0},                0},
      { "fixfrm",   MiceChar,    0, {0},                0},
      { "abcorr",   MiceChar,    0, {0},                0},
      { "obsrvr",   MiceChar,    0, {0},                0},
      { "npoints",  MiceInt,     0, {0},                0},
      { "trgepc",   MiceDouble,  0, {0},                0},
      { "obspos",   MiceDouble,  1, {3},                0},
      { "termpts",  MiceIgnore,  0, {0},                0},
      { "plateIDs", MiceIgnore,  0, {0},                0}
      };

   check_arg_num( nrhs, nlhs, 10, 4 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle  = S_INT_ARGV(1);
   dladsc  = A_INT_ARGV(2);

   local_dladsc.bwdptr = dladsc[SPICE_DLA_BWDIDX];
   local_dladsc.fwdptr = dladsc[SPICE_DLA_FWDIDX];
   local_dladsc.ibase  = dladsc[SPICE_DLA_IBSIDX];
   local_dladsc.isize  = dladsc[SPICE_DLA_ISZIDX];
   local_dladsc.dbase  = dladsc[SPICE_DLA_DBSIDX];
   local_dladsc.dsize  = dladsc[SPICE_DLA_DSZIDX];
   local_dladsc.cbase  = dladsc[SPICE_DLA_CBSIDX];
   local_dladsc.csize  = dladsc[SPICE_DLA_CSZIDX];

   mxGetString(prhs[3], trmtyp, DEFAULT_STR_LENGTH);
   mxGetString(prhs[4], source, DEFAULT_STR_LENGTH);
   mxGetString(prhs[5], target, DEFAULT_STR_LENGTH);

   et = S_DBL_ARGV(6);

   mxGetString(prhs[7], fixfrm, DEFAULT_STR_LENGTH);
   mxGetString(prhs[8], abcorr, DEFAULT_STR_LENGTH);
   mxGetString(prhs[9], obsrvr, DEFAULT_STR_LENGTH);

   npoints = S_INT_ARGV(10);

   trgepc  = A_DBL_RET_ARGV(0);
   obspos  = A_DBL_RET_ARGV(1);

   if( npoints <= 0 )
      {
      mexErrMsgTxt( "MICE(INVALIDSIZE): `npoints` must be "
                    "greater-than zero." );
      }

   if ( npoints > 0 )
      {
      size_termpts[0]  = 3;
      size_termpts[1]  = npoints;

      size_plateIDs[0] = 1;
      size_plateIDs[1] = npoints;
      }
   else
      {
      size_termpts[0]  = 0;
      size_termpts[1]  = 0;

      size_plateIDs[0] = 0;
      size_plateIDs[1] = 0;
      }


   plhs[2]  = mxCreateNumericArray( 2, size_termpts,  mxDOUBLE_CLASS, mxREAL);
   termpts  = (SpiceDouble (*)[3])A_DBL_RET_ARGV(2);

   plhs[3]  = mxCreateNumericArray( 2, size_plateIDs, mxINT32_CLASS, mxREAL);
   plateIDs = (SpiceInt *)A_INT_RET_ARGV(3);

   if ( npoints > 0 )
      {
      term_pl02 ( handle, &local_dladsc, trmtyp,  source,
                  target, et,            fixfrm,  abcorr,
                  obsrvr, npoints,       trgepc,  obspos, termpts, plateIDs );
      }

   CHECK_CALL_FAILURE(SCALAR);
   }




/*
   void              termpt_c ( ConstSpiceChar    * method,
                                ConstSpiceChar    * ilusrc,
                                ConstSpiceChar    * target,
                                SpiceDouble         et,
                                ConstSpiceChar    * fixref,
                                ConstSpiceChar    * abcorr,
                                ConstSpiceChar    * corloc,
                                ConstSpiceChar    * obsrvr,
                                ConstSpiceDouble    refvec[3],
                                SpiceDouble         rolstp,
                                SpiceInt            ncuts,
                                SpiceDouble         schstp,
                                SpiceDouble         soltol,
                                SpiceInt            maxn,
                                SpiceInt          * npts,
                                SpiceDouble         points[][3],
                                SpiceDouble         epochs[],
                                SpiceDouble         trmvcs[][3]  );
*/
void cspice_termpt(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar               method [DEFAULT_STR_LENGTH+1];
   SpiceChar               ilusrc [DEFAULT_STR_LENGTH+1];
   SpiceChar               target [DEFAULT_STR_LENGTH+1];
   SpiceDouble             et;
   SpiceChar               fixref [DEFAULT_STR_LENGTH+1];
   SpiceChar               abcorr [DEFAULT_STR_LENGTH+1];
   SpiceChar               corloc [DEFAULT_STR_LENGTH+1];
   SpiceChar               obsrvr [DEFAULT_STR_LENGTH+1];
   SpiceDouble           * refvec;
   SpiceDouble             rolstp;
   SpiceInt                ncuts;
   SpiceDouble             schstp;
   SpiceDouble             soltol;
   SpiceInt                maxn;
   SpiceInt              * npts;
   SpiceDouble          (* points)[3] = 0;
   SpiceDouble           * epochs;
   SpiceDouble          (* trmvcs)[3] = 0;

   SpiceDouble           * dvals0_ret;
   SpiceDouble           * dvals1_ret;
   SpiceDouble           * dvals2_ret;
   SpiceDouble           * dvals3_ret;

   mwSize                  sizearray[2];


   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "method", MiceChar,    0, { 0 },    0},
      { "ilusrc", MiceChar,    0, { 0 },    0},
      { "target", MiceChar,    0, { 0 },    0},
      { "et",     MiceDouble,  0, { 0 },    0},
      { "fixref", MiceChar,    0, { 0 },    0},
      { "abcorr", MiceChar,    0, { 0 },    0},
      { "corloc", MiceChar,    0, { 0 },    0},
      { "obsrvr", MiceChar,    0, { 0 },    0},
      { "refvec", MiceDouble,  1, { 3 },    0},
      { "rolstp", MiceDouble,  0, { 0 },    0},
      { "ncuts",  MiceInt,     0, { 0 },    0},
      { "schstp", MiceDouble,  0, { 0 },    0},
      { "soltol", MiceDouble,  0, { 0 },    0},
      { "maxn",   MiceInt,     0, { 0 },    0},
      { "npts",   MiceIgnore,  0, { 0 },    0},
      { "points", MiceIgnore,  0, { 0 },    0},
      { "epochs", MiceIgnore,  0, { 0 },    0},
      { "trmvcs", MiceIgnore,  0, { 0 },    0},
      };

   check_arg_num( nrhs, nlhs, 14, 4 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], method, DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], ilusrc, DEFAULT_STR_LENGTH);
   mxGetString(prhs[3], target, DEFAULT_STR_LENGTH);

   et = S_DBL_ARGV(4);

   mxGetString(prhs[5], fixref, DEFAULT_STR_LENGTH);
   mxGetString(prhs[6], abcorr, DEFAULT_STR_LENGTH);
   mxGetString(prhs[7], corloc, DEFAULT_STR_LENGTH);
   mxGetString(prhs[8], obsrvr, DEFAULT_STR_LENGTH);

   refvec = A_DBL_ARGV( 9 );

   rolstp = S_DBL_ARGV(10);
   ncuts  = S_INT_ARGV(11);
   schstp = S_DBL_ARGV(12);
   soltol = S_DBL_ARGV(13);

   maxn   = S_INT_ARGV(14);

   if ( maxn > 0 )
      {

      npts  = (SpiceInt * )mxMalloc( maxn * sizeof(SpiceInt) );
      memset( npts,  0, maxn * sizeof(SpiceInt) );

      points  = (SpiceDouble (*)[3] )mxMalloc(3 * maxn * sizeof(SpiceDouble) );
      memset( points,  0, 3 * maxn * sizeof(SpiceDouble) );

      epochs  = (SpiceDouble *)mxMalloc(maxn * sizeof(SpiceDouble)  );
      memset( epochs,  0, maxn * sizeof(SpiceDouble) );

      trmvcs  = (SpiceDouble (*)[3] )mxMalloc(3 * maxn * sizeof(SpiceDouble) );
      memset( trmvcs,  0, 3 * maxn * sizeof(SpiceDouble) );

      termpt_c ( method,    ilusrc, target, et,
                 fixref,    abcorr, corloc, obsrvr,
                 refvec,    rolstp, ncuts,  schstp,
                 soltol,    maxn,   npts,  points,
                 epochs,    trmvcs                  );

      if ( failed_c() )
         {
         mxFree( npts );
         mxFree( points );
         mxFree( epochs );
         mxFree( trmvcs );


         /*
         The mice_fail call creates the error string then returns control
         to the MATLAB interpreter.
         */
         mice_fail(SCALAR);
         }

      sizearray[0] = 3;
      sizearray[1] = maxn;

      plhs[1] = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
      dvals1_ret = A_DBL_RET_ARGV(1);

      MOVED( (SpiceDouble *)points, 3*maxn, dvals1_ret );


      plhs[3] = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
      dvals3_ret = A_DBL_RET_ARGV(3);

      MOVED( (SpiceDouble *)trmvcs, 3*maxn, dvals3_ret );


      sizearray[0] = 1;
      sizearray[1] = maxn;

      plhs[0] = mxCreateNumericArray( 2, sizearray, mxINT32_CLASS, mxREAL);
      dvals0_ret = A_DBL_RET_ARGV(0);

      MOVEI( (SpiceInt *)npts, maxn, dvals0_ret );


      plhs[2] = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
      dvals2_ret = A_DBL_RET_ARGV(2);

      MOVED( (SpiceDouble *)epochs, maxn, dvals2_ret );

      mxFree( npts );
      mxFree( points );
      mxFree( epochs );
      mxFree( trmvcs );

      }
   else
      {

      sizearray[0] = 0;
      sizearray[1] = 0;

      plhs[0] = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
      dvals0_ret = A_DBL_RET_ARGV(0);

      plhs[1] = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
      dvals1_ret = A_DBL_RET_ARGV(1);

      plhs[2] = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
      dvals2_ret = A_DBL_RET_ARGV(2);

      plhs[3] = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
      dvals3_ret = A_DBL_RET_ARGV(3);

      }

   }




/*
   void              timdef_c ( ConstSpiceChar    * action,
                                ConstSpiceChar    * item,
                                SpiceInt            lenout,
                                SpiceChar         * value );
*/
void cspice_timdef_get(int nlhs, mxArray *plhs[], int nrhs,
                                      const mxArray *prhs[])
   {

   SpiceChar           item  [DEFAULT_STR_LENGTH+1];
   SpiceChar           value [DEFAULT_STR_LENGTH+1];

   struct extra_dims * extra;
   struct argcheck ArgCheck[] =
      {
      { "item",   MiceChar, 0, {0}, 0},
      { "value",  MiceChar, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 1, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], item,  DEFAULT_STR_LENGTH);

   timdef_c ( "GET", item, DEFAULT_STR_LENGTH, value );
   CHECK_CALL_FAILURE(SCALAR);

   plhs[0] = mxCreateString( value );
   if ( plhs[0] == NULL )
      {
      mexErrMsgTxt( "MICE(BUG): mxCreateString failed in cspice_timdef_get" );
      }

   }




/*
   void              timdef_c ( ConstSpiceChar    * action,
                                ConstSpiceChar    * item,
                                SpiceInt            lenout,
                                SpiceChar         * value );
*/
void cspice_timdef_set(int nlhs, mxArray *plhs[], int nrhs,
                                     const mxArray *prhs[])
   {

   SpiceChar           item  [DEFAULT_STR_LENGTH+1];
   SpiceChar           value [DEFAULT_STR_LENGTH+1];

   struct extra_dims * extra;
   struct argcheck ArgCheck[] =
      {
      { "item",   MiceChar, 0, {0}, 0},
      { "value",  MiceChar, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 2, 0 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], item,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], value, DEFAULT_STR_LENGTH);

   timdef_c ( "SET", item, DEFAULT_STR_LENGTH, value );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void               timout_c ( SpiceDouble       et,
                                 ConstSpiceChar  * pictur,
                                 SpiceInt          lenout,
                                 SpiceChar       * output )
*/
void cspice_timout(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble       * vec_et;
   SpiceDouble         et;
   SpiceChar           pictur[DEFAULT_STR_LENGTH+1];
   SpiceChar           output[DEFAULT_STR_LENGTH+1];
   SpiceChar        ** cval;
   SpiceChar        ** array;

   mwIndex             i;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "et",     MiceDouble, 0, {0}, 1},
      { "pictur", MiceChar,   0, {0}, 0},
      { "output", MiceChar,   0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   memset( output, 0, default_str_size );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_et = A_DBL_ARGV(1);

   mxGetString(prhs[2], pictur, DEFAULT_STR_LENGTH);

   if (extra->count>1)
      {
      /*
      Allocate needed memory for intermediate operations.
      */
      cval  = (SpiceChar**)alloc_SpiceString_C_array(DEFAULT_STR_LENGTH,
                                                     extra->count );
      array = (SpiceChar**)alloc_SpiceString_Pointer_array(extra->count);

      CHECK_CALL_FAILURE_MEM1(SCALAR, 1, cval, array);

      for (i=0;i<extra->count;i++)
         {

         et = *(vec_et+i*extra->offset[0]);

         /*
         Copy the ith string pointer to the array of pointers,
         use this pointer for the call output.
         */
         array[i] = *cval + i*default_str_size;

         timout_c(et, pictur, DEFAULT_STR_LENGTH, array[i]);
         CHECK_CALL_FAILURE_MEM1(i, 1, cval, array);
         }

      /*
      I think this functions as a copy, creating needed
      memory for plhs.
      */
      plhs[0] = mxCreateCharMatrixFromStrings( extra->count,
                                               (const char **)array);

      free_SpiceString_C_array ( 1, cval );
      free_SpiceMemory( array );
      }
   else
      {

      et = *(vec_et);

      timout_c(et, pictur, DEFAULT_STR_LENGTH, output);
      CHECK_CALL_FAILURE(SCALAR);

      plhs[0] = mxCreateString( output );
      if ( plhs[0] == NULL )
         {
         mexErrMsgTxt( "MICE(BUG): mxCreateString failed in cspice_timout" );
         }

      }

   /*
   Confirm the code released all allocated memory.
   */
   MICE_ALLOC_CHECK;

   }




/*
   void tipbod_c ( ConstSpiceChar  * ref,
                   SpiceInt          body,
                   SpiceDouble       et,
                   SpiceDouble       tipm[3][3] )
*/
void cspice_tipbod(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            ref    [DEFAULT_STR_LENGTH+1];
   SpiceInt             body;
   SpiceDouble          et;
   SpiceDouble        * tipm;
   SpiceDouble          ret_tipm[3][3];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "ref",     MiceChar,     0, {0},   0},
      { "body",    MiceInt,      0, {0},   0},
      { "et",      MiceDouble,   0, {0},   0},
      { "tipm",    MiceDouble,   2, {3,3}, 0},
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], ref, DEFAULT_STR_LENGTH);

   body     = S_INT_ARGV(2);
   et       = S_DBL_ARGV(3);

   tipm     = A_DBL_RET_ARGV(0);

   tipbod_c ( ref, body, et, (SpiceDouble(*)[3])ret_tipm );
   CHECK_CALL_FAILURE(SCALAR);

   xpose_c ( ret_tipm, (SpiceDouble(*)[3])tipm );

   }




/*
   void tisbod_c ( ConstSpiceChar   * ref,
                   SpiceInt           body,
                   SpiceDouble        et,
                   SpiceDouble        tsipm[6][6] )
*/
void cspice_tisbod(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            ref    [DEFAULT_STR_LENGTH+1];
   SpiceInt             body;
   SpiceDouble          et;
   SpiceDouble        * tsipm;
   SpiceDouble          ret_tsipm[6][6];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "ref",     MiceChar,     0, {0},   0},
      { "body",    MiceInt,      0, {0},   0},
      { "et",      MiceDouble,   0, {0},   0},
      { "tsipm",   MiceDouble,   2, {6,6}, 0},
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], ref, DEFAULT_STR_LENGTH);

   body     = S_INT_ARGV(2);
   et       = S_DBL_ARGV(3);

   tsipm    = A_DBL_RET_ARGV(0);

   tisbod_c ( ref, body, et, (SpiceDouble(*)[6])ret_tsipm );
   CHECK_CALL_FAILURE(SCALAR);

   xpose6_c ( ret_tsipm, (SpiceDouble(*)[6])tsipm );

   }




/*
   void tkfram_c ( SpiceInt            frcode,
                   SpiceDouble         rot    [3][3],
                   SpiceInt          * frame,
                   SpiceBoolean      * found         )
*/
void cspice_tkfram(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             frcode;
   SpiceDouble        * rot;
   SpiceDouble          ret_rot[3][3];
   SpiceInt           * frame;
   SpiceBoolean       * found;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "frcode",  MiceInt,      0, {0},   0},
      { "rot",     MiceDouble,   2, {3,3}, 0},
      { "frame",   MiceInt,      0, {0},   0},
      { "found",   MiceBoolean,  0, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 1, 3 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   frcode   = S_INT_ARGV(1);

   rot      = A_DBL_RET_ARGV(0);
   frame    = A_INT_RET_ARGV(1);
   found    = A_BOOL_RET_ARGV(2);

   tkfram_c ( frcode, (SpiceDouble(*)[3])ret_rot, frame, found );
   CHECK_CALL_FAILURE(SCALAR);

   xpose_c ( ret_rot, (SpiceDouble(*)[3])rot );

   }




/*
   ConstSpiceChar  * tkvrsn_c ( ConstSpiceChar    * item );
*/
void cspice_tkvrsn(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            item  [DEFAULT_STR_LENGTH+1];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "item",   MiceChar, 0, {0}, 0},
      { "verstr", MiceChar, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 1, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], item, DEFAULT_STR_LENGTH);

   plhs[0] = mxCreateString( tkvrsn_c(item) );
   if ( plhs[0] == NULL )
      {
      mexErrMsgTxt( "MICE(BUG): mxCreateString failed in cspice_tkvrsn" );
      }

   }




/*
   void tparch_c ( ConstSpiceChar    * type )
*/
void cspice_tparch(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            type   [DEFAULT_STR_LENGTH+1];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "type",    MiceChar,     0, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 1, 0 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], type, DEFAULT_STR_LENGTH);


   tparch_c ( type );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void tparse_c ( ConstSpiceChar  * string,
                   SpiceInt          errmln,
                   SpiceDouble     * sp2000,
                   SpiceChar       * errmsg  )
*/
void cspice_tparse(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            string [DEFAULT_STR_LENGTH+1];
   SpiceDouble        * sp2000;
   SpiceChar            errmsg [DEFAULT_STR_LENGTH+1];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "string",  MiceChar,     0, {0},   0},
      { "sp2000",  MiceDouble,   0, {0},   0},
      { "errmsg",  MiceChar,     0, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 1, 2 );

   memset( errmsg, 0, default_str_size );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], string, DEFAULT_STR_LENGTH);

   sp2000   = A_DBL_RET_ARGV(0);

   tparse_c ( string, DEFAULT_STR_LENGTH, sp2000, errmsg );
   CHECK_CALL_FAILURE(SCALAR);

   plhs[1] = mxCreateString(errmsg);

   if (plhs[1] == NULL)
      {
      mexErrMsgTxt( "MICE(BUG): mxCreateString failed in cspice_tparse" );
      }

   }




/*
   void              tpictr_c ( ConstSpiceChar     * sample,
                                SpiceInt            lenpictur,
                                SpiceInt            lenerror,
                                SpiceChar         * pictur,
                                SpiceBoolean      * ok,
                                SpiceChar         * errmsg     );
*/
void cspice_tpictr(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar           sample[DEFAULT_STR_LENGTH+1];
   SpiceChar           pictur[DEFAULT_STR_LENGTH+1];
   SpiceChar           errmsg[DEFAULT_STR_LENGTH+1];
   SpiceBoolean        ok;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "sample", MiceChar,   0, {0}, 0},
      { "pictur", MiceIgnore, 0, {0}, 0},
      { "ok",     MiceIgnore, 0, {0}, 0},
      { "errmsg", MiceIgnore, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 1, 3 );

   memset( pictur, 0, default_str_size );
   memset( errmsg, 0, default_str_size );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], sample, DEFAULT_STR_LENGTH);

   tpictr_c( sample,
             DEFAULT_STR_LENGTH,
             DEFAULT_STR_LENGTH,
             pictur,
             &ok,
             errmsg );
   CHECK_CALL_FAILURE(SCALAR);

   plhs[0] = mxCreateString( pictur );
   plhs[1] = zzmice_CreateIntScalar(ok);
   plhs[2] = mxCreateString( errmsg );

   if ( ok )
      {
      plhs[0] = mxCreateString( pictur );
      plhs[2] = mxCreateString( "\0" );
      }
   else
      {
      plhs[0] = mxCreateString( "\0" );
      plhs[2] = mxCreateString( errmsg );
      }

   if ( (plhs[0] == NULL) || (plhs[2] == NULL) )
      {
      mexErrMsgTxt( "MICE(BUG): mxCreateString failed in cspice_tpictr" );
      }

   }




/*
   SpiceDouble trgsep_c ( SpiceDouble         et,
                          ConstSpiceChar    * targ1,
                          ConstSpiceChar    * shape1,
                          ConstSpiceChar    * frame1,
                          ConstSpiceChar    * targ2,
                          ConstSpiceChar    * shape2,
                          ConstSpiceChar    * frame2,
                          ConstSpiceChar    * obsrvr,
                          ConstSpiceChar    * abcorr )
*/
void cspice_trgsep(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble          et;
   SpiceChar            targ1  [DEFAULT_STR_LENGTH+1];
   SpiceChar            shape1 [DEFAULT_STR_LENGTH+1];
   SpiceChar            frame1 [DEFAULT_STR_LENGTH+1];
   SpiceChar            targ2  [DEFAULT_STR_LENGTH+1];
   SpiceChar            shape2 [DEFAULT_STR_LENGTH+1];
   SpiceChar            frame2 [DEFAULT_STR_LENGTH+1];
   SpiceChar            obsrvr [DEFAULT_STR_LENGTH+1];
   SpiceChar            abcorr [DEFAULT_STR_LENGTH+1];
   SpiceDouble        * trgsep;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "et",      MiceDouble,   0, {0},   0},
      { "targ1",   MiceChar,     0, {0},   0},
      { "shape1",  MiceChar,     0, {0},   0},
      { "frame1",  MiceChar,     0, {0},   0},
      { "targ2",   MiceChar,     0, {0},   0},
      { "shape2",  MiceChar,     0, {0},   0},
      { "frame2",  MiceChar,     0, {0},   0},
      { "obsrvr",  MiceChar,     0, {0},   0},
      { "abcorr",  MiceChar,     0, {0},   0},
      { "trgsep",  MiceDouble,   0, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 9, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   et       = S_DBL_ARGV(1);

   mxGetString(prhs[2], targ1, DEFAULT_STR_LENGTH);
   mxGetString(prhs[3], shape1, DEFAULT_STR_LENGTH);
   mxGetString(prhs[4], frame1, DEFAULT_STR_LENGTH);
   mxGetString(prhs[5], targ2, DEFAULT_STR_LENGTH);
   mxGetString(prhs[6], shape2, DEFAULT_STR_LENGTH);
   mxGetString(prhs[7], frame2, DEFAULT_STR_LENGTH);
   mxGetString(prhs[8], obsrvr, DEFAULT_STR_LENGTH);
   mxGetString(prhs[9], abcorr, DEFAULT_STR_LENGTH);

   trgsep   = A_DBL_RET_ARGV(0);

   *trgsep = trgsep_c ( et, targ1, shape1, frame1, targ2, shape2, frame2,
                        obsrvr, abcorr );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void tsetyr_c ( SpiceInt year )
*/
void cspice_tsetyr(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             year;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "year",  MiceInt, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 1, 0 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   year = S_INT_ARGV(1);

   tsetyr_c ( year );
   CHECK_CALL_FAILURE(SCALAR);

   }






/*
   SpiceDouble twopi_c( void )
*/
void cspice_twopi(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   check_arg_num( nrhs, nlhs, 0, 1 );

   /*
   Directly return the scalar value. This simple case needs no
   error checks.
   */
   plhs[0] = mxCreateDoubleScalar( twopi_c() );

   }




/*
   void              twovec_c( ConstSpiceDouble    axdef  [3],
                               SpiceInt            indexa,
                               ConstSpiceDouble    plndef [3],
                               SpiceInt            indexp,
                               SpiceDouble         mout   [3][3] )
*/
void cspice_twovec(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * axdef;
   SpiceInt             indexa;
   SpiceDouble        * plndef;
   SpiceInt             indexp;
   SpiceDouble        * mout;
   SpiceDouble          xr[3][3];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "axdef",  MiceDouble, 1, {3},    0},
      { "indexa", MiceInt,    0, {0},    0},
      { "plndef", MiceDouble, 1, {3},    0},
      { "indexp", MiceInt,    0, {0},    0},
      { "mout",   MiceDouble, 2, {3, 3}, 0},
      };

   check_arg_num( nrhs, nlhs, 4, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   axdef  = A_DBL_ARGV(1);
   indexa = S_INT_ARGV(2);
   plndef = A_DBL_ARGV(3);
   indexp = S_INT_ARGV(4);
   mout   = A_DBL_RET_ARGV(0);

   twovec_c(axdef, indexa, plndef, indexp, (SpiceDouble(*)[3])xr);
   CHECK_CALL_FAILURE(SCALAR);

   xpose_c( xr, (SpiceDouble(*)[3])mout);

   }




/*
   void twovxf_c ( ConstSpiceDouble    axdef  [6],
                   SpiceInt            indexa,
                   ConstSpiceDouble    plndef [6],
                   SpiceInt            indexp,
                   SpiceDouble         xform  [6][6] )
*/
void cspice_twovxf(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * axdef;
   SpiceInt             indexa;
   SpiceDouble        * plndef;
   SpiceInt             indexp;
   SpiceDouble        * xform;
   SpiceDouble          ret_xform[6][6];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "axdef",   MiceDouble,   1, {6},   0},
      { "indexa",  MiceInt,      0, {0},   0},
      { "plndef",  MiceDouble,   1, {6},   0},
      { "indexp",  MiceInt,      0, {0},   0},
      { "xform",   MiceDouble,   2, {6,6}, 0},
      };

   check_arg_num( nrhs, nlhs, 4, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   axdef    = A_DBL_ARGV(1);
   indexa   = S_INT_ARGV(2);
   plndef   = A_DBL_ARGV(3);
   indexp   = S_INT_ARGV(4);

   xform    = A_DBL_RET_ARGV(0);

   twovxf_c ( axdef, indexa, plndef, indexp, (SpiceDouble(*)[6])ret_xform );
   CHECK_CALL_FAILURE(SCALAR);

   xpose6_c ( ret_xform, (SpiceDouble(*)[6])xform );

   }




/*
   SpiceDouble       tyear_c  ( void );
*/
void cspice_tyear(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   check_arg_num( nrhs, nlhs, 0, 1 );

   /*
   Directly return the scalar value. This simple case needs no
   error checks.
   */
   plhs[0] = mxCreateDoubleScalar( tyear_c() );

   }




/*
   void              unload_c ( ConstSpiceChar   * file );
*/
void cspice_unload(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar     file[DEFAULT_STR_LENGTH+1];
   mxChar      * mx_file;

   mwIndex       i;
   SpiceInt      j;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "file", MiceChar, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 1, 0 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);


   if (extra->count>1)
      {

      mx_file = (mxChar *)mxGetChars(prhs[1]);

      for (i=0;i<extra->count;i++)
         {

         /*
         Extract the string data, character by character, into
         CSPICE strings. The mx_str array stores the data in a column
         major format, we need to extract the data by rows.
         */
         for ( j=0; j<extra->offset[0]; j++)
            {
            file[j] = (char)mx_file[i + (extra->count*j)];
            }

         file[extra->offset[0]] = '\0';

         unload_c(file);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {

      mxGetString(prhs[1], file, DEFAULT_STR_LENGTH-1);

      unload_c(file);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   SpiceDouble       unitim_c ( SpiceDouble         epoch,
                                ConstSpiceChar    * insys,
                                ConstSpiceChar    * outsys )
*/
void cspice_unitim(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_epoch;
   SpiceDouble          epoch;
   SpiceChar            insys  [DEFAULT_STR_LENGTH+1];
   SpiceChar            outsys [DEFAULT_STR_LENGTH+1];
   SpiceDouble        * vec_retval;
   SpiceDouble        * retval;

   mwIndex              i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "epoch",  MiceDouble, 0, {0}, 1},
      { "insys",  MiceChar,   0, {0}, 0},
      { "outsys", MiceChar,   0, {0}, 0},
      { "unitim", MiceDouble, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[2], insys,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[3], outsys, DEFAULT_STR_LENGTH);

   vec_epoch  = A_DBL_ARGV(1);

   if (extra->count>1)
      {

      vec_retval = A_DBL_RET_ARGV(0);

      for (i=0;i<extra->count;i++)
         {

         epoch  = *(vec_epoch + i*extra->offset[0]);
         retval = vec_retval  + i*extra->offset[3];

         *retval = unitim_c ( epoch, insys, outsys );
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {

      epoch = *vec_epoch;

      plhs[0] = mxCreateDoubleScalar( unitim_c ( epoch, insys, outsys ) );
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void              unorm_c  ( ConstSpiceDouble    v1[3],
                                SpiceDouble         vout[3],
                                SpiceDouble       * vmag    );
*/
void cspice_unorm(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {
   SpiceDouble        * v1;
   SpiceDouble        * vec_v1;
   SpiceDouble        * vout;
   SpiceDouble        * vec_vout;
   SpiceDouble        * vmag;
   SpiceDouble        * vec_vmag;

   mwIndex              i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "v1",   MiceDouble, 1, {3}, 1},
      { "vout", MiceDouble, 1, {3}, 1},
      { "vmag", MiceDouble, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 1, 2 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_v1   = A_DBL_ARGV(1);
   vec_vout = A_DBL_RET_ARGV(0);
   vec_vmag = A_DBL_RET_ARGV(1);

   v1   = (vec_v1);
   vout = (vec_vout);
   vmag = (vec_vmag);

   if (extra->count>1)
      {
      for (i=0;i<extra->count;i++)
         {

         v1   =  (vec_v1   + i*extra->offset[0]);
         vout =  (vec_vout + i*extra->offset[1]);
         vmag =  (vec_vmag + i*extra->offset[2]);

         unorm_c(v1, vout, vmag);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {
      unorm_c(v1, vout, vmag);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   SpiceDouble       vdist_c  ( ConstSpiceDouble    v1[3],
                                ConstSpiceDouble    v2[3] );
*/
void cspice_vdist(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_v1;
   SpiceDouble        * vec_v2;
   SpiceDouble        * v1;
   SpiceDouble        * v2;
   SpiceDouble        * retval;
   SpiceDouble        * vec_retval;

   mwIndex              i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "v1",    MiceDouble, 1, {3}, 1},
      { "v2",    MiceDouble, 1, {3}, 1},
      { "vdist", MiceDouble, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_v1     = A_DBL_ARGV(1);
   vec_v2     = A_DBL_ARGV(2);
   vec_retval = A_DBL_RET_ARGV(0);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         v1     = (vec_v1     + i*extra->offset[0]);
         v2     = (vec_v2     + i*extra->offset[1]);
         retval = (vec_retval + i*extra->offset[2]);

         *retval = vdist_c(v1, v2);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {
      v1     = vec_v1;
      v2     = vec_v2;
      retval = vec_retval;

      *retval = vdist_c(v1, v2);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void              vhat_c   ( ConstSpiceDouble    v1  [3],
                                SpiceDouble         vout[3] );
*/
void cspice_vhat(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_v1;
   SpiceDouble        * vec_vout;
   SpiceDouble        * v1;
   SpiceDouble        * vout;

   mwIndex              i;

   struct extra_dims  * extra;

   struct argcheck ArgCheck[] =
      {
      { "v1",   MiceDouble, 1, {3}, 1},
      { "vout", MiceDouble, 1, {3}, 1},
      };

   check_arg_num( nrhs, nlhs, 1, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_v1   = A_DBL_ARGV(1);
   vec_vout = A_DBL_RET_ARGV(0);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         v1   =  (vec_v1   + i*extra->offset[0]);
         vout =  (vec_vout + i*extra->offset[1]);

         vhat_c(v1, vout);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {

      v1   =  vec_v1;
      vout =  vec_vout;

      vhat_c(v1, vout);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void              vperp_c ( ConstSpiceDouble   a[3],
                               ConstSpiceDouble   b[3],
                               SpiceDouble        p[3] )

*/
void cspice_vperp(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_s1;
   SpiceDouble        * vec_s2;
   SpiceDouble        * vec_vout;
   SpiceDouble        * s1;
   SpiceDouble        * s2;
   SpiceDouble        * vout;

   mwIndex              i;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "a", MiceDouble, 1, {3}, 1},
      { "b", MiceDouble, 1, {3}, 1},
      { "p", MiceDouble, 1, {3}, 1},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_s1   = A_DBL_ARGV(1);
   vec_s2   = A_DBL_ARGV(2);
   vec_vout = A_DBL_RET_ARGV(0);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         s1   = (vec_s1   + i*extra->offset[0]);
         s2   = (vec_s2   + i*extra->offset[1]);
         vout = (vec_vout + i*extra->offset[2]);

         vperp_c(s1, s2, vout);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {
      s1   = vec_s1;
      s2   = vec_s2;
      vout = vec_vout;

      vperp_c(s1, s2, vout);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   SpiceDouble       vnorm_c   ( ConstSpiceDouble    v1[3] );
*/
void cspice_vnorm(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_v1;
   SpiceDouble        * v1;
   SpiceDouble        * vec_retval;
   SpiceDouble        * retval;

   mwIndex              i;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "v1",    MiceDouble, 1, {3}, 1},
      { "vnorm", MiceDouble, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 1, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_v1     = A_DBL_ARGV(1);
   vec_retval = A_DBL_RET_ARGV(0);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         v1     = (vec_v1     + i*extra->offset[0]);
         retval = (vec_retval + i*extra->offset[1]);

         *retval = vnorm_c(v1);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {
      v1     = vec_v1;
      retval = vec_retval;

      *retval = vnorm_c(v1);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void              vprjp_c  ( ConstSpiceDouble    vin   [3],
                                ConstSpicePlane   * plane,
                                SpiceDouble         vout  [3] );
*/
void cspice_vprjp(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vin;
   SpicePlane           plane;
   SpiceDouble        * vout;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "vin",   MiceDouble, 1, {3}, 0},
      { "plane", MicePlane,  0, {0}, 0},
      { "vout",  MiceDouble, 1, {3}, 0},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vin = A_DBL_ARGV(1);

   /*
   Assemble a plane structure from the input arguments.
   */
   memcpy( plane.normal,
           mxGetPr( mxGetField( prhs[2], 0,"normal") ),
           3*sizeof(SpiceDouble)
         );

   plane.constant = *mxGetPr( mxGetField( prhs[2], 0,"constant") );

   vout = A_DBL_RET_ARGV(0);

   (void)vprjp_c( vin, &plane, vout );
   CHECK_CALL_FAILURE( SCALAR );

   }




/*
   void              vprjpi_c ( ConstSpiceDouble    vin    [3],
                                ConstSpicePlane   * projpl,
                                ConstSpicePlane   * invpl,
                                SpiceDouble         vout   [3],
                                SpiceBoolean      * found       );
*/
void cspice_vprjpi(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vin;
   SpicePlane           projpl;
   SpicePlane           invpl;
   SpiceDouble        * vout;
   SpiceBoolean       * found;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "vin",    MiceDouble,  1, {3}, 0},
      { "projpl", MicePlane,   0, {0}, 0},
      { "invpl",  MicePlane,   0, {0}, 0},
      { "vout",   MiceDouble,  1, {3}, 0},
      { "found",  MiceBoolean, 0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 3, 2 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vin = A_DBL_ARGV(1);

   /*
   Assemble a plane structure from the input arguments.
   */
   memcpy( projpl.normal,
           mxGetPr( mxGetField( prhs[2], 0,"normal") ),
           3*sizeof(SpiceDouble)
         );

   projpl.constant = *mxGetPr( mxGetField( prhs[2], 0,"constant") );

   memcpy( invpl.normal,
           mxGetPr( mxGetField( prhs[3], 0,"normal") ),
           3*sizeof(SpiceDouble)
         );

   invpl.constant = *mxGetPr( mxGetField( prhs[3], 0,"constant") );

   vout   = A_DBL_RET_ARGV(0);
   found  = A_BOOL_RET_ARGV(1);

   (void)vprjpi_c( vin, &projpl, &invpl, vout, found );
   CHECK_CALL_FAILURE( SCALAR );

   }




/*
   void              vproj_c ( ConstSpiceDouble   a[3],
                               ConstSpiceDouble   b[3],
                               SpiceDouble        p[3] )

*/
void cspice_vproj(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_s1;
   SpiceDouble        * vec_s2;
   SpiceDouble        * vec_vout;
   SpiceDouble        * s1;
   SpiceDouble        * s2;
   SpiceDouble        * vout;

   mwIndex              i;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "a", MiceDouble, 1, {3}, 1},
      { "b", MiceDouble, 1, {3}, 1},
      { "p", MiceDouble, 1, {3}, 1},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_s1   = A_DBL_ARGV(1);
   vec_s2   = A_DBL_ARGV(2);
   vec_vout = A_DBL_RET_ARGV(0);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         s1   = (vec_s1   + i*extra->offset[0]);
         s2   = (vec_s2   + i*extra->offset[1]);
         vout = (vec_vout + i*extra->offset[2]);

         vproj_c(s1, s2, vout);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {
      s1   = vec_s1;
      s2   = vec_s2;
      vout = vec_vout;

      vproj_c(s1, s2, vout);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void vprojg_c ( ConstSpiceDouble    a      [],
                   ConstSpiceDouble    b      [],
                   SpiceInt            ndim,
                   SpiceDouble         p      [] )
*/
void cspice_vprojg(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   ConstSpiceDouble   * a;
   ConstSpiceDouble   * b;
   SpiceInt             ndim;
   SpiceDouble        * p;
   SpiceDouble        * ret_p;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "a",       MiceDouble,   1, {0},   0},
      { "b",       MiceDouble,   1, {0},   0},
      { "p",       MiceIgnore,   0, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   ndim     = mxGetNumberOfElements(prhs[1]);
   a        = (ConstSpiceDouble*)mxGetData(prhs[1]);

   if( ndim !=  (SpiceInt)mxGetNumberOfElements( prhs[2] ) )
      {
      mexErrMsgTxt( "MICE(INVALIDSIZE): Array `b` must have the same "
                             "measure of vectorization as `a`" );
      }
   b        = (ConstSpiceDouble*)mxGetData(prhs[2]);

   ret_p = (SpiceDouble*) mxMalloc( ndim * sizeof(SpiceDouble) );

   vprojg_c ( a, b, ndim, ret_p );

   /*
   Check for a failure signal. Free the memory assigned to `ret_p'
   before signaling a Matlab error.
   */
   if ( failed_c())
      {
      mxFree( ret_p );

      /*
      The mice_fail call creates the error string then returns control
      to the MATLAB interpreter.
      */
      mice_fail(SCALAR);
      }

   /*
   Allocate the needed memory to return a vector of size `ndim'
   to MATLAB.
   */
   plhs[0]  = mxCreateDoubleMatrix( ndim, 1, mxREAL );
   p     = A_DBL_RET_ARGV(0);
   MOVED( ret_p, ndim, p );
   mxFree( ret_p );

   }




/*
   void              vrotv_c  ( ConstSpiceDouble    v    [3],
                                ConstSpiceDouble    axis [3],
                                SpiceDouble         theta,
                                SpiceDouble         r    [3] );
*/
void cspice_vrotv(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * v;
   SpiceDouble        * axis;
   SpiceDouble          theta;
   SpiceDouble        * r;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "v",     MiceDouble, 1, {3}, 0},
      { "axis",  MiceDouble, 1, {3}, 0},
      { "theta", MiceDouble, 0, {0}, 0},
      { "r",     MiceDouble, 1, {3}, 0},
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   v      = A_DBL_ARGV(1);
   axis   = A_DBL_ARGV(2);
   theta  = S_DBL_ARGV(3);
   r      = A_DBL_RET_ARGV(0);

   vrotv_c( v, axis, theta, r );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   SpiceDouble       vsep_c   ( ConstSpiceDouble    v1[3],
                                ConstSpiceDouble    v2[3] );
*/
void cspice_vsep(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_v1;
   SpiceDouble        * vec_v2;
   SpiceDouble        * v1;
   SpiceDouble        * v2;
   SpiceDouble        * retval;
   SpiceDouble        * vec_retval;

   mwIndex              i;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "v1",   MiceDouble, 1, {3}, 1},
      { "v2",   MiceDouble, 1, {3}, 1},
      { "vsep", MiceDouble, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_v1     = A_DBL_ARGV(1);
   vec_v2     = A_DBL_ARGV(2);
   vec_retval = A_DBL_RET_ARGV(0);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         v1     = (vec_v1     + i*extra->offset[0]);
         v2     = (vec_v2     + i*extra->offset[1]);
         retval = (vec_retval + i*extra->offset[2]);

         *retval = vsep_c(v1, v2);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {
      v1     = vec_v1;
      v2     = vec_v2;
      retval = vec_retval;

      *retval = vsep_c(v1, v2);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void vupack_c ( ConstSpiceDouble     v[3],
                   SpiceDouble        * x,
                   SpiceDouble        * y,
                   SpiceDouble        * z     )
*/
void cspice_vupack(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * v;
   SpiceDouble        * x;
   SpiceDouble        * y;
   SpiceDouble        * z;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "v",       MiceDouble,   1, {3},   0},
      { "x",       MiceDouble,   0, {0},   0},
      { "y",       MiceDouble,   0, {0},   0},
      { "z",       MiceDouble,   0, {0},   0},
      };

   check_arg_num( nrhs, nlhs, 1, 3 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   v        = A_DBL_ARGV(1);

   x        = A_DBL_RET_ARGV(0);
   y        = A_DBL_RET_ARGV(1);
   z        = A_DBL_RET_ARGV(2);

   vupack_c ( v, x, y, z );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   SpiceInt          wncard_c ( SpiceCell          * window );

*/
void cspice_wncard(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble       * window;
   SpiceInt            card;

   SpiceInt            window_size;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "window", MiceWin,    1, {0}, 0},
      { "wncard", MiceIgnore, 0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 1, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   window = (SpiceDouble*)mxGetData(prhs[1]);

   /*
   The size of array 'window' includes an addition SPICE_CELL_CTRLSZ
   zero elements appended to the arrays. Calculate the size of 'window'
   without the append size.
   */
   window_size = mxGetNumberOfElements( prhs[1] ) - SPICE_CELL_CTRLSZ;

   /*
   The interface wrapper appended a 6x1 zeros array to
   'window' to provide a control segment. Use of the
   SPICE window routines requires this operation. Add
   size and cardinality values to this control segment.
   */
   ssized_( ( integer * ) &window_size, ( double * ) window );
   scardd_( ( integer * ) &window_size, ( double * ) window );

   card = wncard_( ( doublereal * ) window );
   CHECK_CALL_FAILURE(SCALAR);

   plhs[0] =  zzmice_CreateIntScalar(card) ;

   }




/*
   void              wncomd_c ( SpiceDouble          left,
                                SpiceDouble          right,
                                SpiceCell          * window,
                                SpiceCell          * result );
*/
void cspice_wncomd(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble          left;
   SpiceDouble          right;
   SpiceDouble        * window;
   SpiceDouble        * result;
   SpiceDouble        * result_f;

   SpiceInt             card = 0;
   SpiceInt             window_size;
   SpiceInt             size;

   mwSize               sizearray[2];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "left",     MiceDouble, 0, {0}, 0},
      { "right",    MiceDouble, 0, {0}, 0},
      { "window_i", MiceWin,    1, {0}, 0},
      { "result",   MiceIgnore, 0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 3, 1);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   left   = S_DBL_ARGV(1);
   right  = S_DBL_ARGV(2);
   window = (SpiceDouble*)mxGetData(prhs[3]);

   /*
   The size of array 'window' includes an addition SPICE_CELL_CTRLSZ
   zero elements appended to the arrays. Calculate the size of
   'window' without the append size.
   */
   window_size = mxGetNumberOfElements( prhs[3] ) - SPICE_CELL_CTRLSZ;

   /*
   The interface wrapper appended a 6x1 zeros array to
   'a' and 'b' to provide a control segment. Use of the
   SPICE window routines requires this operation. Add
   size and cardinality values to this control segment.
   */
   ssized_( ( integer * ) &window_size, ( double * ) window );
   scardd_( ( integer * ) &window_size, ( double * ) window );


   /*
   Allocate the memory for the return window, provide the needed room
   for the control segment.

   The maximum size of the output window 'return' equals no more than
   the size of 'window' plus 2.
   */
   size = window_size + 2;

   result = (SpiceDouble*)
             mxMalloc( (size + SPICE_CELL_CTRLSZ)*sizeof(SpiceDouble)  );

   /*
   Set to size and cardinality for the 'return' before passing to CSPICE.
   */
   ssized_( ( integer * ) &size, ( double * ) result );
   scardd_( ( integer * ) &card, ( double * ) result );

   wncomd_ ( (doublereal * ) &left,
             (doublereal * ) &right,
             (doublereal * ) (window),
             (doublereal * ) (result) );

   /*
   Check for a failure signal. Free the memory assigned to 'result'
   before signaling a Matlab error.
   */
   if ( failed_c())
      {
      mxFree( result );

      /*
      The mice_fail call creates the error string then returns control
      to the MATLAB interpreter.
      */
      mice_fail(SCALAR);
      }

   /*
   Array element 6, index 5, contains the cell cardinality. Create an output
   array CARDx1.
   */
   sizearray[0] = result[5];
   sizearray[1] = 1;

   plhs[0]  = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
   result_f = A_DBL_RET_ARGV(0);

   /*
   Copy the data contents of 'result' to 'result_f'. The set of window data
   starts at 'cover' array index SPICE_CELL_CTRLSZ and contains 'result[5]'
   elements.
   */
   MOVED( result + SPICE_CELL_CTRLSZ, result[5], result_f );
   mxFree( result );

   }






/*
   void              wndifd_c ( SpiceCell          * a,
                                SpiceCell          * b,
                                SpiceCell          * c  );
*/
void cspice_wndifd(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * a;
   SpiceDouble        * b;
   SpiceDouble        * c;
   SpiceDouble        * c_f;

   SpiceInt            card = 0;
   SpiceInt            size;

   SpiceInt            a_size;
   SpiceInt            b_size;
   mwSize              sizearray[2];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "a",    MiceWin,    1, {0}, 0},
      { "b",    MiceWin,    1, {0}, 0},
      { "c",    MiceIgnore, 0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 2, 1);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   a = (SpiceDouble*)mxGetData(prhs[1]);
   b = (SpiceDouble*)mxGetData(prhs[2]);

   /*
   The size of array 'a' and 'b' includes an addition SPICE_CELL_CTRLSZ
   zero elements appended to the arrays. Calculate the size of 'a'
   and 'b' without the append size.
   */
   a_size = mxGetNumberOfElements( prhs[1] ) - SPICE_CELL_CTRLSZ;
   b_size = mxGetNumberOfElements( prhs[2] ) - SPICE_CELL_CTRLSZ;

   /*
   The maximum size of the output window 'c' equals no more than
   the size of 'a' plus the size of 'b'.
   */
   size =  a_size + b_size;

   /*
   The interface wrapper appended a 6x1 zeros array to
   'a' and 'b' to provide a control segment. Use of the
   SPICE window routines requires this operation. Add
   size and cardinality values to this control segment.
   */
   ssized_( ( integer * ) &a_size, ( double * ) a );
   scardd_( ( integer * ) &a_size, ( double * ) a );

   ssized_( ( integer * ) &b_size, ( double * ) b );
   scardd_( ( integer * ) &b_size, ( double * ) b );

   c = (SpiceDouble*)
        mxMalloc( (size + SPICE_CELL_CTRLSZ)*sizeof(SpiceDouble)  );

   ssized_( ( integer * ) &size, ( double * ) c );
   scardd_( ( integer * ) &card, ( double * ) c );

   wndifd_(  (doublereal *) (a),
             (doublereal *) (b),
             (doublereal *) (c));

   /*
   Check for a failure signal. Free the memory assigned to 'c'
   before signaling a Matlab error.
   */
   if ( failed_c())
      {
      mxFree( c );

      /*
      The mice_fail call creates the error string then returns control
      to the MATLAB interpreter.
      */
      mice_fail(SCALAR);
      }

   /*
   Array element 6, index 5, contains the cell cardinality. Create an output
   array CARDx1.
   */
   sizearray[0] = c[5];
   sizearray[1] = 1;

   plhs[0] = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
   c_f     = A_DBL_RET_ARGV(0);

   /*
   Copy the data contents of 'c' to 'c_f'. The set of window data
   starts at 'cover' array index SPICE_CELL_CTRLSZ and contains 'c[5]'
   elements.
   */
   MOVED( c + SPICE_CELL_CTRLSZ, c[5], c_f );
   mxFree( c );

   }




/*
   SpiceBoolean      wnelmd_c ( SpiceDouble          point,
                                SpiceCell          * window );
*/
void cspice_wnelmd(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble       * window;
   SpiceDouble         point;

   SpiceInt            window_size;
   SpiceBoolean      * retval;

   struct extra_dims * extra;
   struct argcheck ArgCheck[] =
      {
      { "point",  MiceDouble,  0, {0}, 0},
      { "window", MiceWin,     1, {0}, 0},
      { "wnelmd", MiceBoolean, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   point   = S_DBL_ARGV(1);
   window = (SpiceDouble*)mxGetData(prhs[2]);
   retval = A_BOOL_RET_ARGV(0);

   /*
   The size of array 'window' includes an addition SPICE_CELL_CTRLSZ
   zero elements appended to the arrays. Calculate the size of 'window'
   without the append size.
   */
   window_size = mxGetNumberOfElements( prhs[2] ) - SPICE_CELL_CTRLSZ;

   /*
   The interface wrapper appended a 6x1 zeros array to
   'window' to provide a control segment. Use of the
   SPICE window routines requires this operation.
   */
   ssized_( ( integer * ) &window_size, ( double * ) window );
   scardd_( ( integer * ) &window_size, ( double * ) window );

   *retval = wnelmd_( (doublereal * ) &point,
                      (doublereal * ) (window) );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              wnexpd_c ( SpiceDouble          left,
                                SpiceDouble          right,
                                SpiceCell          * window );
*/
void cspice_wnexpd(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble          left;
   SpiceDouble          right;
   SpiceDouble        * window_i;
   SpiceDouble        * window;
   SpiceDouble        * window_f;

   SpiceInt            size;
   mwSize              sizearray[2];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "left",     MiceDouble, 0, {0}, 0},
      { "right",    MiceDouble, 0, {0}, 0},
      { "window_i", MiceWin,    1, {0}, 0},
      { "window_f", MiceIgnore, 0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 3, 1);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   left     = S_DBL_ARGV(1);
   right    = S_DBL_ARGV(2);
   window_i = (SpiceDouble*)mxGetData(prhs[3]);

   /*
   Calculate the size of 'window_i'. This corresponds to a CSPICE window
   size and cardinality for this case

   The maximum size of the work window 'window' equals no more than
   the size of 'window_i'.
   */
   size = mxGetNumberOfElements( prhs[3] );

   /*
   Allocate the memory for the window, provide the needed room for the
   control segment.
   */
   window = (SpiceDouble*)
             mxMalloc( (size + SPICE_CELL_CTRLSZ)*sizeof(SpiceDouble)  );

   /*
   Set to size and cardinality for the window before passing to CSPICE.
   */
   ssized_( ( integer * ) &size, ( double * ) window );
   scardd_( ( integer * ) &size, ( double * ) window );

   /*
   Copy the window data from the input window to the work window. The
   window data should begin at 'window' element SPICE_CELL_CTRLSZ.
   */
   MOVED( window_i, size,  window  + SPICE_CELL_CTRLSZ);

   wnexpd_ ( (doublereal * )  &left,
             (doublereal * )  &right,
             (doublereal * )  (window) );

   /*
   Check for a failure signal. Free the memory assigned to 'window'
   before signaling a Matlab error.
   */
   if ( failed_c())
      {
      mxFree( window );

      /*
      The mice_fail call creates the error string then returns control
      to the MATLAB interpreter.
      */
      mice_fail(SCALAR);
      }

   /*
   Array element 6, index 5, contains the cell cardinality. Create an output
   array CARDx1.
   */
   sizearray[0] = window[5];
   sizearray[1] = 1;

   plhs[0]  = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
   window_f = A_DBL_RET_ARGV(0);

   /*
   Copy the data contents of 'window' to 'window_f'. The set of window data
   starts at 'cover' array index SPICE_CELL_CTRLSZ and contains 'window[5]'
   elements.
   */
   MOVED( window + SPICE_CELL_CTRLSZ, window[5], window_f );
   mxFree( window );

   }




/*
   void              wnextd_c ( SpiceChar            side,
                                SpiceCell          * window );
*/
void cspice_wnextd(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            side[DEFAULT_STR_LENGTH+1];
   SpiceDouble        * window_i;
   SpiceDouble        * window;
   SpiceDouble        * window_f;

   SpiceInt            size;
   mwSize              sizearray[2];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "side",     MiceChar,   0, {0}, 0},
      { "window_i", MiceWin,    1, {0}, 0},
      { "window_f", MiceIgnore, 0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 2, 1);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], side, DEFAULT_STR_LENGTH);
   window_i = (SpiceDouble*)mxGetData(prhs[2]);

   /*
   Calculate the size of 'window_i'. This corresponds to a CSPICE window
   size and cardinality for this case

   The maximum size of the work window 'window' equals no more than
   the size of 'window_i'.
   */
   size = mxGetNumberOfElements( prhs[2] );

   /*
   Allocate the memory for the window, provide the needed room for the
   control segment.
   */
   window = (SpiceDouble*)
             mxMalloc( (size + SPICE_CELL_CTRLSZ)*sizeof(SpiceDouble)  );

   /*
   Set to size and cardinality for the window before passing to CSPICE.
   */
   ssized_( ( integer * ) &size, ( double * ) window );
   scardd_( ( integer * ) &size, ( double * ) window );

   /*
   Copy the window data from the input window to the work window. The
   window data should begin at 'window' element SPICE_CELL_CTRLSZ.
   */
   MOVED( window_i, size,  window  + SPICE_CELL_CTRLSZ);

   wnextd_ ( ( char       * ) &side,
             ( doublereal * ) window,
             ( ftnlen       ) 1 );

   /*
   Check for a failure signal. Free the memory assigned to 'window'
   before signaling a Matlab error.
   */
   if ( failed_c())
      {
      mxFree( window );

      /*
      The mice_fail call creates the error string then returns control
      to the MATLAB interpreter.
      */
      mice_fail(SCALAR);
      }

   /*
   Array element 6, index 5, contains the cell cardinality. Create an output
   array CARDx1.
   */
   sizearray[0] = window[5];
   sizearray[1] = 1;

   plhs[0]  = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
   window_f = A_DBL_RET_ARGV(0);

   /*
   Copy the data contents of 'window' to 'window_f'. The set of window data
   starts at 'cover' array index SPICE_CELL_CTRLSZ and contains 'window[5]'
   elements.
   */
   MOVED( window + SPICE_CELL_CTRLSZ, window[5], window_f );
   mxFree( window );

   }




/*
   void              wnfetd_c ( SpiceCell          * window,
                                SpiceInt             n,
                                SpiceDouble        * left,
                                SpiceDouble        * right   );
*/
void cspice_wnfetd(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble       * window;
   SpiceDouble       * left;
   SpiceDouble       * right;

   SpiceInt            n;
   SpiceInt            window_size;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "window", MiceWin,     1, {0}, 0},
      { "n",      MiceInt,     0, {0}, 0},
      { "left",   MiceDouble,  0, {0}, 0},
      { "right",  MiceDouble,  0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 2, 2 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   window = (SpiceDouble*)mxGetData(prhs[1]);
   n      = S_INT_ARGV(2);
   left   = A_DBL_RET_ARGV(0);
   right  = A_DBL_RET_ARGV(1);

   /*
   The size of array 'window' includes an addition SPICE_CELL_CTRLSZ
   zero elements appended to the arrays. Calculate the size of 'window'
   without the append size.
   */
   window_size = mxGetNumberOfElements( prhs[1] ) - SPICE_CELL_CTRLSZ;

   /*
   The interface wrapper appended a 6x1 zeros array to
   'window' to provide a control segment. Use of the
   SPICE window routines requires this operation.
   */
   ssized_( ( integer * ) &window_size, ( double * ) window );
   scardd_( ( integer * ) &window_size, ( double * ) window );

   wnfetd_ ( ( doublereal * ) window,
             ( integer    * ) &n,
             ( doublereal * ) left,
             ( doublereal * ) right );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              wnfild_c ( SpiceDouble          smlgap,
                                SpiceCell          * window );
*/
void cspice_wnfild(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble          smlgap;
   SpiceDouble        * window_i;
   SpiceDouble        * window;
   SpiceDouble        * window_f;

   SpiceInt            size;
   mwSize              sizearray[2];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "smlgap",   MiceDouble, 0, {0}, 0},
      { "window_i", MiceWin,    1, {0}, 0},
      { "window_f", MiceIgnore, 0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 2, 1);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   smlgap   = S_DBL_ARGV(1);
   window_i = (SpiceDouble*)mxGetData(prhs[2]);

   /*
   Calculate the size of 'window_i'. This corresponds to a CSPICE window
   size and cardinality for this case

   The maximum size of the work window 'window' equals no more than
   the size of 'window_i'.
   */
   size = mxGetNumberOfElements( prhs[2] );

   /*
   Allocate the memory for the window, provide the needed room for the
   control segment.
   */
   window = (SpiceDouble*)
             mxMalloc( (size + SPICE_CELL_CTRLSZ)*sizeof(SpiceDouble)  );

   /*
   Set to size and cardinality for the window before passing to CSPICE.
   */
   ssized_( ( integer * ) &size, ( double * ) window );
   scardd_( ( integer * ) &size, ( double * ) window );

   /*
   Copy the window data from the input window to the work window. The
   window data should begin at 'window' element SPICE_CELL_CTRLSZ.
   */
   MOVED( window_i, size,  window  + SPICE_CELL_CTRLSZ);

   wnfild_ ( (doublereal * )  &smlgap,
             (doublereal * )  (window) );

   /*
   Check for a failure signal. Free the memory assigned to 'window'
   before signaling a Matlab error.
   */
   if ( failed_c())
      {
      mxFree( window );

      /*
      The mice_fail call creates the error string then returns control
      to the MATLAB interpreter.
      */
      mice_fail(SCALAR);
      }

   /*
   Array element 6, index 5, contains the cell cardinality. Create an output
   array CARDx1.
   */
   sizearray[0] = window[5];
   sizearray[1] = 1;

   plhs[0]  = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
   window_f = A_DBL_RET_ARGV(0);

   /*
   Copy the data contents of 'window' to 'window_f'. The set of window data
   starts at 'cover' array index SPICE_CELL_CTRLSZ and contains 'window[5]'
   elements.
   */
   MOVED( window + SPICE_CELL_CTRLSZ, window[5], window_f );
   mxFree( window );

   }




/*
   void              wnfltd_c ( SpiceDouble          smlint,
                                SpiceCell          * window );
*/
void cspice_wnfltd(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble          smlint;
   SpiceDouble        * window_i;
   SpiceDouble        * window;
   SpiceDouble        * window_f;

   SpiceInt            size;
   mwSize              sizearray[2];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "smlint",   MiceDouble, 0, {0}, 0},
      { "window_i", MiceWin,    1, {0}, 0},
      { "window_f", MiceIgnore, 0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 2, 1);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   smlint   = S_DBL_ARGV(1);
   window_i = (SpiceDouble*)mxGetData(prhs[2]);

   /*
   Calculate the size of 'window_i'. This corresponds to a CSPICE window
   size and cardinality for this case

   The maximum size of the work window 'window' equals no more than
   the size of 'window_i'.
   */
   size = mxGetNumberOfElements( prhs[2] );

   /*
   Allocate the memory for the window, provide the needed room for the
   control segment.
   */
   window = (SpiceDouble*)
             mxMalloc( (size + SPICE_CELL_CTRLSZ)*sizeof(SpiceDouble)  );

   /*
   Set to size and cardinality for the window before passing to CSPICE.
   */
   ssized_( ( integer * ) &size, ( double * ) window );
   scardd_( ( integer * ) &size, ( double * ) window );

   /*
   Copy the window data from the input window to the work window. The
   window data should begin at 'window' element SPICE_CELL_CTRLSZ.
   */
   MOVED( window_i, size,  window  + SPICE_CELL_CTRLSZ);

   wnfltd_ ( (doublereal * )  &smlint,
             (doublereal * )  (window) );

   /*
   Check for a failure signal. Free the memory assigned to 'window'
   before signaling a Matlab error.
   */
   if ( failed_c())
      {
      mxFree( window );

      /*
      The mice_fail call creates the error string then returns control
      to the MATLAB interpreter.
      */
      mice_fail(SCALAR);
      }

   /*
   Array element 6, index 5, contains the cell cardinality. Create an output
   array CARDx1.
   */
   sizearray[0] = window[5];
   sizearray[1] = 1;

   plhs[0]  = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
   window_f = A_DBL_RET_ARGV(0);

   /*
   Copy the data contents of 'window' to 'window_f'. The set of window data
   starts at 'cover' array index SPICE_CELL_CTRLSZ and contains 'window[5]'
   elements.
   */
   MOVED( window + SPICE_CELL_CTRLSZ, window[5], window_f );
   mxFree( window );

   }




/*
   SpiceBoolean      wnincd_c ( SpiceDouble          left,
                                SpiceDouble          right,
                                SpiceCell          * window  );
*/
void cspice_wnincd(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble         left;
   SpiceDouble         right;
   SpiceDouble       * window;

   SpiceInt            window_size;
   SpiceBoolean      * retval;

   struct extra_dims * extra;
   struct argcheck ArgCheck[] =
      {
      { "left",   MiceDouble,  0, {0}, 0},
      { "right",  MiceDouble,  0, {0}, 0},
      { "window", MiceWin,     1, {0}, 0},
      { "wnincd", MiceBoolean, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   left   = S_DBL_ARGV(1);
   right  = S_DBL_ARGV(2);
   window = (SpiceDouble*)mxGetData(prhs[3]);
   retval = A_BOOL_RET_ARGV(0);

   /*
   The size of array 'window' includes an addition SPICE_CELL_CTRLSZ
   zero elements appended to the arrays. Calculate the size of 'window'
   without the append size.
   */
   window_size = mxGetNumberOfElements( prhs[3] ) - SPICE_CELL_CTRLSZ;

   /*
   The interface wrapper appended a 6x1 zeros array to
   'window' to provide a control segment. Use of the
   SPICE window routines requires this operation.
   */
   ssized_( ( integer * ) &window_size, ( double * ) window );
   scardd_( ( integer * ) &window_size, ( double * ) window );

   *retval = wnincd_( (doublereal *) &left,
                      (doublereal *) &right,
                      (doublereal *) (window) );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              wninsd_c ( SpiceDouble          left,
                                SpiceDouble          right,
                                SpiceCell          * window );
*/
void cspice_wninsd(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble         left;
   SpiceDouble         right;

   SpiceInt            card;
   SpiceInt            size;

   mwSize              sizearray[2];

   SpiceDouble        * window;
   SpiceDouble        * window_f;

   struct extra_dims * extra;
   struct argcheck ArgCheck[] =
      {
      { "left",   MiceDouble,  0, {0}, 0},
      { "right",  MiceDouble,  0, {0}, 0},
      { "window", MiceIgnore,  0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   left   = S_DBL_ARGV(1);
   right  = S_DBL_ARGV(2);

   /*
   The insert creates a new window with two elements.
   */
   card   = 0;
   size   = 2;

   window = (SpiceDouble*)
             mxMalloc( (size + SPICE_CELL_CTRLSZ)*sizeof(SpiceDouble)  );

   ssized_( ( integer * ) &size, ( double * ) window );
   scardd_( ( integer * ) &card, ( double * ) window );

   wninsd_ ( (doublereal * )  &left,
             (doublereal * )  &right,
             (doublereal * )  (window) );

   /*
   Check for a failure signal. Free the memory assigned to 'window'
   before signaling a Matlab error.
   */
   if ( failed_c())
      {
      mxFree( window );

      /*
      The mice_fail call creates the error string then returns control
      to the MATLAB interpreter.
      */
      mice_fail(SCALAR);
      }

   /*
   Array element 6, index 5, contains the cell cardinality. Create an output
   array CARDx1.
   */
   sizearray[0] = window[5];
   sizearray[1] = 1;

   plhs[0]  = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
   window_f = A_DBL_RET_ARGV(0);

   /*
   Copy the data contents of 'cover' to 'cover_f'. The set of window data
   starts at 'cover' array index SPICE_CELL_CTRLSZ and contains 'cover[5]'
   elements.
   */
   MOVED( window + SPICE_CELL_CTRLSZ, window[5], window_f );
   mxFree( window );

   }




/*
   void              wnintd_c ( SpiceCell          * a,
                                SpiceCell          * b,
                                SpiceCell          * c  );
*/
void cspice_wnintd(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * a;
   SpiceDouble        * b;
   SpiceDouble        * c;
   SpiceDouble        * c_f;

   SpiceInt            card = 0;
   SpiceInt            size;

   SpiceInt            a_size;
   SpiceInt            b_size;
   mwSize              sizearray[2];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "a",    MiceWin,    1, {0}, 0},
      { "b",    MiceWin,    1, {0}, 0},
      { "c",    MiceIgnore, 0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 2, 1);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   a = (SpiceDouble*)mxGetData(prhs[1]);
   b = (SpiceDouble*)mxGetData(prhs[2]);

   /*
   The size of array 'a' and 'b' includes an addition SPICE_CELL_CTRLSZ
   zero elements appended to the arrays. Calculate the size of 'a'
   and 'b' without the append size.
   */
   a_size = mxGetNumberOfElements( prhs[1] ) - SPICE_CELL_CTRLSZ;
   b_size = mxGetNumberOfElements( prhs[2] ) - SPICE_CELL_CTRLSZ;

   /*
   The maximum size of the output window 'c' equals no more than
   the size of 'a' plus the size of 'b' (I think the proper value
   equals "size_a + size_b - 1" ).
   */
   size =  a_size + b_size;

   /*
   The interface wrapper appended a 6x1 zeros array to
   'a' and 'b' to provide a control segment. Use of the
   SPICE window routines requires this operation.
   */
   ssized_( ( integer * ) &a_size, ( double * ) a );
   scardd_( ( integer * ) &a_size, ( double * ) a );

   ssized_( ( integer * ) &b_size, ( double * ) b );
   scardd_( ( integer * ) &b_size, ( double * ) b );

   c = (SpiceDouble*)
        mxMalloc( (size + SPICE_CELL_CTRLSZ)*sizeof(SpiceDouble)  );

   ssized_( ( integer * ) &size, ( double * ) c );
   scardd_( ( integer * ) &card, ( double * ) c );

   wnintd_(  (doublereal *) (a),
             (doublereal *) (b),
             (doublereal *) (c));

   /*
   Check for a failure signal. Free the memory assigned to 'c'
   before signaling a Matlab error.
   */
   if ( failed_c())
      {
      mxFree( c );

      /*
      The mice_fail call creates the error string then returns control
      to the MATLAB interpreter.
      */
      mice_fail(SCALAR);
      }

   /*
   Array element 6, index 5, contains the cell cardinality. Create an output
   array CARDx1.
   */
   sizearray[0] = c[5];
   sizearray[1] = 1;

   plhs[0] = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
   c_f     = A_DBL_RET_ARGV(0);

   /*
   Copy the data contents of 'c' to 'c_f'. The set of window data
   starts at 'cover' array index SPICE_CELL_CTRLSZ and contains 'c[5]'
   elements.
   */
   MOVED( c + SPICE_CELL_CTRLSZ, c[5], c_f );
   mxFree( c );

   }




/*
   SpiceBoolean      wnreld_c ( SpiceCell          * a,
                                ConstSpiceChar     * op,
                                SpiceCell          * b   );
*/
void cspice_wnreld(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {
   SpiceDouble        * a;
   SpiceDouble        * b;

   SpiceChar            op[DEFAULT_STR_LENGTH+1];

   SpiceInt            a_size;
   SpiceInt            b_size;
   SpiceBoolean      * retval;

   struct extra_dims * extra;
   struct argcheck ArgCheck[] =
      {
      { "a",      MiceWin,     1, {0}, 0},
      { "op",     MiceChar,    0, {0}, 0},
      { "b",      MiceWin,     1, {0}, 0},
      { "wnreld", MiceBoolean, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   a      = (SpiceDouble*)mxGetData(prhs[1]);

   mxGetString(prhs[2], op, MAXLEN);

   b      = (SpiceDouble*)mxGetData(prhs[3]);
   retval = A_BOOL_RET_ARGV(0);

   /*
   The size of array 'a' and 'b' includes an addition SPICE_CELL_CTRLSZ
   zero elements appended to the arrays. Calculate the size of 'a'
   and 'b' without the append size.
   */
   a_size = mxGetNumberOfElements( prhs[1] ) - SPICE_CELL_CTRLSZ;
   b_size = mxGetNumberOfElements( prhs[3] ) - SPICE_CELL_CTRLSZ;

  /*
   The interface wrapper appended a 6x1 zeros array to
   'a' and 'b' to provide a control segment. Use of the
   SPICE window routines requires this operation.
   */
   ssized_( ( integer * ) &a_size, ( double * ) a );
   scardd_( ( integer * ) &a_size, ( double * ) a );

   ssized_( ( integer * ) &b_size, ( double * ) b );
   scardd_( ( integer * ) &b_size, ( double * ) b );

   *retval = wnreld_( (doublereal * ) (a),
                      (char       * ) op,
                      (doublereal * ) (b),
                      (ftnlen       ) strlen(op)  );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              wnsumd_c ( SpiceCell      * window,
                                SpiceDouble    * meas,
                                SpiceDouble    * avg,
                                SpiceDouble    * stddev,
                                SpiceInt       * idxsml,
                                SpiceInt       * idxlon   )
*/
void mice_wnsumd(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble       * window;
   SpiceDouble         meas;
   SpiceDouble         avg;
   SpiceDouble         stddev;
   SpiceInt            idxsml;
   SpiceInt            idxlon;

   SpiceInt            window_size;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "window", MiceWin,    1, {0}, 0},
      { "wnsumd", MiceWnsumd, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 1, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   window = (SpiceDouble*)mxGetData(prhs[1]);

   /*
   The size of array 'window' includes an addition SPICE_CELL_CTRLSZ
   zero elements appended to the arrays. Calculate the size of 'window'
   without the append size.
   */
   window_size = mxGetNumberOfElements( prhs[1] ) - SPICE_CELL_CTRLSZ;

   /*
   The interface wrapper appended a 6x1 zeros array to
   'window' to provide a control segment. Use of the
   SPICE window routines requires this operation.
   */
   ssized_( ( integer * ) &window_size, ( double * ) window );
   scardd_( ( integer * ) &window_size, ( double * ) window );

   wnsumd_ ( ( doublereal * ) window,
             ( doublereal * ) &meas,
             ( doublereal * ) &avg,
             ( doublereal * ) &stddev,
             ( integer    * ) &idxsml,
             ( integer    * ) &idxlon );
   CHECK_CALL_FAILURE(SCALAR);

   /*
   Copy the state vector and the lighttime value into the return structure.
   */

   mxDestroyArray( mxGetField( plhs[0], 0, "meas" ) );
   mxSetField( plhs[0], 0, "meas", mxCreateDoubleScalar(meas) );

   mxDestroyArray( mxGetField( plhs[0], 0, "avg" ) );
   mxSetField( plhs[0], 0, "avg", mxCreateDoubleScalar(avg) );

   mxDestroyArray( mxGetField( plhs[0], 0, "stddev" ) );
   mxSetField( plhs[0], 0, "stddev", mxCreateDoubleScalar(stddev) );

   mxDestroyArray( mxGetField( plhs[0], 0, "idxsml" ) );
   mxSetField( plhs[0], 0, "idxsml", zzmice_CreateIntScalar(idxsml) );

   mxDestroyArray( mxGetField( plhs[0], 0, "idxlon" ) );
   mxSetField( plhs[0], 0, "idxlon", zzmice_CreateIntScalar(idxlon) );

   }




/*
   void              wnunid_c ( SpiceCell          * a,
                                SpiceCell          * b,
                                SpiceCell          * c  );
*/
void cspice_wnunid(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * a;
   SpiceDouble        * b;
   SpiceDouble        * c;
   SpiceDouble        * c_f;

   SpiceInt            card = 0;
   SpiceInt            size;

   SpiceInt            a_size;
   SpiceInt            b_size;
   mwSize              sizearray[2];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "a",    MiceWin,    1, {0}, 0},
      { "b",    MiceWin,    1, {0}, 0},
      { "c",    MiceIgnore, 0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 2, 1);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   a = (SpiceDouble*)mxGetData(prhs[1]);
   b = (SpiceDouble*)mxGetData(prhs[2]);

   /*
   The size of array 'a' and 'b' includes an addition SPICE_CELL_CTRLSZ
   zero elements appended to the arrays. Calculate the size of 'a'
   and 'b' without the append size.
   */
   a_size = mxGetNumberOfElements( prhs[1] ) - SPICE_CELL_CTRLSZ;
   b_size = mxGetNumberOfElements( prhs[2] ) - SPICE_CELL_CTRLSZ;

   /*
   The maximum size of the output window 'c' equals no more than
   the size of 'a' plus the size of 'b' (when 'a' and 'b' do not
   intersect).
   */
   size = a_size + b_size;

   /*
   The interface wrapper appended a 6x1 zeros array to
   'a' and 'b' to provide a control segment. Use of the
   SPICE window routines requires this operation.
   */
   ssized_( ( integer * ) &a_size, ( double * ) a );
   scardd_( ( integer * ) &a_size, ( double * ) a );

   ssized_( ( integer * ) &b_size, ( double * ) b );
   scardd_( ( integer * ) &b_size, ( double * ) b );

   c = (SpiceDouble*)
        mxMalloc( (size + SPICE_CELL_CTRLSZ)*sizeof(SpiceDouble) );

   ssized_( ( integer * ) &size, ( double * ) c );
   scardd_( ( integer * ) &card, ( double * ) c );

   wnunid_(  (doublereal *) (a),
             (doublereal *) (b),
             (doublereal *) (c));

   /*
   Check for a failure signal. Free the memory assigned to 'c'
   before signaling a Matlab error.
   */
   if ( failed_c())
      {
      mxFree( c );

      /*
      The mice_fail call creates the error string then returns control
      to the MATLAB interpreter.
      */
      mice_fail(SCALAR);
      }

   /*
   Array element 6, index 5, contains the cell cardinality. Create an output
   array CARDx1.
   */
   sizearray[0] = c[5];
   sizearray[1] = 1;

   plhs[0] = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
   c_f     = A_DBL_RET_ARGV(0);

   /*
   Copy the data contents of 'c' to 'c_f'. The set of window data
   starts at 'cover' array index SPICE_CELL_CTRLSZ and contains 'c[5]'
   elements.
   */
   MOVED( c + SPICE_CELL_CTRLSZ, c[5], c_f );
   mxFree( c );

   }




/*
   void              wnvald_c ( SpiceInt             size,
                                SpiceInt             n,
                                SpiceCell          * window );

*/
void cspice_wnvald(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * window_i;
   SpiceDouble        * window;
   SpiceDouble        * window_f;

   SpiceInt            size;
   mwSize              sizearray[2];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "window_i",    MiceWin,    1, {0}, 0},
      { "window_f",    MiceIgnore, 0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 1, 1);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   window_i = (SpiceDouble*)mxGetData(prhs[1]);

   /*
   Calculate the size of 'window_i'. This corresponds to a CSPICE window
   size and cardinality for this case

   The maximum size of the work window 'window' equals no more than
   the size of 'window_i'.
   */
   size = mxGetNumberOfElements( prhs[1] );

   /*
   Allocate the memory for the window, provide the needed room for the
   control segment.
   */
   window = (SpiceDouble*)
             mxMalloc( (size + SPICE_CELL_CTRLSZ)*sizeof(SpiceDouble)  );

   /*
   Set to size and cardinality for the window before passing to CSPICE.
   */
   ssized_( ( integer * ) &size, ( double * ) window );
   scardd_( ( integer * ) &size, ( double * ) window );

   /*
   Copy the window data from the input window to the work window. The
   window data should begin at 'window' element SPICE_CELL_CTRLSZ.
   */
   MOVED( window_i, size, window  + SPICE_CELL_CTRLSZ);

   wnvald_ ( (integer    * ) &size,
             (integer    * ) &size,
             (doublereal * )  (window) );

   /*
   Check for a failure signal. Free the memory assigned to 'window'
   before signaling a Matlab error.
   */
   if ( failed_c())
      {
      mxFree( window );

      /*
      The mice_fail call creates the error string then returns control
      to the MATLAB interpreter.
      */
      mice_fail(SCALAR);
      }

   /*
   Array element 6, index 5, contains the cell cardinality. Create an output
   array CARDx1.
   */
   sizearray[0] = window[5];
   sizearray[1] = 1;

   plhs[0]  = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
   window_f = A_DBL_RET_ARGV(0);

   /*
   Copy the data contents of 'window' to 'window_f'. The set of window data
   starts at 'cover' array index SPICE_CELL_CTRLSZ and contains 'window[5]'
   elements.
   */
   MOVED( window + SPICE_CELL_CTRLSZ, window[5], window_f );
   mxFree( window );

   }




/*
   void              xf2eul_c ( ConstSpiceDouble     xform  [6][6],
                                SpiceInt             axisa,
                                SpiceInt             axisb,
                                SpiceInt             axisc,
                                SpiceDouble          eulang [6],
                                SpiceBoolean       * unique         );

*/
void cspice_xf2eul(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {
   SpiceDouble        * vec_xform;
   SpiceDouble        * vec_eulang;
   SpiceBoolean       * vec_unique;
   SpiceInt             axisa;
   SpiceInt             axisb;
   SpiceInt             axisc;
   SpiceDouble        * xform;
   SpiceDouble        * eulang;
   SpiceBoolean       * unique;

   mwIndex              i;
   SpiceDouble          xr[6][6];

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "xform",  MiceDouble,  2, {6, 6}, 1},
      { "axisa",  MiceInt,     0, {0},    0},
      { "axisb",  MiceInt,     0, {0},    0},
      { "axisc",  MiceInt,     0, {0},    0},
      { "eulang", MiceDouble,  1, {6},    1},
      { "unique", MiceBoolean, 0, {0},    1}
      };

   check_arg_num( nrhs, nlhs, 4, 2);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_xform  = A_DBL_ARGV(1);
   axisa      = S_INT_ARGV(2);
   axisb      = S_INT_ARGV(3);
   axisc      = S_INT_ARGV(4);
   vec_eulang = A_DBL_RET_ARGV(0);
   vec_unique = A_BOOL_RET_ARGV(1);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         xform  = (vec_xform  + i*extra->offset[0]);
         eulang = (vec_eulang + i*extra->offset[4]);
         unique = (vec_unique + i*extra->offset[5]);

         xpose6_c( xform, (SpiceDouble(*)[6])xr );

         xf2eul_c( xr, axisa, axisb, axisc, eulang, unique );
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {
      xform  = vec_xform;
      eulang = vec_eulang;
      unique = vec_unique;

      xpose6_c( xform, (SpiceDouble(*)[6])xr );

      xf2eul_c( xr, axisa, axisb, axisc, eulang, unique );
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void              xf2rav_c ( ConstSpiceDouble     xform [6][6],
                                SpiceDouble          rot   [3][3],
                                SpiceDouble          av    [3]     );
*/
void cspice_xf2rav(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {
   SpiceDouble  * vec_xform;
   SpiceDouble  * vec_rot;
   SpiceDouble  * vec_av;
   SpiceDouble  * xform;
   SpiceDouble  * rot;
   SpiceDouble  * av;
   SpiceDouble    xr[3][3];
   SpiceDouble    xf[6][6];

   mwIndex        i;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "xform", MiceDouble, 2, {6,6}, 1},
      { "rot",   MiceDouble, 2, {3,3}, 1},
      { "av",    MiceDouble, 1, {3},   1},
      };

   check_arg_num( nrhs, nlhs, 1, 2 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_xform = A_DBL_ARGV(1);
   vec_rot   = A_DBL_RET_ARGV(0);
   vec_av    = A_DBL_RET_ARGV(1);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         xform = (vec_xform  + i*extra->offset[0]);
         rot   = (vec_rot    + i*extra->offset[1]);
         av    = (vec_av     + i*extra->offset[2]);

         xpose6_c( xform, (SpiceDouble(*)[6])xf );

         xf2rav_c( xf, (SpiceDouble(*)[3])xr, av );
         CHECK_CALL_FAILURE(i);

         xpose_c( xr, (SpiceDouble(*)[3])rot );
         }

      }
   else
      {

      xform = (vec_xform);
      rot   = (vec_rot);
      av    = (vec_av);

      xpose6_c( xform, (SpiceDouble(*)[6])xf );

      xf2rav_c( xf, (SpiceDouble(*)[3])xr, av );
      CHECK_CALL_FAILURE(SCALAR);

      xpose_c( xr, (SpiceDouble(*)[3])rot );
      }

   }




/*
   void xfmsta_c ( ConstSpiceDouble     istate[6],
                   ConstSpiceChar     * icosys,
                   ConstSpiceChar     * ocosys,
                   ConstSpiceChar     * body,
                   SpiceDouble          ostate[6]  )
*/
void cspice_xfmsta(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble    * vec_istate;
   SpiceDouble    * istate;
   SpiceChar        icosys [DEFAULT_STR_LENGTH+1];
   SpiceChar        ocosys [DEFAULT_STR_LENGTH+1];
   SpiceChar        body   [DEFAULT_STR_LENGTH+1];
   SpiceDouble    * vec_ostate;
   SpiceDouble    * ostate;

   mwIndex          i;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "istate", MiceDouble, 1, {6}, 1},
      { "icosys", MiceChar,   0, {0}, 0},
      { "ocosys", MiceChar,   0, {0}, 0},
      { "body",   MiceChar,   0, {0}, 0},
      { "ostate", MiceDouble, 1, {6}, 1},
      };

   check_arg_num( nrhs, nlhs, 4, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[2], icosys, DEFAULT_STR_LENGTH);
   mxGetString(prhs[3], ocosys, DEFAULT_STR_LENGTH);
   mxGetString(prhs[4], body,   DEFAULT_STR_LENGTH);

   vec_istate = A_DBL_ARGV(1);
   vec_ostate = A_DBL_RET_ARGV(0);

   istate = (vec_istate);
   ostate = (vec_ostate);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         istate = (vec_istate + i*extra->offset[0]);
         ostate = (vec_ostate + i*extra->offset[4]);

         xfmsta_c( istate, icosys, ocosys, body, ostate );
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {

      xfmsta_c( istate, icosys, ocosys, body, ostate );
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
The cleanup routine called on exit.
*/
void mice_cleanup()
   {
   char                    msg[1024];

   hashtable_destroy();

   /*
   This error should never signal. If it does, an unknown error exists
   in the memory allocation routines - the computational equivalent
   of a warp core breach but with less noise.
   */
   if ( alloc_count() != 0 )
      {

      sprintf( msg, "\n"
                 "MICE(BUG): Memory allocation count not zero at "
                 "mexAtExit. Value = %d. This indicates an unexpected "
                 "error. Contact NAIF."
                 "\n\n",
                 alloc_count()  );
      mexErrMsgTxt(msg);
      }

   }




/*

   The routine called by MATLAB to access to external routines.

*/


/*
Now, with the interfaces defined above, include the name to function
pointer list.
*/
#include "npf_cspice.h"


void mexFunction( int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   /*
   Size of array of function name/pointer pairs.
   */
   static int SIZE = sizeof(NPF)/sizeof(NPF[0]);

   /*
   Initialize hash table first time through.
   */
   static SpiceBoolean   first = SPICETRUE;
   int                   i;
   int                   n;
   char                  erract_buf[1024];
   char                * function_name;
   integer               divisor = HASHSIZE;

   void                (*function_reference)(int,
                                             mxArray*[],
                                             int,
                                             const mxArray*[]);

   /*
   Ensure the user doesn't try to directly call the Mice library
   without arguments. Bad user.
   */
   if( nrhs == 0 )
      {
      sprintf( erract_buf,
            "MICE(BOGUSENTRY): Usage error. Do not call the Mice MEX "
            "library without arguments. Access Mice functions by "
            "calling the cspice_*.m or mice_*.m wrappers.");
      mexErrMsgTxt( erract_buf );
      }

   if (first)
      {

      /*
      Initialize the values needed by the hash value functions.
      */
      zzshsh_( &divisor );

      /*
      Initialize hash table
      */
      memset( table, 0, sizeof(table) );

      for ( i=0; i<SIZE; i++)
         {
         hashtable_insert(NPF[i].name, NPF[i].pfunc);
         }

      /*
      By default, CSPICE calls exit() when an error occurs. This response
      causes the MATLAB application to exit (collapse).

      All interface functions immediately execute the CHECK_CALL_FAILURE
      macro calling their CSPICE namesakes. This macro checks the failure_c
      state, making the needed calls to create a MATLAB error message
      if an error occurs.

      Set the error status to RETURN and the error device to NULL.
      */
      zzerrorinit();

      /*
      This block need execute only once. Set the 'first' flag to false.
      */
      first = SPICEFALSE;

      /*
      Register the clean up routine, i.e. the routine executed when
      MATLAB terminates.
      */
      mexAtExit(mice_cleanup);
      }


   /*
   Retrieve the cspice routine name from the function call. Note,
   the first right hand value, prhs[0], for all interface calls
   is a pointer to the interface string name. mxGetN returns the number
   of columns in a MATLAB array; MATLAB defines a string as a 1XN
   vector of characters, so mxGetN returns the length (not null terminated
   length) of the string. When allocating memory for the string, allocate
   N + 1 to accommodate the null terminator.
   */
   n             = mxGetN(prhs[0]) + 1;
   function_name = mxCalloc( n, sizeof(char));

   /*
   Extract the string name from the pointer.
   */
   mxGetString( prhs[0], function_name, n);

   /*
   Now find the address of the function corresponding to the call name...
   */
   function_reference = hashtable_lookup(function_name);

   /*
   ...if found, execute that function. If not found, signal an error
   to the user.
   */
   if (function_reference)
      {
      (*function_reference)(nlhs, plhs, nrhs, prhs);
      }
   else
      {
      sprintf( erract_buf,
            "MICE(UNKNOWNCALL): Unknown CSPICE interface function call: %s\n",
             function_name);

      mexErrMsgTxt( erract_buf );
      }

   mxFree(function_name);
   }
